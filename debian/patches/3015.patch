From c4974d7e62949abde0cca37f3f98f6a59896034c Mon Sep 17 00:00:00 2001
From: GloriousEggroll <gloriouseggroll@gmail.com>
Date: Sun, 23 Apr 2023 21:00:06 -0600
Subject: [PATCH] 3015 av1 backport

---
 gst-libs/gst/codecparsers/gstav1bitwriter.c | 2507 +++++++++++
 gst-libs/gst/codecparsers/gstav1bitwriter.h |   86 +
 gst-libs/gst/codecparsers/gstav1parser.c    |    4 +-
 gst-libs/gst/codecparsers/gstav1parser.h    |    5 +-
 gst-libs/gst/codecparsers/gstvp9bitwriter.c |  171 +
 gst-libs/gst/codecparsers/gstvp9bitwriter.h |   59 +
 gst-libs/gst/codecparsers/meson.build       |    2 +
 sys/va/gstvaav1enc.c                        | 4342 +++++++++++++++++++
 sys/va/gstvaav1enc.h                        |   34 +
 sys/va/gstvabaseenc.c                       |   90 +-
 sys/va/gstvabaseenc.h                       |   12 +-
 sys/va/gstvaencoder.c                       |   89 +-
 sys/va/gstvaencoder.h                       |    5 +-
 sys/va/gstvah264enc.c                       |   20 +-
 sys/va/gstvah265enc.c                       |   51 +-
 sys/va/gstvavp9enc.c                        | 3175 ++++++++++++++
 sys/va/gstvavp9enc.h                        |   34 +
 sys/va/meson.build                          |    6 +-
 sys/va/plugin.c                             |   18 +
 19 files changed, 10663 insertions(+), 47 deletions(-)
 create mode 100644 gst-libs/gst/codecparsers/gstav1bitwriter.c
 create mode 100644 gst-libs/gst/codecparsers/gstav1bitwriter.h
 create mode 100644 gst-libs/gst/codecparsers/gstvp9bitwriter.c
 create mode 100644 gst-libs/gst/codecparsers/gstvp9bitwriter.h
 create mode 100644 sys/va/gstvaav1enc.c
 create mode 100644 sys/va/gstvaav1enc.h
 create mode 100644 sys/va/gstvavp9enc.c
 create mode 100644 sys/va/gstvavp9enc.h

diff --git a/gst-libs/gst/codecparsers/gstav1bitwriter.c b/gst-libs/gst/codecparsers/gstav1bitwriter.c
new file mode 100644
index 0000000..9f04155
--- /dev/null
+++ b/gst-libs/gst/codecparsers/gstav1bitwriter.c
@@ -0,0 +1,2507 @@
+/* GStreamer
+ *  Copyright (C) 2022 Intel Corporation
+ *     Author: He Junyan <junyan.he@intel.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the0
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstav1bitwriter.h"
+#include <gst/base/gstbitwriter.h>
+
+#define WRITE_BITS_UNCHECK(bw, val, nbits)                                    \
+  (nbits <= 8 ? gst_bit_writer_put_bits_uint8 (bw, val, nbits) :              \
+   (nbits <= 16 ? gst_bit_writer_put_bits_uint16 (bw, val, nbits) :           \
+    (nbits <= 32 ? gst_bit_writer_put_bits_uint32 (bw, val, nbits) :          \
+     FALSE)))
+
+#define WRITE_BITS(bw, val, nbits)                                            \
+  if (!WRITE_BITS_UNCHECK (bw, val, nbits)) {                                 \
+    g_warning ("Unsupported bit size: %u", nbits);                            \
+    have_space = FALSE;                                                       \
+    goto error;                                                               \
+  }
+
+static guint
+_av1_uleb_size_in_bytes (guint64 value)
+{
+  guint size = 0;
+
+  do {
+    ++size;
+  } while ((value >>= 7) != 0);
+  return size;
+}
+
+static gboolean
+_av1_encode_uleb (guint64 value, guint available,
+    guint8 * coded_value, guint coded_size)
+{
+  const guint kMaximumLeb128Size = 8;
+  const guint leb_size = _av1_uleb_size_in_bytes (value);
+  const guint64 kMaximumLeb128Value = 0xffffffff /* 4294967295U */ ;
+
+  g_assert (coded_size == leb_size);
+
+  if (value > kMaximumLeb128Value || leb_size > kMaximumLeb128Size ||
+      leb_size > available || !coded_value) {
+    return FALSE;
+  }
+
+  for (guint i = 0; i < leb_size; ++i) {
+    guint8 byte = value & 0x7f;
+    value >>= 7;
+
+    if (value != 0)
+      byte |= 0x80;             // Signal that more bytes follow.
+
+    *(coded_value + i) = byte;
+  }
+
+  return TRUE;
+}
+
+/* 4.10.3
+ *
+ * Variable length unsigned n-bit number appearing directly in the
+ * bitstream */
+static gboolean
+_av1_write_uvlc (GstBitWriter * bw, guint32 value, gboolean * space)
+{
+  gboolean have_space = TRUE;
+  gint64 shift_val = value;
+  gint32 leading_zeroes = 1;
+
+  value++;
+
+  g_assert (shift_val > 0);
+
+  while (shift_val >>= 1)
+    leading_zeroes += 2;
+
+  WRITE_BITS (bw, 0, leading_zeroes >> 1);
+  WRITE_BITS (bw, value, (leading_zeroes + 1) >> 1);
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  *space = have_space;
+  return FALSE;
+}
+
+static gint
+_av1_helper_msb (guint n)
+{
+  int log = 0;
+  guint value = n;
+  int i;
+
+  g_assert (n != 0);
+
+  for (i = 4; i >= 0; --i) {
+    const gint shift = (1 << i);
+    const guint x = value >> shift;
+
+    if (x != 0) {
+      value = x;
+      log += shift;
+    }
+  }
+  return log;
+}
+
+static gboolean
+_av1_write_uniform (GstBitWriter * bw, guint32 max_value, guint32 value,
+    gboolean * space)
+{
+  gboolean have_space = TRUE;
+  const gint l = max_value ? _av1_helper_msb (max_value) + 1 : 0;
+  const gint m = (1 << l) - max_value;
+
+  if (l == 0)
+    goto success;
+
+  if (value < m) {
+    WRITE_BITS (bw, value, l - 1);
+  } else {
+    WRITE_BITS (bw, m + ((value - m) >> 1), l - 1);
+    WRITE_BITS (bw, (value - m) & 1, 1);
+  }
+
+success:
+  *space = TRUE;
+  return TRUE;
+
+error:
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.9.13
+ *
+ * Delta quantizer */
+static gboolean
+_av1_write_delta_q (GstBitWriter * bw, gint32 delta_q, gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  if (delta_q != 0) {
+    WRITE_BITS (bw, 1, 1);
+    WRITE_BITS (bw, delta_q, 7);
+  } else {
+    WRITE_BITS (bw, 0, 1);
+  }
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  *space = have_space;
+  return FALSE;
+}
+
+/* 4.10.6
+ *
+ * su(n) */
+static gboolean
+_av1_write_su (GstBitWriter * bw, gint32 val, guint n, gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  g_assert (n < 31);
+  WRITE_BITS (bw, val, n + 1);
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.9.16 Tile size calculation
+ *
+ * returns the smallest value for k such that blkSize << k is greater
+ * than or equal to target */
+static gint
+_av1_helper_tile_log2 (gint blkSize, gint target)
+{
+  gint k;
+
+  for (k = 0; (blkSize << k) < target; k++);
+
+  return k;
+}
+
+static gboolean
+_av1_write_primitive_quniform (GstBitWriter * bw, guint16 n, guint16 v,
+    gboolean * space)
+{
+  gboolean have_space = TRUE;
+  const gint l = _av1_helper_msb (n) + 1;
+  const gint m = (1 << l) - n;
+
+  if (n <= 1)
+    goto success;
+
+  if (v < m) {
+    WRITE_BITS (bw, v, l - 1);
+  } else {
+    WRITE_BITS (bw, m + ((v - m) >> 1), l - 1);
+    WRITE_BITS (bw, (v - m) & 1, 1);
+  }
+
+success:
+  *space = TRUE;
+  return TRUE;
+
+error:
+  *space = have_space;
+  return FALSE;
+}
+
+static gboolean
+_av1_write_primitive_subexpfin (GstBitWriter * bw, guint16 n, guint16 k,
+    guint16 v, gboolean * space)
+{
+  gboolean have_space = TRUE;
+  gint i = 0;
+  gint mk = 0;
+
+  while (1) {
+    gint b = (i ? k + i - 1 : k);
+    gint a = (1 << b);
+
+    if (n <= mk + 3 * a) {
+      if (!_av1_write_primitive_quniform (bw, n - mk, v - mk, space))
+        goto error;
+
+      break;
+    } else {
+      gint t = (v >= mk + a);
+      WRITE_BITS (bw, t, 1);
+      if (t) {
+        i = i + 1;
+        mk += a;
+      } else {
+        WRITE_BITS (bw, v - mk, b);
+        break;
+      }
+    }
+  }
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  *space = have_space;
+  return FALSE;
+}
+
+/* Recenters a non-negative literal v around a reference r */
+static guint16
+_av1_helper_recenter_nonneg (guint16 r, guint16 v)
+{
+  if (v > (r << 1))
+    return v;
+  else if (v >= r)
+    return ((v - r) << 1);
+  else
+    return ((r - v) << 1) - 1;
+}
+
+/* Recenters a non-negative literal v in [0, n-1] around
+   a reference r also in [0, n-1] */
+static guint16
+_av1_helper_recenter_finite_nonneg (guint16 n, guint16 r, guint16 v)
+{
+  if ((r << 1) <= n) {
+    return _av1_helper_recenter_nonneg (r, v);
+  } else {
+    return _av1_helper_recenter_nonneg (n - 1 - r, n - 1 - v);
+  }
+}
+
+static gboolean
+_av1_write_primitive_refsubexpfin (GstBitWriter * bw,
+    guint16 n, guint16 k, guint16 ref, guint16 v, gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  if (!_av1_write_primitive_subexpfin (bw, n, k,
+          _av1_helper_recenter_finite_nonneg (n, ref, v), space))
+    goto error;
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  *space = have_space;
+  return FALSE;
+}
+
+static gboolean
+_av1_write_signed_primitive_refsubexpfin (GstBitWriter * bw,
+    guint16 n, guint16 k, gint16 ref, gint16 v, gboolean * space)
+{
+  gboolean have_space = TRUE;
+  const guint16 scaled_n = (n << 1) - 1;
+  ref += n - 1;
+  v += n - 1;
+
+  if (!_av1_write_primitive_refsubexpfin (bw, scaled_n, k, ref, v, space))
+    goto error;
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  *space = have_space;
+  return FALSE;
+}
+
+static gboolean
+_av1_seq_level_idx_is_valid (GstAV1SeqLevels seq_level_idx)
+{
+  return seq_level_idx == GST_AV1_SEQ_LEVEL_MAX
+      || (seq_level_idx < GST_AV1_SEQ_LEVELS
+      /* The following levels are currently undefined. */
+      && seq_level_idx != GST_AV1_SEQ_LEVEL_2_2
+      && seq_level_idx != GST_AV1_SEQ_LEVEL_2_3
+      && seq_level_idx != GST_AV1_SEQ_LEVEL_3_2
+      && seq_level_idx != GST_AV1_SEQ_LEVEL_3_3
+      && seq_level_idx != GST_AV1_SEQ_LEVEL_4_2
+      && seq_level_idx != GST_AV1_SEQ_LEVEL_4_3
+      && seq_level_idx != GST_AV1_SEQ_LEVEL_7_0
+      && seq_level_idx != GST_AV1_SEQ_LEVEL_7_1
+      && seq_level_idx != GST_AV1_SEQ_LEVEL_7_2
+      && seq_level_idx != GST_AV1_SEQ_LEVEL_7_3);
+}
+
+static gboolean
+_av1_bit_writer_timing_info (const GstAV1TimingInfo * timing_info,
+    GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  GST_DEBUG ("writing timing info");
+
+  if (timing_info->num_units_in_display_tick == 0 ||
+      timing_info->time_scale == 0)
+    goto error;
+
+  WRITE_BITS (bw, timing_info->num_units_in_display_tick, 32);
+  WRITE_BITS (bw, timing_info->time_scale, 32);
+
+  WRITE_BITS (bw, timing_info->equal_picture_interval, 1);
+  if (timing_info->equal_picture_interval) {
+    if (timing_info->num_ticks_per_picture_minus_1 == G_MAXUINT)
+      goto error;
+
+    if (!_av1_write_uvlc (bw, timing_info->num_ticks_per_picture_minus_1,
+            &have_space))
+      goto error;
+  }
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write timing info");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.5.4 */
+static gboolean
+_av1_bit_writer_decoder_model_info (const GstAV1DecoderModelInfo *
+    decoder_model_info, GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  GST_DEBUG ("writing decoder model info");
+
+  WRITE_BITS (bw, decoder_model_info->buffer_delay_length_minus_1, 5);
+  WRITE_BITS (bw, decoder_model_info->num_units_in_decoding_tick, 32);
+  WRITE_BITS (bw, decoder_model_info->buffer_removal_time_length_minus_1, 5);
+  WRITE_BITS (bw, decoder_model_info->frame_presentation_time_length_minus_1,
+      5);
+
+  *space = TRUE;
+  return TRUE;
+error:
+  GST_WARNING ("failed to write decoder model info");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.5.5 */
+static gboolean
+_av1_bit_writer_operating_parameters_info (const GstAV1SequenceHeaderOBU *
+    seq_header, const GstAV1OperatingPoint * op_point, GstBitWriter * bw,
+    gboolean * space)
+{
+  gboolean have_space = TRUE;
+  guint32 n = seq_header->decoder_model_info.buffer_delay_length_minus_1 + 1;
+
+  GST_DEBUG ("writing operating parameters info");
+
+  if (n > 32)
+    goto error;
+
+  WRITE_BITS (bw, op_point->decoder_buffer_delay, n);
+  WRITE_BITS (bw, op_point->encoder_buffer_delay, n);
+  WRITE_BITS (bw, op_point->low_delay_mode_flag, 1);
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write operating parameters info");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.5.2 */
+static gboolean
+_av1_bit_writer_color_config (const GstAV1SequenceHeaderOBU * seq_header,
+    const GstAV1ColorConfig * color_config, GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  GST_DEBUG ("writing color config");
+
+  WRITE_BITS (bw, color_config->high_bitdepth, 1);
+
+  if (seq_header->seq_profile == GST_AV1_PROFILE_2
+      && color_config->high_bitdepth) {
+    WRITE_BITS (bw, color_config->twelve_bit, 1);
+  } else if (seq_header->seq_profile > GST_AV1_PROFILE_2) {
+    GST_WARNING ("Unsupported profile/bit-depth combination");
+    goto error;
+  }
+
+  if (seq_header->seq_profile != GST_AV1_PROFILE_1)
+    WRITE_BITS (bw, color_config->mono_chrome, 1);
+
+  if (seq_header->num_planes != 1 && seq_header->num_planes != 3) {
+    GST_WARNING ("num_planes is not correct");
+    goto error;
+  }
+  if (!color_config->mono_chrome && seq_header->num_planes != 3) {
+    GST_WARNING ("num_planes is not correct");
+    goto error;
+  }
+
+  WRITE_BITS (bw, color_config->color_description_present_flag, 1);
+
+  if (color_config->color_description_present_flag) {
+    WRITE_BITS (bw, color_config->color_primaries, 8);
+    WRITE_BITS (bw, color_config->transfer_characteristics, 8);
+    WRITE_BITS (bw, color_config->matrix_coefficients, 8);
+  }
+
+  if (color_config->mono_chrome) {
+    if (color_config->subsampling_x != 1 || color_config->subsampling_y != 1) {
+      GST_WARNING ("set subsampling_x or subsampling_y wrong value");
+      goto error;
+    }
+
+    WRITE_BITS (bw, color_config->color_range, 1);
+    goto success;
+  } else if (color_config->color_primaries == GST_AV1_CP_BT_709 &&
+      color_config->transfer_characteristics == GST_AV1_TC_SRGB &&
+      color_config->matrix_coefficients == GST_AV1_MC_IDENTITY) {
+
+    if (color_config->color_range != 1) {
+      GST_WARNING ("set color_range wrong value");
+      goto error;
+    }
+
+    if (color_config->subsampling_x != 0 || color_config->subsampling_y != 0) {
+      GST_WARNING ("set subsampling_x or subsampling_y wrong value");
+      goto error;
+    }
+
+    if (!(seq_header->seq_profile == GST_AV1_PROFILE_1 ||
+            (seq_header->seq_profile == GST_AV1_PROFILE_2
+                && seq_header->bit_depth == 12))) {
+      GST_WARNING ("sRGB colorspace not compatible with specified profile");
+      goto error;
+    }
+  } else {
+    WRITE_BITS (bw, color_config->color_range, 1);
+
+    if (seq_header->seq_profile == GST_AV1_PROFILE_0) {
+      if (color_config->subsampling_x != 1 || color_config->subsampling_y != 1) {
+        GST_WARNING ("set subsampling_x or subsampling_y wrong value");
+        goto error;
+      }
+    } else if (seq_header->seq_profile == GST_AV1_PROFILE_1) {
+      if (color_config->subsampling_x != 0 || color_config->subsampling_y != 0) {
+        GST_WARNING ("set subsampling_x or subsampling_y wrong value");
+        goto error;
+      }
+    } else if (seq_header->seq_profile == GST_AV1_PROFILE_2) {
+      if (seq_header->bit_depth == 12) {
+        WRITE_BITS (bw, color_config->subsampling_x, 1);
+
+        if (color_config->subsampling_x) {
+          /* 422 or 420 */
+          WRITE_BITS (bw, color_config->subsampling_y, 1);
+        }
+      }
+    }
+
+    if (color_config->subsampling_x && color_config->subsampling_y)
+      WRITE_BITS (bw, color_config->chroma_sample_position, 2);
+  }
+
+  WRITE_BITS (bw, color_config->separate_uv_delta_q, 1);
+
+  if (!(color_config->subsampling_x == 0 && color_config->subsampling_y == 0) &&
+      !(color_config->subsampling_x == 1 && color_config->subsampling_y == 1) &&
+      !(color_config->subsampling_x == 1 && color_config->subsampling_y == 0)) {
+    GST_WARNING ("Only 4:4:4, 4:2:2 and 4:2:0 are currently supported, "
+        "%d %d subsampling is not supported.\n",
+        color_config->subsampling_x, color_config->subsampling_y);
+    goto error;
+  }
+
+success:
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write color config");
+  *space = have_space;
+  return FALSE;
+}
+
+static gboolean
+_av1_bit_writer_sequence_header (const GstAV1SequenceHeaderOBU * seq_header,
+    GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+  gint i;
+
+  GST_DEBUG ("writing sequence header");
+
+  if (seq_header->seq_profile > GST_AV1_PROFILE_2) {
+    GST_WARNING ("Unsupported profile %d", seq_header->seq_profile);
+    goto error;
+  }
+  WRITE_BITS (bw, seq_header->seq_profile, 3);
+
+  WRITE_BITS (bw, seq_header->still_picture, 1);
+
+  if (!seq_header->still_picture && seq_header->reduced_still_picture_header) {
+    GST_WARNING (" If reduced_still_picture_header is equal to 1, it is a"
+        " requirement of bitstream conformance that still_picture is equal"
+        " to 1. ");
+    goto error;
+  }
+  WRITE_BITS (bw, seq_header->reduced_still_picture_header, 1);
+
+  if (seq_header->reduced_still_picture_header) {
+    if (!_av1_seq_level_idx_is_valid
+        (seq_header->operating_points[0].seq_level_idx)) {
+      GST_WARNING ("The seq_level_idx is unsupported");
+      goto error;
+    }
+    WRITE_BITS (bw, seq_header->operating_points[0].seq_level_idx, 5);
+  } else {
+    WRITE_BITS (bw, seq_header->timing_info_present_flag, 1);
+    if (seq_header->timing_info_present_flag) {
+      if (!_av1_bit_writer_timing_info (&seq_header->timing_info, bw,
+              &have_space))
+        goto error;
+
+      WRITE_BITS (bw, seq_header->decoder_model_info_present_flag, 1);
+      if (seq_header->decoder_model_info_present_flag) {
+        if (!_av1_bit_writer_decoder_model_info
+            (&seq_header->decoder_model_info, bw, &have_space))
+          goto error;
+      }
+    }
+
+    WRITE_BITS (bw, seq_header->initial_display_delay_present_flag, 1);
+
+    if (seq_header->operating_points_cnt_minus_1 + 1 >
+        GST_AV1_MAX_OPERATING_POINTS) {
+      GST_WARNING ("The operating points number %d is too big",
+          seq_header->operating_points_cnt_minus_1 + 1);
+      goto error;
+    }
+    WRITE_BITS (bw, seq_header->operating_points_cnt_minus_1, 5);
+
+    for (i = 0; i < seq_header->operating_points_cnt_minus_1 + 1; i++) {
+      const GstAV1OperatingPoint *op = &seq_header->operating_points[i];
+
+      WRITE_BITS (bw, op->idc, 12);
+
+      if (!_av1_seq_level_idx_is_valid (op->seq_level_idx)) {
+        GST_WARNING ("The seq_level_idx is unsupported");
+        goto error;
+      }
+      WRITE_BITS (bw, op->seq_level_idx, 5);
+
+      if (op->seq_level_idx > GST_AV1_SEQ_LEVEL_3_3)
+        WRITE_BITS (bw, op->seq_tier, 1);
+
+      if (seq_header->decoder_model_info_present_flag) {
+        WRITE_BITS (bw, op->decoder_model_present_for_this_op, 1);
+        if (op->decoder_model_present_for_this_op) {
+          if (!_av1_bit_writer_operating_parameters_info (seq_header,
+                  op, bw, &have_space))
+            goto error;
+        }
+      }
+
+      if (seq_header->initial_display_delay_present_flag) {
+        WRITE_BITS (bw, op->initial_display_delay_present_for_this_op, 1);
+
+        if (op->initial_display_delay_present_for_this_op) {
+          if (op->initial_display_delay_minus_1 + 1 > 10) {
+            GST_INFO ("AV1 does not support more than 10 decoded frames delay");
+            goto error;
+          }
+
+          WRITE_BITS (bw, op->initial_display_delay_minus_1, 4);
+        }
+      }
+    }
+  }
+
+  WRITE_BITS (bw, seq_header->frame_width_bits_minus_1, 4);
+  WRITE_BITS (bw, seq_header->frame_height_bits_minus_1, 4);
+  WRITE_BITS (bw, seq_header->max_frame_width_minus_1,
+      seq_header->frame_width_bits_minus_1 + 1);
+  WRITE_BITS (bw, seq_header->max_frame_height_minus_1,
+      seq_header->frame_height_bits_minus_1 + 1);
+
+  if (!seq_header->reduced_still_picture_header)
+    WRITE_BITS (bw, seq_header->frame_id_numbers_present_flag, 1);
+
+  if (seq_header->frame_id_numbers_present_flag) {
+    if (seq_header->additional_frame_id_length_minus_1 + 1 +
+        seq_header->delta_frame_id_length_minus_2 + 2 > 16) {
+      GST_WARNING ("Invalid frame_id_length");
+      goto error;
+    }
+    WRITE_BITS (bw, seq_header->delta_frame_id_length_minus_2, 4);
+    WRITE_BITS (bw, seq_header->additional_frame_id_length_minus_1, 3);
+  }
+
+  WRITE_BITS (bw, seq_header->use_128x128_superblock, 1);
+  WRITE_BITS (bw, seq_header->enable_filter_intra, 1);
+  WRITE_BITS (bw, seq_header->enable_intra_edge_filter, 1);
+
+  if (!seq_header->reduced_still_picture_header) {
+    WRITE_BITS (bw, seq_header->enable_interintra_compound, 1);
+    WRITE_BITS (bw, seq_header->enable_masked_compound, 1);
+    WRITE_BITS (bw, seq_header->enable_warped_motion, 1);
+    WRITE_BITS (bw, seq_header->enable_dual_filter, 1);
+    WRITE_BITS (bw, seq_header->enable_order_hint, 1);
+    if (seq_header->enable_order_hint) {
+      WRITE_BITS (bw, seq_header->enable_jnt_comp, 1);
+      WRITE_BITS (bw, seq_header->enable_ref_frame_mvs, 1);
+    }
+
+    WRITE_BITS (bw, seq_header->seq_choose_screen_content_tools, 1);
+    if (!seq_header->seq_choose_screen_content_tools)
+      WRITE_BITS (bw, seq_header->seq_force_screen_content_tools, 1);
+
+    if (seq_header->seq_force_screen_content_tools > 0) {
+      WRITE_BITS (bw, seq_header->seq_choose_integer_mv, 1);
+      if (!seq_header->seq_choose_integer_mv)
+        WRITE_BITS (bw, seq_header->seq_force_integer_mv, 1);
+    }
+
+    if (seq_header->enable_order_hint)
+      WRITE_BITS (bw, seq_header->order_hint_bits_minus_1, 3);
+  }
+
+  WRITE_BITS (bw, seq_header->enable_superres, 1);
+  WRITE_BITS (bw, seq_header->enable_cdef, 1);
+  WRITE_BITS (bw, seq_header->enable_restoration, 1);
+
+  if (!_av1_bit_writer_color_config (seq_header, &seq_header->color_config,
+          bw, &have_space))
+    goto error;
+
+  WRITE_BITS (bw, seq_header->film_grain_params_present, 1);
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write sequence header");
+  *space = have_space;
+  return FALSE;
+}
+
+static gboolean
+_av1_bit_writer_add_size_field (guint8 * data, guint * size, guint header_size,
+    guint payload_size, gboolean * space)
+{
+  guint size_field_size;
+
+  /* Move and write the data size field */
+  size_field_size = _av1_uleb_size_in_bytes (payload_size);
+  if (header_size + payload_size + size_field_size > *size) {
+    *space = FALSE;
+    goto error;
+  }
+  *space = TRUE;
+
+  memmove (data + header_size + size_field_size,
+      data + header_size, payload_size);
+
+  if (!_av1_encode_uleb (payload_size, sizeof (payload_size),
+          data + header_size, size_field_size))
+    goto error;
+
+  *size = header_size + payload_size + size_field_size;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write the size field");
+  return FALSE;
+}
+
+/**
+ * gst_av1_bit_writer_sequence_header_obu:
+ * @seq_hdr: the sequence header of #GstAV1SequenceHeaderOBU to write
+ * @size_field: whether the header contain size feild
+ * @data: (out): the bit stream generated by the sequence header
+ * @size: (inout): the size in bytes of the input and output
+ *
+ * Generating the according AV1 bit stream OBU by providing the sequence header.
+ *
+ * Returns: a #GstAV1BitWriterResult
+ *
+ * Since: 1.22
+ **/
+GstAV1BitWriterResult
+gst_av1_bit_writer_sequence_header_obu (const GstAV1SequenceHeaderOBU *
+    seq_hdr, gboolean size_field, guint8 * data, guint * size)
+{
+  gboolean have_space = TRUE;
+  GstBitWriter bw;
+  guint header_size;
+  guint payload_size;
+
+  g_return_val_if_fail (seq_hdr != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (data != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (size != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (*size > 0, GST_AV1_BIT_WRITER_ERROR);
+
+  gst_bit_writer_init_with_data (&bw, data, *size, FALSE);
+
+  /* obu_forbidden_bit */
+  WRITE_BITS (&bw, 0, 1);
+  /* obu_type */
+  WRITE_BITS (&bw, GST_AV1_OBU_SEQUENCE_HEADER, 4);
+  /* obu_extention_flag */
+  WRITE_BITS (&bw, 0, 1);
+  /* obu_has_size_field */
+  WRITE_BITS (&bw, 1, 1);
+  /* obu_reserved_1bit */
+  WRITE_BITS (&bw, 0, 1);
+
+  header_size = gst_bit_writer_get_size (&bw);
+  g_assert (header_size % 8 == 0);
+  header_size /= 8;
+
+  if (!_av1_bit_writer_sequence_header (seq_hdr, &bw, &have_space))
+    goto error;
+
+  /* Add trailings. */
+  WRITE_BITS (&bw, 1, 1);
+  if (!gst_bit_writer_align_bytes (&bw, 0)) {
+    have_space = FALSE;
+    goto error;
+  }
+
+  payload_size = gst_bit_writer_get_size (&bw);
+  g_assert (payload_size % 8 == 0);
+  payload_size /= 8;
+  payload_size -= header_size;
+
+  gst_bit_writer_reset (&bw);
+
+  if (size_field) {
+    if (!_av1_bit_writer_add_size_field (data, size,
+            header_size, payload_size, &have_space))
+      goto error;
+  } else {
+    *size = header_size + payload_size;
+  }
+
+  return GST_AV1_BIT_WRITER_OK;
+
+error:
+  gst_bit_writer_reset (&bw);
+  *size = 0;
+  return have_space ? GST_AV1_BIT_WRITER_INVALID_DATA :
+      GST_AV1_BIT_WRITER_NO_MORE_SPACE;
+}
+
+/* 5.9.5 */
+static gboolean
+_av1_bit_writer_superres_params (const GstAV1FrameHeaderOBU * frame_header,
+    const GstAV1SequenceHeaderOBU * seq_header, GstBitWriter * bw,
+    gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  GST_DEBUG ("writing superres param");
+
+  if (seq_header->enable_superres)
+    WRITE_BITS (bw, frame_header->use_superres, 1);
+
+  if (frame_header->use_superres) {
+    guint8 coded_denom;
+
+    if (frame_header->superres_denom < GST_AV1_SUPERRES_DENOM_MIN)
+      goto error;
+
+    coded_denom = frame_header->superres_denom - GST_AV1_SUPERRES_DENOM_MIN;
+    if (coded_denom > (1 << GST_AV1_SUPERRES_DENOM_BITS) - 1)
+      goto error;
+
+    WRITE_BITS (bw, coded_denom, GST_AV1_SUPERRES_DENOM_BITS);
+  }
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write superres param");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.9.5 */
+static gboolean
+_av1_bit_writer_frame_size (const GstAV1FrameHeaderOBU * frame_header,
+    const GstAV1SequenceHeaderOBU * seq_header, GstBitWriter * bw,
+    gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  GST_DEBUG ("writing frame size");
+
+  if (frame_header->frame_size_override_flag) {
+    guint16 frame_width_minus_1;
+    guint16 frame_height_minus_1;
+
+    frame_width_minus_1 = frame_header->frame_width - 1;
+    WRITE_BITS (bw, frame_width_minus_1,
+        seq_header->frame_width_bits_minus_1 + 1);
+    frame_height_minus_1 = frame_header->frame_height - 1;
+    WRITE_BITS (bw, frame_height_minus_1,
+        seq_header->frame_height_bits_minus_1 + 1);
+  }
+
+  if (!_av1_bit_writer_superres_params (frame_header, seq_header, bw, space))
+    goto error;
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write frame size");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.9.6 */
+static gboolean
+_av1_bit_writer_render_size (const GstAV1FrameHeaderOBU * frame_header,
+    GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  GST_DEBUG ("writing render size");
+
+  WRITE_BITS (bw, frame_header->render_and_frame_size_different, 1);
+
+  if (frame_header->render_and_frame_size_different) {
+    guint16 render_width_minus_1 = frame_header->render_width - 1;
+    guint16 render_height_minus_1 = frame_header->render_height - 1;
+
+    WRITE_BITS (bw, render_width_minus_1, 16);
+    WRITE_BITS (bw, render_height_minus_1, 16);
+  }
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write render size");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.9.15 */
+static gboolean
+_av1_bit_writer_tile_info (const GstAV1FrameHeaderOBU * frame_header,
+    const GstAV1SequenceHeaderOBU * seq_header, GstBitWriter * bw,
+    gboolean * space)
+{
+  gboolean have_space = TRUE;
+  const GstAV1TileInfo *tile_info;
+  guint32 mi_cols /* MiCols */ ;
+  guint32 mi_rows /* MiRows */ ;
+  gint sb_cols /* sbCols */ ;
+  gint sb_rows /* sbRows */ ;
+  gint sb_shift /*sbShift */ ;
+  gint sb_size /* sbSize */ ;
+  gint max_tile_width_sb /* maxTileWidthSb */ ;
+  gint max_tile_height_sb /* maxTileHeightSb */ ;
+  gint max_tile_area_sb /* maxTileAreaSb */ ;
+  gint min_log2_tile_cols /* minLog2TileCols */ ;
+  gint max_log2_tile_cols /* maxLog2TileCols */ ;
+  gint min_log2_tile_rows /* minLog2TileRows */ ;
+  gint max_log2_tile_rows /* maxLog2TileRows */ ;
+  gint min_log2_tiles /* minLog2Tiles */ ;
+  gint size_sb /* sizeSb */ ;
+  gint widest_tile_sb /* widestTileSb */ ;
+
+  tile_info = &frame_header->tile_info;
+
+  GST_DEBUG ("writing tile info");
+
+  /* User must specify the frame resolution. */
+  if (frame_header->frame_width == 0 || frame_header->frame_height == 0) {
+    GST_WARNING ("unknown frame_width or frame_height");
+    goto error;
+  }
+
+  mi_cols = 2 * ((frame_header->frame_width + 7) >> 3);
+  mi_rows = 2 * ((frame_header->frame_height + 7) >> 3);
+
+  sb_cols = seq_header->use_128x128_superblock ?
+      ((mi_cols + 31) >> 5) : ((mi_cols + 15) >> 4);
+  sb_rows = seq_header->use_128x128_superblock ?
+      ((mi_rows + 31) >> 5) : ((mi_rows + 15) >> 4);
+  sb_shift = seq_header->use_128x128_superblock ? 5 : 4;
+  sb_size = sb_shift + 2;
+
+  max_tile_width_sb = GST_AV1_MAX_TILE_WIDTH >> sb_size;
+  max_tile_area_sb = GST_AV1_MAX_TILE_AREA >> (2 * sb_size);
+  min_log2_tile_cols = _av1_helper_tile_log2 (max_tile_width_sb, sb_cols);
+  max_log2_tile_cols = _av1_helper_tile_log2 (1, MIN (sb_cols,
+          GST_AV1_MAX_TILE_COLS));
+  max_log2_tile_rows = _av1_helper_tile_log2 (1, MIN (sb_rows,
+          GST_AV1_MAX_TILE_ROWS));
+  min_log2_tiles = MAX (min_log2_tile_cols,
+      _av1_helper_tile_log2 (max_tile_area_sb, sb_rows * sb_cols));
+
+  WRITE_BITS (bw, tile_info->uniform_tile_spacing_flag, 1);
+  if (tile_info->uniform_tile_spacing_flag) {
+    /* columns */
+    gint ones = tile_info->tile_cols_log2 - min_log2_tile_cols;
+    if (ones < 0)
+      goto error;
+
+    while (ones--)
+      WRITE_BITS (bw, 1, 1);
+    if (tile_info->tile_cols_log2 < max_log2_tile_cols)
+      WRITE_BITS (bw, 0, 1);
+
+    /* rows */
+    min_log2_tile_rows = MAX (min_log2_tiles - tile_info->tile_cols_log2, 0);
+    ones = tile_info->tile_rows_log2 - min_log2_tile_rows;
+    if (ones < 0)
+      goto error;
+
+    while (ones--)
+      WRITE_BITS (bw, 1, 1);
+    if (tile_info->tile_rows_log2 < max_log2_tile_rows)
+      WRITE_BITS (bw, 0, 1);
+  } else {
+    /* Explicit tiles with configurable tile widths and heights */
+    guint i;
+    guint width_sb;
+    guint height_sb;
+
+    widest_tile_sb = 0;
+
+    /* columns */
+    width_sb = sb_cols;
+    for (i = 0; i < tile_info->tile_cols; i++) {
+      size_sb = tile_info->mi_col_starts[i + 1] - tile_info->mi_col_starts[i];
+      size_sb = size_sb >> sb_shift;
+      widest_tile_sb = MAX (size_sb, widest_tile_sb);
+      if (_av1_write_uniform (bw, MIN (width_sb, max_tile_width_sb),
+              size_sb - 1, &have_space))
+        goto error;
+
+      width_sb -= size_sb;
+    }
+
+    if (width_sb != 0)
+      goto error;
+
+    // rows
+    if (min_log2_tiles > 0) {
+      max_tile_area_sb = (sb_rows * sb_cols) >> (min_log2_tiles + 1);
+    } else {
+      max_tile_area_sb = sb_rows * sb_cols;
+    }
+
+    max_tile_height_sb = MAX (max_tile_area_sb / widest_tile_sb, 1);
+
+    height_sb = sb_rows;
+    for (i = 0; i < tile_info->tile_rows; i++) {
+      size_sb = tile_info->mi_row_starts[i + 1] - tile_info->mi_row_starts[i];
+      size_sb = size_sb >> sb_shift;
+      if (_av1_write_uniform (bw, MIN (height_sb, max_tile_height_sb),
+              size_sb - 1, &have_space))
+        goto error;
+
+      height_sb -= size_sb;
+    }
+
+    if (height_sb != 0)
+      goto error;
+  }
+
+  if (tile_info->tile_cols_log2 > 0 || tile_info->tile_rows_log2 > 0) {
+    WRITE_BITS (bw, tile_info->context_update_tile_id,
+        tile_info->tile_cols_log2 + tile_info->tile_rows_log2);
+
+    WRITE_BITS (bw, tile_info->tile_size_bytes_minus_1, 2);
+  }
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write tile info");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.9.12 */
+static gboolean
+_av1_bit_writer_quantization_params (const GstAV1FrameHeaderOBU * frame_header,
+    const GstAV1SequenceHeaderOBU * seq_header, guint * qindex_offset,
+    GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+  const GstAV1QuantizationParams *quant_params =
+      &(frame_header->quantization_params);
+
+  GST_DEBUG ("writing quantization params");
+
+  if (qindex_offset)
+    *qindex_offset = gst_bit_writer_get_size (bw);
+
+  WRITE_BITS (bw, quant_params->base_q_idx, 8);
+
+  if (!_av1_write_delta_q (bw,
+          frame_header->quantization_params.delta_q_y_dc, &have_space))
+    goto error;
+
+  if (seq_header->num_planes > 1) {
+    if (seq_header->color_config.separate_uv_delta_q)
+      WRITE_BITS (bw, quant_params->diff_uv_delta, 1);
+
+    if (!_av1_write_delta_q (bw,
+            frame_header->quantization_params.delta_q_u_dc, &have_space))
+      goto error;
+
+    if (!_av1_write_delta_q (bw,
+            frame_header->quantization_params.delta_q_u_ac, &have_space))
+      goto error;
+
+    if (quant_params->diff_uv_delta) {
+      if (!_av1_write_delta_q (bw,
+              frame_header->quantization_params.delta_q_v_dc, &have_space))
+        goto error;
+
+      if (!_av1_write_delta_q (bw,
+              frame_header->quantization_params.delta_q_v_ac, &have_space))
+        goto error;
+    }
+  }
+
+  WRITE_BITS (bw, quant_params->using_qmatrix, 1);
+  if (quant_params->using_qmatrix) {
+    WRITE_BITS (bw, quant_params->qm_y, 4);
+    WRITE_BITS (bw, quant_params->qm_u, 4);
+
+    if (seq_header->color_config.separate_uv_delta_q)
+      WRITE_BITS (bw, quant_params->qm_v, 4);
+  }
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write quantization params");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.9.14 */
+static gboolean
+_av1_bit_writer_segmentation_params (const GstAV1FrameHeaderOBU * frame_header,
+    const GstAV1SequenceHeaderOBU * seq_header, guint * segmentation_offset,
+    GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  GST_DEBUG ("writing segmentation params");
+
+  if (segmentation_offset)
+    *segmentation_offset = gst_bit_writer_get_size (bw);
+
+  /* TODO: segmentation support. */
+  if (frame_header->segmentation_params.segmentation_enabled) {
+    GST_WARNING ("segmentation is not supported now");
+    goto error;
+  }
+
+  WRITE_BITS (bw, frame_header->segmentation_params.segmentation_enabled, 1);
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write segmentation params");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.9.17 */
+static gboolean
+_av1_bit_writer_delta_q_params (const GstAV1FrameHeaderOBU * frame_header,
+    const GstAV1SequenceHeaderOBU * seq_header, GstBitWriter * bw,
+    gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  GST_DEBUG ("writing delta q params");
+
+  if (frame_header->quantization_params.base_q_idx > 0)
+    WRITE_BITS (bw, frame_header->quantization_params.delta_q_present, 1);
+
+  if (frame_header->quantization_params.delta_q_present)
+    WRITE_BITS (bw, frame_header->quantization_params.delta_q_res, 2);
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write delta q params");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.9.18 */
+static gboolean
+_av1_bit_writer_delta_lf_params (const GstAV1FrameHeaderOBU * frame_header,
+    const GstAV1SequenceHeaderOBU * seq_header, GstBitWriter * bw,
+    gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  GST_DEBUG ("writing delta lf params");
+
+  if (frame_header->quantization_params.delta_q_present) {
+    if (!frame_header->allow_intrabc)
+      WRITE_BITS (bw, frame_header->loop_filter_params.delta_lf_present, 1);
+
+    if (frame_header->loop_filter_params.delta_lf_present) {
+      WRITE_BITS (bw, frame_header->loop_filter_params.delta_lf_res, 2);
+      WRITE_BITS (bw, frame_header->loop_filter_params.delta_lf_multi, 1);
+    }
+  }
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write delta lf params");
+  *space = have_space;
+  return FALSE;
+}
+
+static gboolean
+_av1_bit_writer_loop_filter_params (const GstAV1FrameHeaderOBU * frame_header,
+    const GstAV1SequenceHeaderOBU * seq_header, guint * loopfilter_offset,
+    GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+  const GstAV1LoopFilterParams *lf_params = &frame_header->loop_filter_params;
+
+  GST_DEBUG ("writing loop filter params");
+
+  if (frame_header->coded_lossless || frame_header->allow_intrabc)
+    goto success;
+
+  if (loopfilter_offset)
+    *loopfilter_offset = gst_bit_writer_get_size (bw);
+
+  WRITE_BITS (bw, lf_params->loop_filter_level[0], 6);
+  WRITE_BITS (bw, lf_params->loop_filter_level[1], 6);
+  if (seq_header->num_planes > 1) {
+    if (lf_params->loop_filter_level[0] || lf_params->loop_filter_level[1]) {
+      WRITE_BITS (bw, lf_params->loop_filter_level[2], 6);
+      WRITE_BITS (bw, lf_params->loop_filter_level[3], 6);
+    }
+  }
+
+  WRITE_BITS (bw, lf_params->loop_filter_sharpness, 3);
+
+  WRITE_BITS (bw, lf_params->loop_filter_delta_enabled, 1);
+  if (lf_params->loop_filter_delta_enabled) {
+    guint i;
+
+    WRITE_BITS (bw, lf_params->loop_filter_delta_update, 1);
+
+    if (lf_params->loop_filter_delta_update) {
+      const gint8 default_loop_filter_ref_deltas[] =
+          { 1, 0, 0, 0, -1, 0, -1, -1 };
+      gboolean update_ref_deltas;
+
+      for (i = 0; i < GST_AV1_TOTAL_REFS_PER_FRAME; i++) {
+        /* If loop_filter_ref_deltas[i] is different from default
+           value, we update it. */
+        update_ref_deltas = (lf_params->loop_filter_ref_deltas[i] !=
+            default_loop_filter_ref_deltas[i]);
+
+        WRITE_BITS (bw, update_ref_deltas, 1);
+
+        if (update_ref_deltas) {
+          if (!_av1_write_su (bw, lf_params->loop_filter_ref_deltas[i],
+                  6, space))
+            goto error;
+        }
+      }
+
+      for (i = 0; i < 2; i++) {
+        /* If loop_filter_mode_deltas[i] is different from default
+           value, we update it. */
+        update_ref_deltas = (lf_params->loop_filter_mode_deltas[i] != 0);
+
+        WRITE_BITS (bw, update_ref_deltas, 1);
+
+        if (update_ref_deltas) {
+          if (!_av1_write_su (bw, lf_params->loop_filter_mode_deltas[i],
+                  6, space))
+            goto error;
+        }
+      }
+    }
+  }
+
+success:
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write loop filter params");
+  *space = have_space;
+  return FALSE;
+}
+
+static gboolean
+_av1_bit_writer_cdef_params (const GstAV1FrameHeaderOBU * frame_header,
+    const GstAV1SequenceHeaderOBU * seq_header, guint * cdef_offset,
+    GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+  const GstAV1CDEFParams *cdef_params = &frame_header->cdef_params;
+  guint i;
+
+  GST_DEBUG ("writing cdef params");
+
+  if (frame_header->coded_lossless || frame_header->allow_intrabc
+      || !seq_header->enable_cdef)
+    goto success;
+
+  if (cdef_offset)
+    *cdef_offset = gst_bit_writer_get_size (bw);
+
+  WRITE_BITS (bw, cdef_params->cdef_damping - 3, 2);
+  WRITE_BITS (bw, cdef_params->cdef_bits, 2);
+
+  for (i = 0; i < (1 << cdef_params->cdef_bits); i++) {
+    guint8 cdef_y_sec_strength;
+
+    WRITE_BITS (bw, cdef_params->cdef_y_pri_strength[i], 4);
+
+    cdef_y_sec_strength = cdef_params->cdef_y_sec_strength[i];
+
+    /* In 5.9.19:
+       if ( cdef_y_sec_strength[i] == 3 ) cdef_y_sec_strength[i] += 1
+       so in fact 3 is not a valid value for cdef_y_sec_strength */
+    if (cdef_y_sec_strength == 3) {
+      GST_WARNING ("cdef_y_sec_strength is not valid");
+      goto error;
+    }
+
+    if (cdef_y_sec_strength == 4)
+      cdef_y_sec_strength -= 1;
+
+    WRITE_BITS (bw, cdef_y_sec_strength, 2);
+
+    if (seq_header->num_planes > 1) {
+      guint8 cdef_uv_sec_strength;
+
+      WRITE_BITS (bw, cdef_params->cdef_uv_pri_strength[i], 4);
+
+      cdef_uv_sec_strength = cdef_params->cdef_uv_sec_strength[i];
+
+      /* In 5.9.19:
+         if ( cdef_uv_sec_strength[i] == 3 ) cdef_uv_sec_strength[i] += 1
+         so in fact 3 is not a valid value for cdef_uv_sec_strength */
+      if (cdef_uv_sec_strength == 3) {
+        GST_WARNING ("cdef_uv_sec_strength is not valid");
+        goto error;
+      }
+
+      if (cdef_uv_sec_strength == 4)
+        cdef_uv_sec_strength -= 1;
+
+      WRITE_BITS (bw, cdef_uv_sec_strength, 2);
+    }
+  }
+
+success:
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write cdef params");
+  *space = have_space;
+  return FALSE;
+}
+
+static gboolean
+_av1_bit_writer_loop_restoration_params (const GstAV1FrameHeaderOBU *
+    frame_header, const GstAV1SequenceHeaderOBU * seq_header,
+    GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+  guint i, j;
+  guint8 use_chroma_lr = 0 /* useChromaLr */ ;
+  const GstAV1LoopRestorationParams *lr_params =
+      &frame_header->loop_restoration_params;
+  const GstAV1FrameRestorationType remap_lr_type /* Remap_Lr_Type */ [4] = {
+    GST_AV1_FRAME_RESTORE_NONE,
+    GST_AV1_FRAME_RESTORE_SWITCHABLE,
+    GST_AV1_FRAME_RESTORE_WIENER, GST_AV1_FRAME_RESTORE_SGRPROJ
+  };
+
+  GST_DEBUG ("writing loop restoration params");
+
+  if (frame_header->all_lossless || frame_header->allow_intrabc
+      || !seq_header->enable_restoration)
+    goto success;
+
+  for (i = 0; i < seq_header->num_planes; i++) {
+    for (j = 0; j < 4; j++) {
+      if (lr_params->frame_restoration_type[i] == remap_lr_type[j])
+        break;
+    }
+    if (j == 4)
+      goto error;
+
+    if (lr_params->frame_restoration_type[i] != GST_AV1_FRAME_RESTORE_NONE) {
+      if (!lr_params->uses_lr) {
+        GST_WARNING ("uses_lr set to wrong value");
+        goto error;
+      }
+
+      if (i > 1)
+        use_chroma_lr = 1;
+    }
+
+    WRITE_BITS (bw, j, 2);
+  }
+
+  if (lr_params->uses_lr) {
+    if (lr_params->lr_unit_shift > 2)
+      goto error;
+
+    if (seq_header->use_128x128_superblock) {
+      WRITE_BITS (bw, lr_params->lr_unit_shift - 1, 1);
+    } else {
+      WRITE_BITS (bw, 1, 1);
+
+      if (lr_params->lr_unit_shift > 1)
+        /* lr_unit_extra_shift */
+        WRITE_BITS (bw, 1, 1);
+    }
+
+    if (seq_header->color_config.subsampling_x
+        && seq_header->color_config.subsampling_y && use_chroma_lr)
+      WRITE_BITS (bw, lr_params->lr_uv_shift, 1);
+  }
+
+success:
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write loop restoration params");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.9.22 */
+static gboolean
+_av1_bit_writer_skip_mode_params (const GstAV1FrameHeaderOBU * frame_header,
+    const GstAV1SequenceHeaderOBU * seq_header, GstBitWriter * bw,
+    gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  GST_DEBUG ("writing skip mode params");
+
+  /* if skipModeAllowed is true */
+  if (frame_header->skip_mode_frame[0] > 0
+      || frame_header->skip_mode_frame[1] > 0)
+    WRITE_BITS (bw, frame_header->skip_mode_present, 1);
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write skip mode params");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.9.24 */
+static gboolean
+_av1_bit_writer_global_motion_params (const GstAV1FrameHeaderOBU * frame_header,
+    const GstAV1SequenceHeaderOBU * seq_header, GstBitWriter * bw,
+    gboolean * space)
+{
+  gboolean have_space = TRUE;
+  gint ref, i;
+  const GstAV1GlobalMotionParams *gm_params =
+      &(frame_header->global_motion_params);
+  gint32 prev_gm_params[GST_AV1_NUM_REF_FRAMES][6] /* PrevGmParams */ ;
+
+  GST_DEBUG ("writing global motion params");
+
+  if (frame_header->frame_is_intra)
+    goto success;
+
+  if (frame_header->primary_ref_frame != GST_AV1_PRIMARY_REF_NONE) {
+    memcpy (prev_gm_params, &frame_header->ref_global_motion_params,
+        sizeof (gint32) * GST_AV1_NUM_REF_FRAMES * 6);
+  } else {
+    for (ref = GST_AV1_REF_INTRA_FRAME; ref < GST_AV1_NUM_REF_FRAMES; ref++)
+      for (i = 0; i < 6; i++)
+        prev_gm_params[ref][i] =
+            ((i % 3 == 2) ? 1 << GST_AV1_WARPEDMODEL_PREC_BITS : 0);
+  }
+
+  for (ref = GST_AV1_REF_LAST_FRAME; ref <= GST_AV1_REF_ALTREF_FRAME; ref++) {
+    WRITE_BITS (bw, gm_params->gm_type[ref] != GST_AV1_WARP_MODEL_IDENTITY, 1);
+
+    if (gm_params->gm_type[ref] != GST_AV1_WARP_MODEL_IDENTITY) {
+      WRITE_BITS (bw, gm_params->gm_type[ref] == GST_AV1_WARP_MODEL_ROTZOOM, 1);
+
+      if (gm_params->gm_type[ref] != GST_AV1_WARP_MODEL_ROTZOOM)
+        WRITE_BITS (bw,
+            gm_params->gm_type[ref] == GST_AV1_WARP_MODEL_TRANSLATION, 1);
+    }
+
+    if (gm_params->gm_type[ref] >= GST_AV1_WARP_MODEL_ROTZOOM) {
+      if (!_av1_write_signed_primitive_refsubexpfin (bw,
+              (1 << GST_AV1_GM_ABS_ALPHA_BITS) + 1, 3,
+              (prev_gm_params[ref][2] >> (GST_AV1_WARPEDMODEL_PREC_BITS -
+                      GST_AV1_GM_ALPHA_PREC_BITS)) -
+              (1 << GST_AV1_GM_ALPHA_PREC_BITS),
+              (gm_params->gm_params[ref][2] >> (GST_AV1_WARPEDMODEL_PREC_BITS -
+                      GST_AV1_GM_ALPHA_PREC_BITS)) -
+              (1 << GST_AV1_GM_ALPHA_PREC_BITS), space))
+        goto error;
+
+      if (!_av1_write_signed_primitive_refsubexpfin (bw,
+              (1 << GST_AV1_GM_ABS_ALPHA_BITS) + 1, 3,
+              (prev_gm_params[ref][3] >> (GST_AV1_WARPEDMODEL_PREC_BITS -
+                      GST_AV1_GM_ALPHA_PREC_BITS)),
+              (gm_params->gm_params[ref][3] >> (GST_AV1_WARPEDMODEL_PREC_BITS -
+                      GST_AV1_GM_ALPHA_PREC_BITS)), space))
+        goto error;
+    }
+
+    if (gm_params->gm_type[ref] >= GST_AV1_WARP_MODEL_AFFINE) {
+      if (!_av1_write_signed_primitive_refsubexpfin (bw,
+              (1 << GST_AV1_GM_ABS_ALPHA_BITS) + 1, 3,
+              (prev_gm_params[ref][4] >> (GST_AV1_WARPEDMODEL_PREC_BITS -
+                      GST_AV1_GM_ALPHA_PREC_BITS)),
+              (gm_params->gm_params[ref][4] >> (GST_AV1_WARPEDMODEL_PREC_BITS -
+                      GST_AV1_GM_ALPHA_PREC_BITS)), space))
+        goto error;
+
+      if (!_av1_write_signed_primitive_refsubexpfin (bw,
+              (1 << GST_AV1_GM_ABS_ALPHA_BITS) + 1, 3,
+              (prev_gm_params[ref][5] >> (GST_AV1_WARPEDMODEL_PREC_BITS -
+                      GST_AV1_GM_ALPHA_PREC_BITS)) -
+              (1 << GST_AV1_GM_ALPHA_PREC_BITS),
+              (gm_params->gm_params[ref][5] >> (GST_AV1_WARPEDMODEL_PREC_BITS -
+                      GST_AV1_GM_ALPHA_PREC_BITS)) -
+              (1 << GST_AV1_GM_ALPHA_PREC_BITS), space))
+        goto error;
+    }
+
+    if (gm_params->gm_type[ref] >= GST_AV1_WARP_MODEL_TRANSLATION) {
+      const gint trans_bits =
+          (gm_params->gm_type[ref] == GST_AV1_WARP_MODEL_TRANSLATION) ?
+          GST_AV1_GM_ABS_TRANS_ONLY_BITS -
+          !frame_header->allow_high_precision_mv : GST_AV1_GM_ABS_TRANS_BITS;
+      const gint trans_prec_diff =
+          (gm_params->gm_type[ref] == GST_AV1_WARP_MODEL_TRANSLATION) ?
+          GST_AV1_WARPEDMODEL_PREC_BITS - 3 +
+          !frame_header->allow_high_precision_mv :
+          (GST_AV1_WARPEDMODEL_PREC_BITS - GST_AV1_GM_TRANS_PREC_BITS);
+
+      if (!_av1_write_signed_primitive_refsubexpfin (bw, (1 << trans_bits) + 1,
+              3, (prev_gm_params[ref][0] >> trans_prec_diff),
+              (gm_params->gm_params[ref][0] >> trans_prec_diff), space))
+        goto error;
+
+      if (!_av1_write_signed_primitive_refsubexpfin (bw, (1 << trans_bits) + 1,
+              3, (prev_gm_params[ref][1] >> trans_prec_diff),
+              (gm_params->gm_params[ref][1] >> trans_prec_diff), space))
+        goto error;
+    }
+  }
+
+success:
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write global motion params");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.9.30 */
+static gboolean
+_av1_bit_writer_film_grain_params (const GstAV1FrameHeaderOBU * frame_header,
+    const GstAV1SequenceHeaderOBU * seq_header, GstBitWriter * bw,
+    gboolean * space)
+{
+  gboolean have_space = TRUE;
+  guint i;
+  gint num_pos_chroma /* numPosChroma */ , num_pos_luma /* numPosLuma */ ;
+  const GstAV1FilmGrainParams *fg_params = &frame_header->film_grain_params;
+
+  GST_DEBUG ("writing film grain params");
+
+  fg_params = &frame_header->film_grain_params;
+  if (!seq_header->film_grain_params_present || (!frame_header->show_frame
+          && !frame_header->showable_frame))
+    goto success;
+
+  WRITE_BITS (bw, fg_params->apply_grain, 1);
+  if (!fg_params->apply_grain)
+    goto success;
+
+  WRITE_BITS (bw, fg_params->grain_seed, 16);
+
+  if (frame_header->frame_type == GST_AV1_INTER_FRAME)
+    WRITE_BITS (bw, fg_params->update_grain, 1);
+
+  if (!fg_params->update_grain) {
+    WRITE_BITS (bw, fg_params->film_grain_params_ref_idx, 3);
+    goto success;
+  }
+
+  WRITE_BITS (bw, fg_params->num_y_points, 4);
+
+  for (i = 0; i < fg_params->num_y_points; i++) {
+    WRITE_BITS (bw, fg_params->point_y_value[i], 8);
+    WRITE_BITS (bw, fg_params->point_y_scaling[i], 8);
+  }
+
+  if (!seq_header->color_config.mono_chrome)
+    WRITE_BITS (bw, fg_params->chroma_scaling_from_luma, 1);
+
+  if (!(seq_header->color_config.mono_chrome
+          || fg_params->chroma_scaling_from_luma
+          || (seq_header->color_config.subsampling_x == 1
+              && seq_header->color_config.subsampling_y == 1
+              && fg_params->num_y_points == 0))) {
+    WRITE_BITS (bw, fg_params->num_cb_points, 4);
+
+    for (i = 0; i < fg_params->num_cb_points; i++) {
+      WRITE_BITS (bw, fg_params->point_cb_value[i], 8);
+      WRITE_BITS (bw, fg_params->point_cb_scaling[i], 8);
+    }
+
+    WRITE_BITS (bw, fg_params->num_cr_points, 4);
+    for (i = 0; i < fg_params->num_cr_points; i++) {
+      WRITE_BITS (bw, fg_params->point_cr_value[i], 8);
+      WRITE_BITS (bw, fg_params->point_cr_scaling[i], 8);
+    }
+  }
+
+  WRITE_BITS (bw, fg_params->grain_scaling_minus_8, 2);
+
+  WRITE_BITS (bw, fg_params->ar_coeff_lag, 2);
+
+  num_pos_luma = 2 * fg_params->ar_coeff_lag * (fg_params->ar_coeff_lag + 1);
+  if (fg_params->num_y_points) {
+    num_pos_chroma = num_pos_luma + 1;
+    for (i = 0; i < num_pos_luma; i++)
+      WRITE_BITS (bw, fg_params->ar_coeffs_y_plus_128[i], 8);
+  } else {
+    num_pos_chroma = num_pos_luma;
+  }
+
+  if (fg_params->chroma_scaling_from_luma || fg_params->num_cb_points) {
+    for (i = 0; i < num_pos_chroma; i++)
+      WRITE_BITS (bw, fg_params->ar_coeffs_cb_plus_128[i], 8);
+  }
+
+  if (fg_params->chroma_scaling_from_luma || fg_params->num_cr_points) {
+    for (i = 0; i < num_pos_chroma; i++)
+      WRITE_BITS (bw, fg_params->ar_coeffs_cr_plus_128[i], 8);
+  }
+
+  WRITE_BITS (bw, fg_params->ar_coeff_shift_minus_6, 2);
+
+  WRITE_BITS (bw, fg_params->grain_scale_shift, 2);
+
+  if (fg_params->num_cb_points) {
+    WRITE_BITS (bw, fg_params->cb_mult, 8);
+    WRITE_BITS (bw, fg_params->cb_luma_mult, 8);
+    WRITE_BITS (bw, fg_params->cb_offset, 9);
+  }
+
+  if (fg_params->num_cr_points) {
+    WRITE_BITS (bw, fg_params->cr_mult, 8);
+    WRITE_BITS (bw, fg_params->cr_luma_mult, 8);
+    WRITE_BITS (bw, fg_params->cr_offset, 9);
+  }
+
+  WRITE_BITS (bw, fg_params->overlap_flag, 1);
+  WRITE_BITS (bw, fg_params->clip_to_restricted_range, 1);
+
+success:
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write film grain params");
+  *space = have_space;
+  return FALSE;
+}
+
+static gboolean
+_av1_bit_writer_uncompressed_frame_header (const GstAV1FrameHeaderOBU *
+    frame_header, const GstAV1SequenceHeaderOBU * seq_header,
+    guint8 temporal_id, guint8 spatial_id, guint * qindex_offset,
+    guint * segmentation_offset, guint * loopfilter_offset,
+    guint * cdef_offset, GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+  guint i;
+  gint id_len /* idLen */  = 0;
+  const GstAV1DecoderModelInfo *cmi = &seq_header->decoder_model_info;
+
+  GST_DEBUG ("writing frame header");
+
+  if (seq_header->frame_id_numbers_present_flag)
+    id_len = seq_header->additional_frame_id_length_minus_1 + 1 +
+        seq_header->delta_frame_id_length_minus_2 + 2;
+
+  if (!seq_header->reduced_still_picture_header) {
+    WRITE_BITS (bw, frame_header->show_existing_frame, 1);
+    if (frame_header->show_existing_frame) {
+      WRITE_BITS (bw, frame_header->frame_to_show_map_idx, 3);
+
+      if (seq_header->decoder_model_info_present_flag
+          && !seq_header->timing_info.equal_picture_interval)
+        WRITE_BITS (bw, frame_header->frame_presentation_time,
+            cmi->frame_presentation_time_length_minus_1 + 1);
+
+      if (seq_header->frame_id_numbers_present_flag) {
+        if (id_len <= 0)
+          goto error;
+
+        WRITE_BITS (bw, frame_header->display_frame_id, id_len);
+      }
+
+      goto success;
+    }
+
+    if (seq_header->still_picture &&
+        (frame_header->frame_type != GST_AV1_KEY_FRAME
+            || !frame_header->show_frame)) {
+      GST_INFO ("Still pictures must be coded as shown keyframes");
+      goto error;
+    }
+    WRITE_BITS (bw, frame_header->frame_type, 2);
+    WRITE_BITS (bw, frame_header->show_frame, 1);
+
+    if (frame_header->show_frame
+        && seq_header->decoder_model_info_present_flag
+        && !seq_header->timing_info.equal_picture_interval)
+      WRITE_BITS (bw, frame_header->frame_presentation_time,
+          cmi->frame_presentation_time_length_minus_1 + 1);
+
+    if (!frame_header->show_frame)
+      WRITE_BITS (bw, frame_header->showable_frame, 1);
+
+    if (!(frame_header->frame_type == GST_AV1_SWITCH_FRAME
+            || (frame_header->frame_type == GST_AV1_KEY_FRAME
+                && frame_header->show_frame)))
+      WRITE_BITS (bw, frame_header->error_resilient_mode, 1);
+  }
+
+  WRITE_BITS (bw, frame_header->disable_cdf_update, 1);
+
+  if (seq_header->seq_force_screen_content_tools ==
+      GST_AV1_SELECT_SCREEN_CONTENT_TOOLS)
+    WRITE_BITS (bw, frame_header->allow_screen_content_tools, 1);
+
+  if (frame_header->allow_screen_content_tools) {
+    if (seq_header->seq_force_integer_mv == GST_AV1_SELECT_INTEGER_MV)
+      WRITE_BITS (bw, frame_header->force_integer_mv, 1);
+  }
+
+  if (seq_header->frame_id_numbers_present_flag) {
+    if (id_len <= 0)
+      goto error;
+
+    WRITE_BITS (bw, frame_header->current_frame_id, id_len);
+  }
+
+  if (frame_header->frame_type != GST_AV1_SWITCH_FRAME
+      && !seq_header->reduced_still_picture_header)
+    WRITE_BITS (bw, frame_header->frame_size_override_flag, 1);
+
+  WRITE_BITS (bw, frame_header->order_hint,
+      seq_header->order_hint_bits_minus_1 + 1);
+
+  if (frame_header->frame_is_intra || frame_header->error_resilient_mode) {
+    if (frame_header->primary_ref_frame != GST_AV1_PRIMARY_REF_NONE) {
+      GST_WARNING ("primary_ref_frame is not none.");
+      goto error;
+    }
+  } else {
+    WRITE_BITS (bw, frame_header->primary_ref_frame, 3);
+  }
+
+  if (seq_header->decoder_model_info_present_flag) {
+    if (frame_header->buffer_removal_time_present_flag) {
+      guint op_num;
+      const GstAV1OperatingPoint *operating_points;
+
+      for (op_num = 0; op_num <= seq_header->operating_points_cnt_minus_1;
+          op_num++) {
+        operating_points = &seq_header->operating_points[op_num];
+
+        if (operating_points->decoder_model_present_for_this_op) {
+          gint op_pt_idc = operating_points->idc;
+          gint in_temporal_layer = (op_pt_idc >> temporal_id) & 1;
+          gint in_spatial_layer = (op_pt_idc >> (spatial_id + 8)) & 1;
+
+          if (op_pt_idc == 0 || (in_temporal_layer && in_spatial_layer))
+            WRITE_BITS (bw, frame_header->buffer_removal_time[op_num],
+                cmi->buffer_removal_time_length_minus_1 + 1);
+        }
+      }
+    }
+  }
+
+  if (frame_header->frame_type == GST_AV1_INTRA_ONLY_FRAME) {
+    if (frame_header->refresh_frame_flags == 0xFF) {
+      GST_INFO ("Intra only frames cannot have refresh flags 0xFF");
+      goto error;
+    }
+  }
+  if (!(frame_header->frame_type == GST_AV1_SWITCH_FRAME ||
+          (frame_header->frame_type == GST_AV1_KEY_FRAME
+              && frame_header->show_frame)))
+    WRITE_BITS (bw, frame_header->refresh_frame_flags, 8);
+
+  if (!frame_header->frame_is_intra
+      || frame_header->refresh_frame_flags !=
+      (1 << GST_AV1_NUM_REF_FRAMES) - 1) {
+    if (frame_header->error_resilient_mode && seq_header->enable_order_hint) {
+      for (i = 0; i < GST_AV1_NUM_REF_FRAMES; i++)
+        WRITE_BITS (bw, frame_header->ref_order_hint[i],
+            seq_header->order_hint_bits_minus_1 + 1);
+    }
+  }
+
+  if (frame_header->frame_is_intra) {
+    if (!_av1_bit_writer_frame_size (frame_header, seq_header, bw, space))
+      goto error;
+
+    if (!_av1_bit_writer_render_size (frame_header, bw, space))
+      goto error;
+
+    if (frame_header->allow_screen_content_tools
+        && frame_header->upscaled_width == frame_header->frame_width)
+      WRITE_BITS (bw, frame_header->allow_intrabc, 1);
+  } else {
+    if (seq_header->enable_order_hint) {
+      WRITE_BITS (bw, frame_header->frame_refs_short_signaling, 1);
+
+      if (frame_header->frame_refs_short_signaling) {
+        WRITE_BITS (bw, frame_header->last_frame_idx, 3);
+        WRITE_BITS (bw, frame_header->gold_frame_idx, 3);
+      }
+    }
+
+    for (i = 0; i < GST_AV1_REFS_PER_FRAME; i++) {
+      if (!frame_header->frame_refs_short_signaling)
+        WRITE_BITS (bw, frame_header->ref_frame_idx[i], 3);
+
+      if (seq_header->frame_id_numbers_present_flag) {
+        gint32 delta_frame_id /* DeltaFrameId */ ;
+
+        if (id_len <= 0)
+          goto error;
+
+        delta_frame_id =
+            frame_header->current_frame_id - frame_header->expected_frame_id[i];
+        delta_frame_id = delta_frame_id + (1 << id_len);
+        delta_frame_id = delta_frame_id % (1 << id_len);
+        WRITE_BITS (bw, delta_frame_id - 1,
+            seq_header->delta_frame_id_length_minus_2 + 2);
+      }
+    }
+
+    if (frame_header->frame_size_override_flag
+        && !frame_header->error_resilient_mode) {
+      /* 5.9.7 */
+      /* TODO: reuse reference frame width/height. Just disable now. */
+      for (i = 0; i < GST_AV1_REFS_PER_FRAME; i++)
+        WRITE_BITS (bw, 0, 1);
+    }
+
+    if (!_av1_bit_writer_frame_size (frame_header, seq_header, bw, space))
+      goto error;
+
+    if (!_av1_bit_writer_render_size (frame_header, bw, space))
+      goto error;
+
+    if (!frame_header->force_integer_mv)
+      WRITE_BITS (bw, frame_header->allow_high_precision_mv, 1);
+
+    WRITE_BITS (bw, frame_header->is_filter_switchable, 1);
+    if (!frame_header->is_filter_switchable)
+      WRITE_BITS (bw, frame_header->interpolation_filter, 2);
+
+    WRITE_BITS (bw, frame_header->is_motion_mode_switchable, 1);
+
+    if (!(frame_header->error_resilient_mode
+            || !seq_header->enable_ref_frame_mvs))
+      WRITE_BITS (bw, frame_header->use_ref_frame_mvs, 1);
+  }
+
+  if (!(seq_header->reduced_still_picture_header
+          || frame_header->disable_cdf_update))
+    WRITE_BITS (bw, frame_header->disable_frame_end_update_cdf, 1);
+
+  if (!_av1_bit_writer_tile_info (frame_header, seq_header, bw, space))
+    goto error;
+
+  if (!_av1_bit_writer_quantization_params (frame_header, seq_header,
+          qindex_offset, bw, space))
+    goto error;
+
+  if (!_av1_bit_writer_segmentation_params (frame_header, seq_header,
+          segmentation_offset, bw, space))
+    goto error;
+
+  if (!_av1_bit_writer_delta_q_params (frame_header, seq_header, bw, space))
+    goto error;
+
+  if (!_av1_bit_writer_delta_lf_params (frame_header, seq_header, bw, space))
+    goto error;
+
+  if (!_av1_bit_writer_loop_filter_params (frame_header, seq_header,
+          loopfilter_offset, bw, space))
+    goto error;
+
+  if (!_av1_bit_writer_cdef_params (frame_header, seq_header,
+          cdef_offset, bw, space))
+    goto error;
+
+  if (!_av1_bit_writer_loop_restoration_params (frame_header, seq_header,
+          bw, space))
+    goto error;
+
+  /* 5.9.21 tx_mode() */
+  if (frame_header->coded_lossless != 1) {
+    /* Write the tx_mode_select bit. */
+    if (frame_header->tx_mode == GST_AV1_TX_MODE_SELECT) {
+      WRITE_BITS (bw, 1, 1);
+    } else {
+      WRITE_BITS (bw, 0, 1);
+    }
+  }
+
+  /* 5.9.23 inlined frame_reference_mode () */
+  if (!frame_header->frame_is_intra)
+    WRITE_BITS (bw, frame_header->reference_select, 1);
+
+  if (!_av1_bit_writer_skip_mode_params (frame_header, seq_header, bw, space))
+    goto error;
+
+  if (!(frame_header->frame_is_intra || frame_header->error_resilient_mode ||
+          !seq_header->enable_warped_motion))
+    WRITE_BITS (bw, frame_header->allow_warped_motion, 1);
+
+  WRITE_BITS (bw, frame_header->reduced_tx_set, 1);
+
+  if (!_av1_bit_writer_global_motion_params (frame_header,
+          seq_header, bw, space))
+    goto error;
+
+  if (!_av1_bit_writer_film_grain_params (frame_header, seq_header, bw, space))
+    goto error;
+
+success:
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write frame header");
+  *space = have_space;
+  return FALSE;
+}
+
+/**
+ * gst_av1_bit_writer_frame_header_obu:
+ * @frame_hdr: the frame header of #GstAV1FrameHeaderOBU to write
+ * @seq_hdr: the sequence header of #GstAV1SequenceHeaderOBU to refer
+ * @temporal_id: specifies the temporal level of the data contained in the OBU.
+ * @spatial_id: specifies the spatial level of the data contained in the OBU.
+ * @size_field: whether the OBU header contains the OBU size.
+ * @data: (out): the bit stream generated by the frame header
+ * @size: (inout): the size in bytes of the input and output
+ *
+ * Generating the according AV1 bit stream OBU by providing the frame header.
+ *
+ * Returns: a #GstAV1BitWriterResult
+ *
+ * Since: 1.22
+ **/
+GstAV1BitWriterResult
+gst_av1_bit_writer_frame_header_obu (const GstAV1FrameHeaderOBU * frame_hdr,
+    const GstAV1SequenceHeaderOBU * seq_hdr, guint8 temporal_id,
+    guint8 spatial_id, gboolean size_field, guint8 * data, guint * size)
+{
+  gboolean have_space = TRUE;
+  GstBitWriter bw;
+  guint header_size;
+  guint payload_size;
+
+  g_return_val_if_fail (frame_hdr != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (seq_hdr != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (temporal_id < GST_AV1_MAX_NUM_TEMPORAL_LAYERS,
+      GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (spatial_id < GST_AV1_MAX_NUM_SPATIAL_LAYERS,
+      GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (data != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (size != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (*size > 0, GST_AV1_BIT_WRITER_ERROR);
+
+  gst_bit_writer_init_with_data (&bw, data, *size, FALSE);
+
+  /* obu_forbidden_bit */
+  WRITE_BITS (&bw, 0, 1);
+  /* obu_type */
+  WRITE_BITS (&bw, GST_AV1_OBU_FRAME_HEADER, 4);
+  /* obu_extention_flag */
+  if (temporal_id > 0 || spatial_id > 0) {
+    WRITE_BITS (&bw, 1, 1);
+  } else {
+    WRITE_BITS (&bw, 0, 1);
+  }
+  /* obu_has_size_field */
+  if (size_field) {
+    WRITE_BITS (&bw, 1, 1);
+  } else {
+    WRITE_BITS (&bw, 0, 1);
+  }
+  /* obu_reserved_1bit */
+  WRITE_BITS (&bw, 0, 1);
+
+  header_size = 1;
+  /* 5.3.3 OBU extension header */
+  if (temporal_id > 0 || spatial_id > 0) {
+    WRITE_BITS (&bw, temporal_id, 3);
+    WRITE_BITS (&bw, spatial_id, 2);
+    /* obu_extension_header_reserved_3bits */
+    WRITE_BITS (&bw, 0, 3);
+    header_size = 2;
+  }
+
+  if (!_av1_bit_writer_uncompressed_frame_header (frame_hdr, seq_hdr,
+          temporal_id, spatial_id, NULL, NULL, NULL, NULL, &bw, &have_space))
+    goto error;
+
+  /* Add trailings. */
+  WRITE_BITS (&bw, 1, 1);
+  if (!gst_bit_writer_align_bytes (&bw, 0)) {
+    have_space = FALSE;
+    goto error;
+  }
+
+  payload_size = gst_bit_writer_get_size (&bw);
+  g_assert (payload_size % 8 == 0);
+  payload_size /= 8;
+  payload_size -= header_size;
+
+  gst_bit_writer_reset (&bw);
+
+  if (size_field) {
+    if (!_av1_bit_writer_add_size_field (data, size,
+            header_size, payload_size, &have_space))
+      goto error;
+  } else {
+    *size = header_size + payload_size;
+  }
+
+  return GST_AV1_BIT_WRITER_OK;
+
+error:
+  gst_bit_writer_reset (&bw);
+  *size = 0;
+  return have_space ? GST_AV1_BIT_WRITER_INVALID_DATA :
+      GST_AV1_BIT_WRITER_NO_MORE_SPACE;
+}
+
+/**
+ * gst_av1_bit_writer_frame_header_obu_with_offsets:
+ * @frame_hdr: the frame header of #GstAV1FrameHeaderOBU to write
+ * @seq_hdr: the sequence header of #GstAV1SequenceHeaderOBU to refer
+ * @temporal_id: specifies the temporal level of the data contained in the OBU.
+ * @spatial_id: specifies the spatial level of the data contained in the OBU.
+ * @size_field_bytes: specifies the reserved size field size in bytes.
+ * @qindex_offset: (out): return the qindex fields offset in bits.
+ * @segmentation_offset: (out): return the segmentation fields offset in bits.
+ * @loopfilter_offset: (out): return the loopfilter fields offset in bits.
+ * @cdef_offset: (out): return the cdeffields offset in bits.
+ * @data: (out): the bit stream generated by the frame header
+ * @size: (inout): the size in bytes of the input and output
+ *
+ * While Generating the according AV1 bit stream OBU by providing the frame
+ * header, this function also return bit offsets of qindex, segmentation and
+ * cdef, etc. These offsets can help to change the content of these fields
+ * later. This function is useful if the encoder may change the content of
+ * the frame header after generating it. For example, some HW needs user to
+ * provide a frame header before the real encoding job, and it will change
+ * the according fields in the frame header during the real encoding job.
+ *
+ * Returns: a #GstAV1BitWriterResult
+ *
+ * Since: 1.22
+ **/
+GstAV1BitWriterResult
+gst_av1_bit_writer_frame_header_obu_with_offsets (const GstAV1FrameHeaderOBU *
+    frame_hdr, const GstAV1SequenceHeaderOBU * seq_hdr, guint8 temporal_id,
+    guint8 spatial_id, guint size_field_bytes, guint * qindex_offset,
+    guint * segmentation_offset, guint * loopfilter_offset,
+    guint * cdef_offset, guint8 * data, guint * size)
+{
+  gboolean have_space = TRUE;
+  GstBitWriter bw;
+  guint payload_size;
+
+  g_return_val_if_fail (frame_hdr != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (seq_hdr != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (temporal_id < GST_AV1_MAX_NUM_TEMPORAL_LAYERS,
+      GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (spatial_id < GST_AV1_MAX_NUM_SPATIAL_LAYERS,
+      GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (data != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (size != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (*size > 0, GST_AV1_BIT_WRITER_ERROR);
+
+  gst_bit_writer_init_with_data (&bw, data, *size, FALSE);
+
+  WRITE_BITS (&bw, 0, 1);
+  /* obu_type */
+  WRITE_BITS (&bw, GST_AV1_OBU_FRAME_HEADER, 4);
+  /* obu_extention_flag */
+  if (temporal_id > 0 || spatial_id > 0) {
+    WRITE_BITS (&bw, 1, 1);
+  } else {
+    WRITE_BITS (&bw, 0, 1);
+  }
+
+  /* obu_has_size_field */
+  if (size_field_bytes > 0) {
+    WRITE_BITS (&bw, 1, 1);
+  } else {
+    WRITE_BITS (&bw, 0, 1);
+  }
+  /* obu_reserved_1bit */
+  WRITE_BITS (&bw, 0, 1);
+
+  /* 5.3.3 OBU extension header */
+  if (temporal_id > 0 || spatial_id > 0) {
+    WRITE_BITS (&bw, temporal_id, 3);
+    WRITE_BITS (&bw, spatial_id, 2);
+    /* obu_extension_header_reserved_3bits */
+    WRITE_BITS (&bw, 0, 3);
+  }
+
+  /* Write the fixed size field size */
+  while (size_field_bytes > 0) {
+    WRITE_BITS (&bw, 0, 8);
+    size_field_bytes--;
+  }
+
+  if (!_av1_bit_writer_uncompressed_frame_header (frame_hdr, seq_hdr,
+          temporal_id, spatial_id, qindex_offset, segmentation_offset,
+          loopfilter_offset, cdef_offset, &bw, &have_space))
+    goto error;
+
+  /* Add trailings. */
+  WRITE_BITS (&bw, 1, 1);
+  if (!gst_bit_writer_align_bytes (&bw, 0)) {
+    have_space = FALSE;
+    goto error;
+  }
+
+  payload_size = gst_bit_writer_get_size (&bw);
+  g_assert (payload_size % 8 == 0);
+  payload_size /= 8;
+
+  gst_bit_writer_reset (&bw);
+
+  *size = payload_size;
+
+  return GST_AV1_BIT_WRITER_OK;
+
+error:
+  gst_bit_writer_reset (&bw);
+  *size = 0;
+  return have_space ? GST_AV1_BIT_WRITER_INVALID_DATA :
+      GST_AV1_BIT_WRITER_NO_MORE_SPACE;
+}
+
+/**
+ * gst_av1_bit_writer_temporal_delimiter_obu:
+ * @size_field: whether the header contain size feild
+ * @data: (out): the bit stream generated
+ * @size: (inout): the size in bytes of the input and output
+ *
+ * Generating the according temporal delimiter AV1 bit stream OBU.
+ *
+ * Returns: a #GstAV1BitWriterResult
+ *
+ * Since: 1.22
+ **/
+GstAV1BitWriterResult
+gst_av1_bit_writer_temporal_delimiter_obu (gboolean size_field,
+    guint8 * data, guint * size)
+{
+  gboolean have_space = TRUE;
+  GstBitWriter bw;
+
+  g_return_val_if_fail (data != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (size != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (*size > 0, GST_AV1_BIT_WRITER_ERROR);
+
+  gst_bit_writer_init_with_data (&bw, data, *size, FALSE);
+
+  /* obu_forbidden_bit */
+  WRITE_BITS (&bw, 0, 1);
+  /* obu_type */
+  WRITE_BITS (&bw, GST_AV1_OBU_TEMPORAL_DELIMITER, 4);
+  /* obu_extention_flag */
+  WRITE_BITS (&bw, 0, 1);
+  /* obu_has_size_field */
+  if (size_field) {
+    WRITE_BITS (&bw, 1, 1);
+  } else {
+    WRITE_BITS (&bw, 0, 1);
+  }
+  /* obu_reserved_1bit */
+  WRITE_BITS (&bw, 0, 1);
+
+  /* No need to add trailings */
+
+  /* header_size is 1 and payload_size is 0 */
+  if (size_field) {
+    if (!_av1_bit_writer_add_size_field (data, size, 1, 0, &have_space))
+      goto error;
+  } else {
+    *size = 1 + 0;
+  }
+
+  return GST_AV1_BIT_WRITER_OK;
+
+error:
+  gst_bit_writer_reset (&bw);
+  *size = 0;
+  return have_space ? GST_AV1_BIT_WRITER_INVALID_DATA :
+      GST_AV1_BIT_WRITER_NO_MORE_SPACE;
+}
+
+/* 5.8.2 */
+static gboolean
+_av1_bit_writer_metadata_itut_t35 (const GstAV1MetadataITUT_T35 * itut_t35,
+    GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  GST_DEBUG ("writing metadata itut t35");
+
+  WRITE_BITS (bw, itut_t35->itu_t_t35_country_code, 8);
+
+  if (itut_t35->itu_t_t35_country_code == 0xFF)
+    WRITE_BITS (bw, itut_t35->itu_t_t35_country_code_extention_byte, 8);
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write metadata itut t35");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.8.3 */
+static gboolean
+_av1_bit_writer_metadata_hdr_cll (const GstAV1MetadataHdrCll * hdr_cll,
+    GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+
+  GST_DEBUG ("writing metadata hdr cll");
+
+  WRITE_BITS (bw, hdr_cll->max_cll, 16);
+  WRITE_BITS (bw, hdr_cll->max_fall, 16);
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write metadata hdr cll");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.8.4 */
+static gboolean
+_av1_bit_writer_metadata_hdr_mdcv (const GstAV1MetadataHdrMdcv * hdr_mdcv,
+    GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+  gint i;
+
+  GST_DEBUG ("writing metadata hdr mdcv");
+
+  for (i = 0; i < 3; i++) {
+    WRITE_BITS (bw, hdr_mdcv->primary_chromaticity_x[i], 16);
+    WRITE_BITS (bw, hdr_mdcv->primary_chromaticity_y[i], 16);
+  }
+
+  WRITE_BITS (bw, hdr_mdcv->white_point_chromaticity_x, 16);
+  WRITE_BITS (bw, hdr_mdcv->white_point_chromaticity_y, 16);
+
+  WRITE_BITS (bw, hdr_mdcv->luminance_max, 32);
+  WRITE_BITS (bw, hdr_mdcv->luminance_min, 32);
+
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write metadata hdr mdcv");
+  *space = have_space;
+  return FALSE;
+}
+
+/* 5.8.5 */
+static gboolean
+_av1_bit_writer_metadata_scalability (const GstAV1MetadataScalability *
+    scalability, GstBitWriter * bw, gboolean * space)
+{
+  gboolean have_space = TRUE;
+  guint i, j;
+
+  GST_DEBUG ("writing metadata scalability");
+
+  WRITE_BITS (bw, scalability->scalability_mode_idc, 8);
+
+  if (scalability->scalability_mode_idc != GST_AV1_SCALABILITY_SS)
+    goto success;
+
+  /* 5.8.6 */
+  WRITE_BITS (bw, scalability->spatial_layers_cnt_minus_1, 2);
+  WRITE_BITS (bw, scalability->spatial_layer_dimensions_present_flag, 1);
+  WRITE_BITS (bw, scalability->spatial_layer_description_present_flag, 1);
+  WRITE_BITS (bw, scalability->temporal_group_description_present_flag, 1);
+  /* scalability_structure_reserved_3bits */
+  WRITE_BITS (bw, 0, 3);
+
+  if (scalability->spatial_layer_dimensions_present_flag) {
+    for (i = 0; i <= scalability->spatial_layers_cnt_minus_1; i++) {
+      WRITE_BITS (bw, scalability->spatial_layer_max_width[i], 16);
+      WRITE_BITS (bw, scalability->spatial_layer_max_height[i], 16);
+    }
+  }
+
+  if (scalability->spatial_layer_description_present_flag) {
+    for (i = 0; i <= scalability->spatial_layers_cnt_minus_1; i++)
+      WRITE_BITS (bw, scalability->spatial_layer_ref_id[i], 8);
+  }
+
+  if (scalability->temporal_group_description_present_flag) {
+    WRITE_BITS (bw, scalability->temporal_group_size, 8);
+
+    for (i = 0; i < scalability->temporal_group_size; i++) {
+      WRITE_BITS (bw, scalability->temporal_group_temporal_id[i], 3);
+      WRITE_BITS (bw,
+          scalability->temporal_group_temporal_switching_up_point_flag[i], 1);
+      WRITE_BITS (bw,
+          scalability->temporal_group_spatial_switching_up_point_flag[i], 1);
+      WRITE_BITS (bw, scalability->temporal_group_ref_cnt[i], 3);
+      for (j = 0; j < scalability->temporal_group_ref_cnt[i]; j++)
+        WRITE_BITS (bw, scalability->temporal_group_ref_pic_diff[i][j], 8);
+    }
+  }
+
+success:
+  *space = TRUE;
+  return TRUE;
+
+error:
+  GST_WARNING ("failed to write metadata scalability");
+  *space = have_space;
+  return FALSE;
+}
+
+/**
+ * gst_av1_bit_writer_metadata_obu:
+ * @metadata: the meta data of #GstAV1MetadataOBU to write
+ * @temporal_id: specifies the temporal level of the data contained in the OBU.
+ * @spatial_id: specifies the spatial level of the data contained in the OBU.
+ * @size_field: whether the header contain size feild
+ * @data: (out): the bit stream generated by the meta data
+ * @size: (inout): the size in bytes of the input and output
+ *
+ * Generating the according AV1 bit stream OBU by providing the meta data.
+ *
+ * Returns: a #GstAV1BitWriterResult
+ *
+ * Since: 1.22
+ **/
+GstAV1BitWriterResult
+gst_av1_bit_writer_metadata_obu (const GstAV1MetadataOBU * metadata,
+    guint8 temporal_id, guint8 spatial_id, gboolean size_field,
+    guint8 * data, guint * size)
+{
+  gboolean have_space = TRUE;
+  GstBitWriter bw;
+  guint header_size;
+  guint payload_size;
+  guint8 metadata_type_data[4];
+  guint metadata_size;
+  guint i;
+
+  g_return_val_if_fail (metadata != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (temporal_id < GST_AV1_MAX_NUM_TEMPORAL_LAYERS,
+      GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (spatial_id < GST_AV1_MAX_NUM_SPATIAL_LAYERS,
+      GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (data != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (size != NULL, GST_AV1_BIT_WRITER_ERROR);
+  g_return_val_if_fail (*size > 0, GST_AV1_BIT_WRITER_ERROR);
+
+  gst_bit_writer_init_with_data (&bw, data, *size, FALSE);
+
+  /* obu_forbidden_bit */
+  WRITE_BITS (&bw, 0, 1);
+  /* obu_type */
+  WRITE_BITS (&bw, GST_AV1_OBU_METADATA, 4);
+  /* obu_extention_flag */
+  if (temporal_id > 0 || spatial_id > 0) {
+    WRITE_BITS (&bw, 1, 1);
+  } else {
+    WRITE_BITS (&bw, 0, 1);
+  }
+  /* obu_has_size_field */
+  if (size_field) {
+    WRITE_BITS (&bw, 1, 1);
+  } else {
+    WRITE_BITS (&bw, 0, 1);
+  }
+  /* obu_reserved_1bit */
+  WRITE_BITS (&bw, 0, 1);
+
+  header_size = 1;
+  /* 5.3.3 OBU extension header */
+  if (temporal_id > 0 || spatial_id > 0) {
+    WRITE_BITS (&bw, temporal_id, 3);
+    WRITE_BITS (&bw, spatial_id, 2);
+    /* obu_extension_header_reserved_3bits */
+    WRITE_BITS (&bw, 0, 3);
+    header_size = 2;
+  }
+
+  /* Generate the metadata_type first */
+  metadata_size = _av1_uleb_size_in_bytes (metadata->metadata_type);
+  if (metadata_size > 4) {
+    GST_WARNING ("Invalid metadata_type");
+    goto error;
+  }
+  if (!_av1_encode_uleb (metadata->metadata_type,
+          sizeof (metadata->metadata_type),
+          metadata_type_data, metadata_size)) {
+    GST_WARNING ("Failed to write metadata_type");
+    goto error;
+  }
+  for (i = 0; i < metadata_size; i++)
+    WRITE_BITS (&bw, metadata_type_data[i], 8);
+
+  switch (metadata->metadata_type) {
+    case GST_AV1_METADATA_TYPE_ITUT_T35:
+      if (!_av1_bit_writer_metadata_itut_t35 (&metadata->itut_t35,
+              &bw, &have_space))
+        goto error;
+      break;
+    case GST_AV1_METADATA_TYPE_HDR_CLL:
+      if (!_av1_bit_writer_metadata_hdr_cll (&metadata->hdr_cll,
+              &bw, &have_space))
+        goto error;
+      break;
+    case GST_AV1_METADATA_TYPE_HDR_MDCV:
+      if (!_av1_bit_writer_metadata_hdr_mdcv (&metadata->hdr_mdcv,
+              &bw, &have_space))
+        goto error;
+      break;
+    case GST_AV1_METADATA_TYPE_SCALABILITY:
+      if (!_av1_bit_writer_metadata_scalability (&metadata->scalability,
+              &bw, &have_space))
+        goto error;
+      break;
+    default:
+      GST_WARNING ("Unsupported metadata_type");
+      goto error;
+  }
+
+  /* Add trailings. */
+  WRITE_BITS (&bw, 1, 1);
+  if (!gst_bit_writer_align_bytes (&bw, 0)) {
+    have_space = FALSE;
+    goto error;
+  }
+
+  payload_size = gst_bit_writer_get_size (&bw);
+  g_assert (payload_size % 8 == 0);
+  payload_size /= 8;
+  payload_size -= header_size;
+
+  gst_bit_writer_reset (&bw);
+
+  if (size_field) {
+    if (!_av1_bit_writer_add_size_field (data, size,
+            header_size, payload_size, &have_space))
+      goto error;
+  } else {
+    *size = header_size + payload_size;
+  }
+
+  return GST_AV1_BIT_WRITER_OK;
+
+error:
+  gst_bit_writer_reset (&bw);
+  *size = 0;
+  return have_space ? GST_AV1_BIT_WRITER_INVALID_DATA :
+      GST_AV1_BIT_WRITER_NO_MORE_SPACE;
+}
diff --git a/gst-libs/gst/codecparsers/gstav1bitwriter.h b/gst-libs/gst/codecparsers/gstav1bitwriter.h
new file mode 100644
index 0000000..5cfb67b
--- /dev/null
+++ b/gst-libs/gst/codecparsers/gstav1bitwriter.h
@@ -0,0 +1,86 @@
+/* GStreamer
+ *  Copyright (C) 2022 Intel Corporation
+ *     Author: He Junyan <junyan.he@intel.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the0
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_AV1_BIT_WRITER_H__
+#define __GST_AV1_BIT_WRITER_H__
+
+#include <gst/codecparsers/gstav1parser.h>
+#include <gst/codecparsers/codecparsers-prelude.h>
+
+G_BEGIN_DECLS
+
+/**
+ * GstAV1BitWriterResult:
+ * @GST_AV1_BIT_WRITER_OK: The writing succeeded
+ * @GST_AV1_BIT_WRITER_INVALID_DATA: The input data to write is invalid
+ * @GST_AV1_BIT_WRITER_NO_MORE_SPACE: The output does not have enough size
+ * @GST_AV1_BIT_WRITER_ERROR: An general error occurred when writing
+ *
+ * The result of writing AV1 data into bit stream.
+ *
+ * Since: 1.22
+ */
+typedef enum
+{
+  GST_AV1_BIT_WRITER_OK,
+  GST_AV1_BIT_WRITER_INVALID_DATA,
+  GST_AV1_BIT_WRITER_NO_MORE_SPACE,
+  GST_AV1_BIT_WRITER_ERROR
+} GstAV1BitWriterResult;
+
+GST_CODEC_PARSERS_API
+GstAV1BitWriterResult    gst_av1_bit_writer_sequence_header_obu (const GstAV1SequenceHeaderOBU * seq_hdr,
+                                                                 gboolean size_field,
+                                                                 guint8 * data,
+                                                                 guint * size);
+GST_CODEC_PARSERS_API
+GstAV1BitWriterResult    gst_av1_bit_writer_frame_header_obu    (const GstAV1FrameHeaderOBU * frame_hdr,
+                                                                 const GstAV1SequenceHeaderOBU * seq_hdr,
+                                                                 guint8 temporal_id,
+                                                                 guint8 spatial_id,
+                                                                 gboolean size_field,
+                                                                 guint8 * data,
+                                                                 guint * size);
+GST_CODEC_PARSERS_API
+GstAV1BitWriterResult    gst_av1_bit_writer_frame_header_obu_with_offsets (const GstAV1FrameHeaderOBU * frame_hdr,
+                                                                           const GstAV1SequenceHeaderOBU * seq_hdr,
+                                                                           guint8 temporal_id,
+                                                                           guint8 spatial_id,
+                                                                           guint size_field_bytes,
+                                                                           guint * qindex_offset,
+                                                                           guint * segmentation_offset,
+                                                                           guint * loopfilter_offset,
+                                                                           guint * cdef_offset,
+                                                                           guint8 * data,
+                                                                           guint * size);
+GST_CODEC_PARSERS_API
+GstAV1BitWriterResult    gst_av1_bit_writer_temporal_delimiter_obu (gboolean size_field,
+                                                                    guint8 * data,
+                                                                    guint * size);
+GST_CODEC_PARSERS_API
+GstAV1BitWriterResult    gst_av1_bit_writer_metadata_obu        (const GstAV1MetadataOBU * metadata,
+                                                                 guint8 temporal_id,
+                                                                 guint8 spatial_id,
+                                                                 gboolean size_field,
+                                                                 guint8 * data,
+                                                                 guint * size);
+G_END_DECLS
+
+#endif /* __GST_AV1_BIT_WRITER_H__ */
diff --git a/gst-libs/gst/codecparsers/gstav1parser.c b/gst-libs/gst/codecparsers/gstav1parser.c
index 22ffefd..0e9b76b 100644
--- a/gst-libs/gst/codecparsers/gstav1parser.c
+++ b/gst-libs/gst/codecparsers/gstav1parser.c
@@ -2260,11 +2260,11 @@ gst_av1_parse_tile_info (GstAV1Parser * parser, GstBitReader * br,
     min_log2_tile_rows = MAX (min_log2_tiles - parser->state.tile_cols_log2, 0);
     parser->state.tile_rows_log2 = min_log2_tile_rows;
     while (parser->state.tile_rows_log2 < max_log2_tile_rows) {
-      tile_info->increment_tile_rows_log2 = AV1_READ_BIT_CHECKED (br, &retval);
+      gint increment_tile_rows_log2 = AV1_READ_BIT_CHECKED (br, &retval);
       if (retval != GST_AV1_PARSER_OK)
         goto error;
 
-      if (tile_info->increment_tile_rows_log2 == 1)
+      if (increment_tile_rows_log2 == 1)
         parser->state.tile_rows_log2++;
       else
         break;
diff --git a/gst-libs/gst/codecparsers/gstav1parser.h b/gst-libs/gst/codecparsers/gstav1parser.h
index a5f1c76..7d16c30 100644
--- a/gst-libs/gst/codecparsers/gstav1parser.h
+++ b/gst-libs/gst/codecparsers/gstav1parser.h
@@ -1188,7 +1188,6 @@ struct _GstAV1SegmenationParams {
  *   frame. (In other words, all tiles are the same size except for the ones at the right and
  *   bottom edge which can be smaller.) @uniform_tile_spacing_flag equal to 0 means that the
  *   tile sizes are coded.
- * @increment_tile_rows_log2: is used to compute @tile_rows_log2.
  * @width_in_sbs_minus_1: specifies the width of a tile minus 1 in units of superblocks.
  * @height_in_sbs_minus_1: specifies the height of a tile minus 1 in units of superblocks.
  * @tile_size_bytes_minus_1: is used to compute @tile_size_bytes
@@ -1207,7 +1206,6 @@ struct _GstAV1SegmenationParams {
  */
 struct _GstAV1TileInfo {
   guint8 uniform_tile_spacing_flag;
-  gint increment_tile_rows_log2;
   gint width_in_sbs_minus_1[GST_AV1_MAX_TILE_COLS];
   gint height_in_sbs_minus_1[GST_AV1_MAX_TILE_ROWS];
   gint tile_size_bytes_minus_1;
@@ -1563,6 +1561,7 @@ struct _GstAV1FrameHeaderOBU {
   gint8 last_frame_idx;
   gint8 gold_frame_idx;
   gint8 ref_frame_idx[GST_AV1_REFS_PER_FRAME];
+  gint32 expected_frame_id[GST_AV1_REFS_PER_FRAME];
   gboolean allow_high_precision_mv;
   gboolean is_motion_mode_switchable;
   gboolean use_ref_frame_mvs;
@@ -1583,6 +1582,8 @@ struct _GstAV1FrameHeaderOBU {
   gboolean skip_mode_present;
   gboolean reference_select;
   GstAV1GlobalMotionParams global_motion_params;
+  /* The ref of global_motion_params for primary_ref_frame, used for writer */
+  GstAV1GlobalMotionParams ref_global_motion_params;
   GstAV1FilmGrainParams film_grain_params;
 
   /* Global vars set by frame header */
diff --git a/gst-libs/gst/codecparsers/gstvp9bitwriter.c b/gst-libs/gst/codecparsers/gstvp9bitwriter.c
new file mode 100644
index 0000000..845b68d
--- /dev/null
+++ b/gst-libs/gst/codecparsers/gstvp9bitwriter.c
@@ -0,0 +1,171 @@
+/* GStreamer
+ *  Copyright (C) 2022 Intel Corporation
+ *     Author: He Junyan <junyan.he@intel.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the0
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstvp9bitwriter.h"
+#include <gst/base/gstbitwriter.h>
+
+#define WRITE_BITS_UNCHECK(bw, val, nbits)                                    \
+  (nbits <= 8 ? gst_bit_writer_put_bits_uint8 (bw, val, nbits) :              \
+   (nbits <= 16 ? gst_bit_writer_put_bits_uint16 (bw, val, nbits) :           \
+    (nbits <= 32 ? gst_bit_writer_put_bits_uint32 (bw, val, nbits) :          \
+     FALSE)))
+
+#define WRITE_BITS(bw, val, nbits)                                            \
+  if (!WRITE_BITS_UNCHECK (bw, val, nbits)) {                                 \
+    g_warning ("Unsupported bit size: %u", nbits);                            \
+    have_space = FALSE;                                                       \
+    goto error;                                                               \
+  }
+
+/**
+ * gst_vp9_bit_writer_frame_header:
+ * @frame_hdr: the frame header of #GstVp9FrameHdr to write
+ * @data: (out): the stream generated by the frame header
+ * @size: (inout): the size in bytes of the input and output
+ *
+ * Generating the according VP9 bit stream by providing the frame header.
+ *
+ * Returns: a #GstVp9BitWriterResult
+ *
+ * Since: 1.22
+ **/
+GstVp9BitWriterResult
+gst_vp9_bit_writer_frame_header (const GstVp9FrameHdr * frame_hdr,
+    guint8 * data, guint * size)
+{
+  gboolean have_space = TRUE;
+  GstBitWriter bw;
+
+  g_return_val_if_fail (frame_hdr != NULL, GST_VP9_BIT_WRITER_ERROR);
+  g_return_val_if_fail (data != NULL, GST_VP9_BIT_WRITER_ERROR);
+  g_return_val_if_fail (size != NULL, GST_VP9_BIT_WRITER_ERROR);
+  g_return_val_if_fail (*size > 0, GST_VP9_BIT_WRITER_ERROR);
+
+  gst_bit_writer_init_with_data (&bw, data, *size, FALSE);
+
+  WRITE_BITS (&bw, GST_VP9_FRAME_MARKER, 2);
+  /* profile_low_bit */
+  WRITE_BITS (&bw, frame_hdr->profile & 0x01, 1);
+  /* profile_high_bit */
+  WRITE_BITS (&bw, (frame_hdr->profile & 0x02) >> 1, 1);
+  if (frame_hdr->profile == 3)
+    WRITE_BITS (&bw, 0, 1);
+
+  if (frame_hdr->show_existing_frame) {
+    WRITE_BITS (&bw, frame_hdr->show_existing_frame, 1);
+    WRITE_BITS (&bw, frame_hdr->frame_to_show, 3);
+    gst_bit_writer_align_bytes (&bw, 0);
+  } else {
+    GST_WARNING ("Frame header writing is not implemented.");
+    goto error;
+  }
+
+  g_assert (gst_bit_writer_get_size (&bw) % 8 == 0);
+  *size = gst_bit_writer_get_size (&bw) / 8;
+
+  gst_bit_writer_reset (&bw);
+
+  return GST_VP9_BIT_WRITER_OK;
+
+error:
+  gst_bit_writer_reset (&bw);
+  *size = 0;
+  return have_space ? GST_VP9_BIT_WRITER_INVALID_DATA :
+      GST_VP9_BIT_WRITER_NO_MORE_SPACE;
+}
+
+/**
+ * gst_vp9_bit_writer_superframe_info:
+ * @frame_num: the frame number to composite this super frame
+ * @frame_size: the size of each frame
+ * @data: (inout): the stream data of this super frame
+ * @size: (inout): the size in bytes of the input and output
+ *
+ * Appending the super frame info at the end of this stream.
+ * Note: the input @data should already contain all frames' data in
+ * the same order of @frame_size.
+ *
+ * Returns: a #GstVp9BitWriterResult
+ *
+ * Since: 1.22
+ **/
+GstVp9BitWriterResult
+gst_vp9_bit_writer_superframe_info (guint frame_num, gint * frame_size,
+    guint8 * data, guint * size)
+{
+  GstBitWriter bw;
+  GstVp9BitWriterResult ret = GST_VP9_BIT_WRITER_OK;
+  guint data_sz = 0;
+  guint i, j;
+
+  g_return_val_if_fail (frame_num <= GST_VP9_MAX_FRAMES_IN_SUPERFRAME,
+      GST_VP9_BIT_WRITER_ERROR);
+  g_return_val_if_fail (frame_size != NULL, GST_VP9_BIT_WRITER_ERROR);
+  g_return_val_if_fail (data != NULL, GST_VP9_BIT_WRITER_ERROR);
+  g_return_val_if_fail (size != NULL, GST_VP9_BIT_WRITER_ERROR);
+
+  for (i = 0; i < frame_num; i++)
+    data_sz += frame_size[i];
+
+  if (*size < data_sz + 1 /* superframe_header */  +
+      4 * frame_num /* superframe_index */  + 1 /* superframe_header */ ) {
+    ret = GST_VP9_BIT_WRITER_NO_MORE_SPACE;
+    goto out;
+  }
+
+  memset (data + data_sz, 0, 1 + 4 * frame_num + 1);
+  gst_bit_writer_init_with_data (&bw, data + data_sz,
+      1 + 4 * frame_num + 1, FALSE);
+
+  /* superframe_header() */
+  gst_bit_writer_put_bits_uint8 (&bw, GST_VP9_SUPERFRAME_MARKER, 3);
+  /* bytes_per_framesize_minus_1 */
+  gst_bit_writer_put_bits_uint8 (&bw, 4 - 1, 2);
+  /* frames_in_superframe_minus_1 */
+  gst_bit_writer_put_bits_uint8 (&bw, frame_num - 1, 3);
+
+  for (i = 0; i < frame_num; i++) {
+    guint32 value = frame_size[i];
+    for (j = 0; j < 4; j++)
+      gst_bit_writer_put_bits_uint8 (&bw, (value >> j * 8) & 0xff, 8);
+  }
+
+  /* superframe_header() again */
+  gst_bit_writer_put_bits_uint8 (&bw, GST_VP9_SUPERFRAME_MARKER, 3);
+  /* bytes_per_framesize_minus_1 */
+  gst_bit_writer_put_bits_uint8 (&bw, 4 - 1, 2);
+  /* frames_in_superframe_minus_1 */
+  gst_bit_writer_put_bits_uint8 (&bw, frame_num - 1, 3);
+
+  g_assert (gst_bit_writer_get_size (&bw) % 8 == 0);
+  *size = data_sz + gst_bit_writer_get_size (&bw) / 8;
+
+out:
+  gst_bit_writer_reset (&bw);
+
+  if (ret != GST_VP9_BIT_WRITER_OK)
+    *size = 0;
+
+  return ret;
+}
diff --git a/gst-libs/gst/codecparsers/gstvp9bitwriter.h b/gst-libs/gst/codecparsers/gstvp9bitwriter.h
new file mode 100644
index 0000000..f86c80d
--- /dev/null
+++ b/gst-libs/gst/codecparsers/gstvp9bitwriter.h
@@ -0,0 +1,59 @@
+/* GStreamer
+ *  Copyright (C) 2022 Intel Corporation
+ *     Author: He Junyan <junyan.he@intel.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the0
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_VP9_BIT_WRITER_H__
+#define __GST_VP9_BIT_WRITER_H__
+
+#include <gst/codecparsers/gstvp9parser.h>
+#include <gst/codecparsers/codecparsers-prelude.h>
+
+G_BEGIN_DECLS
+
+/**
+ * GstVp9BitWriterResult:
+ * @GST_VP9_BIT_WRITER_OK: The writing succeeded
+ * @GST_VP9_BIT_WRITER_INVALID_DATA: The input data to write is invalid
+ * @GST_VP9_BIT_WRITER_NO_MORE_SPACE: The output does not have enough size
+ * @GST_VP9_BIT_WRITER_ERROR: An general error occurred when writing
+ *
+ * The result of writing VP9 data into bit stream.
+ *
+ * Since: 1.22
+ */
+typedef enum
+{
+  GST_VP9_BIT_WRITER_OK,
+  GST_VP9_BIT_WRITER_INVALID_DATA,
+  GST_VP9_BIT_WRITER_NO_MORE_SPACE,
+  GST_VP9_BIT_WRITER_ERROR
+} GstVp9BitWriterResult;
+
+GST_CODEC_PARSERS_API
+GstVp9BitWriterResult     gst_vp9_bit_writer_frame_header    (const GstVp9FrameHdr * frame_hdr,
+                                                              guint8 * data,
+                                                              guint * size);
+GST_CODEC_PARSERS_API
+GstVp9BitWriterResult     gst_vp9_bit_writer_superframe_info (guint frame_num,
+                                                              gint * frame_size,
+                                                              guint8 * data,
+                                                              guint * total_size);
+
+G_END_DECLS
+#endif /* __GST_VP9_BIT_WRITER_H__ */
diff --git a/gst-libs/gst/codecparsers/meson.build b/gst-libs/gst/codecparsers/meson.build
index c06c299..94c1a53 100644
--- a/gst-libs/gst/codecparsers/meson.build
+++ b/gst-libs/gst/codecparsers/meson.build
@@ -18,6 +18,8 @@ codecparser_sources = files([
   'gstav1parser.c',
   'gsth264bitwriter.c',
   'gsth265bitwriter.c',
+  'gstvp9bitwriter.c',
+  'gstav1bitwriter.c',
 ])
 codecparser_headers = [
   'codecparsers-prelude.h',
diff --git a/sys/va/gstvaav1enc.c b/sys/va/gstvaav1enc.c
new file mode 100644
index 0000000..4ce400f
--- /dev/null
+++ b/sys/va/gstvaav1enc.c
@@ -0,0 +1,4342 @@
+/* GStreamer
+ *  Copyright (C) 2022 Intel Corporation
+ *     Author: He Junyan <junyan.he@intel.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:element-vaav1enc
+ * @title: vaav1enc
+ * @short_description: A VA-API based AV1 video encoder
+ *
+ * vaav1enc encodes raw video VA surfaces into AV1 bitstreams using
+ * the installed and chosen [VA-API](https://01.org/linuxmedia/vaapi)
+ * driver.
+ *
+ * The raw video frames in main memory can be imported into VA surfaces.
+ *
+ * ## Example launch line
+ * ```
+ * gst-launch-1.0 videotestsrc num-buffers=60 ! timeoverlay ! vaav1enc ! av1parse ! mp4mux ! filesink location=test.mp4
+ * ```
+ *
+ * Since: 1.22
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstvaav1enc.h"
+
+#include <gst/codecparsers/gstav1bitwriter.h>
+#include <gst/va/gstva.h>
+#include <gst/va/gstvavideoformat.h>
+#include <gst/video/video.h>
+#include <va/va_drmcommon.h>
+
+#include "gstvabaseenc.h"
+#include "gstvacaps.h"
+#include "gstvadisplay_priv.h"
+#include "gstvaencoder.h"
+#include "gstvaprofile.h"
+#include "vacompat.h"
+
+GST_DEBUG_CATEGORY_STATIC (gst_va_av1enc_debug);
+#define GST_CAT_DEFAULT gst_va_av1enc_debug
+
+#define GST_VA_AV1_ENC(obj)            ((GstVaAV1Enc *) obj)
+#define GST_VA_AV1_ENC_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), G_TYPE_FROM_INSTANCE (obj), GstVaAV1EncClass))
+#define GST_VA_AV1_ENC_CLASS(klass)    ((GstVaAV1EncClass *) klass)
+
+typedef struct _GstVaAV1Enc GstVaAV1Enc;
+typedef struct _GstVaAV1EncClass GstVaAV1EncClass;
+typedef struct _GstVaAV1LevelLimits GstVaAV1LevelLimits;
+typedef struct _GstVaAV1GFGroup GstVaAV1GFGroup;
+typedef struct _GstVaAV1Ref GstVaAV1Ref;
+typedef struct _GstVaAV1EncFrame GstVaAV1EncFrame;
+
+enum
+{
+  PROP_KEYFRAME_INT = 1,
+  PROP_GOLDEN_GROUP_SIZE,
+  PROP_NUM_REF_FRAMES,
+  PROP_HIERARCHICAL_LEVEL,
+  PROP_128X128_SUPERBLOCK,
+  PROP_MIN_QP,
+  PROP_MAX_QP,
+  PROP_QP,
+  PROP_BITRATE,
+  PROP_TARGET_PERCENTAGE,
+  PROP_TARGET_USAGE,
+  PROP_CPB_SIZE,
+  PROP_RATE_CONTROL,
+  PROP_NUM_TILE_COLS,
+  PROP_NUM_TILE_ROWS,
+  PROP_TILE_GROUPS,
+  PROP_MBBRC,
+  N_PROPERTIES
+};
+
+static GParamSpec *properties[N_PROPERTIES];
+
+static GstElementClass *parent_class = NULL;
+
+#define DEFAULT_BASE_QINDEX  128
+
+#define MAX_KEY_FRAME_INTERVAL  1024
+#define MAX_GF_GROUP_SIZE  32
+#define HIGHEST_PYRAMID_LEVELS  6
+#define INVALID_PYRAMID_LEVEL  -1
+
+#define FRAME_TYPE_INVALID  -1
+#define FRAME_TYPE_REPEAT  0x80
+/* The frame is golden frame */
+#define FRAME_FLAG_GF  0x01
+/* The frame is alt frame */
+#define FRAME_FLAG_ALT  0x02
+/* The frame is on the top level */
+#define FRAME_FLAG_LEAF  0x04
+/* The frame can be internal alt frame */
+#define FRAME_FLAG_ALT_INL  0x08
+/* The frame update the DPB reference */
+#define FRAME_FLAG_UPDATE_REF  0x10
+/* The frame is the last frame in a GF group */
+#define FRAME_FLAG_LAST_IN_GF  0x20
+/* The frame has already be encoded */
+#define FRAME_FLAG_ALREADY_ENCODED  0x40
+/* The frame has already outputted */
+#define FRAME_FLAG_ALREADY_OUTPUTTED  0x80
+/* The frame not show */
+#define FRAME_FLAG_NOT_SHOW  0x100
+
+struct _GstVaAV1GFGroup
+{
+  /* where this GF group start since key frame. */
+  gint start_frame_offset;
+  /* Total frame number of this group. */
+  gint group_frame_num;
+  /* Be different from group_frame_num, include repeat */
+  gint output_frame_num;
+  gint last_pushed_num;
+  gint last_poped_index;
+  guint8 highest_level;
+  gboolean use_alt;
+  gboolean intra_only;
+  GQueue *reorder_list;
+
+  /* Include FRAME_TYPEs or FRAME_TYPE_REPEAT. */
+  GstAV1FrameType frame_types[MAX_GF_GROUP_SIZE * 2];
+  gint8 pyramid_levels[MAX_GF_GROUP_SIZE * 2];
+  guint32 flags[MAX_GF_GROUP_SIZE * 2];
+  /* offset from start_frame_num. */
+  gint frame_offsets[MAX_GF_GROUP_SIZE * 2];
+};
+
+struct _GstVaAV1Ref
+{
+  GstVideoCodecFrame *frame;
+  guint index_in_dpb;
+};
+
+struct _GstVaAV1EncFrame
+{
+  GstVaEncodePicture *picture;
+  GstAV1FrameType type;
+  guint8 temporal_id;
+  guint8 spatial_id;
+  /* AV1 does not define a frame number.
+     This is a virtual number after the key frame. */
+  gint frame_num;
+  guint32 flags;
+  guint pyramid_level;
+  /* The total frame count we handled. */
+  guint total_frame_count;
+  gboolean bidir_ref;
+  gint8 ref_frame_idx[GST_AV1_NUM_REF_FRAMES];
+  /* The index in reference list to update */
+  gint update_index;
+  gint order_hint;
+  /* repeat the current frame */
+  gint8 repeat_index;
+  gsize repeat_frame_header_size;
+  guint8 repeat_frame_header[32];
+};
+
+struct _GstVaAV1Enc
+{
+  /*< private > */
+  GstVaBaseEnc parent;
+
+  guint32 packed_headers;
+
+  guint mi_rows;
+  guint mi_cols;
+  gint level_idx;
+  const gchar *level_str;
+  guint tier;
+  guint cr;
+  guint depth;
+  guint chrome;
+  GstClockTime last_pts;
+  GstClockTime last_dts;
+
+  /* properties */
+  struct
+  {
+    /* kbps */
+    guint bitrate;
+    /* VA_RC_XXX */
+    guint rc_ctrl;
+    guint32 target_usage;
+    guint32 cpb_size;
+    guint32 target_percentage;
+    guint gf_group_size;
+    guint num_ref_frames;
+    guint max_hierarchical_level;
+    gboolean use_128x128_superblock;
+    guint keyframe_interval;
+    guint32 qp;
+    guint32 min_qp;
+    guint32 max_qp;
+    guint32 num_tile_cols;
+    guint32 num_tile_rows;
+    guint32 tile_groups;
+    guint32 mbbrc;
+  } prop;
+
+  struct
+  {
+    guint keyframe_interval;
+    guint gf_group_size;
+    guint max_level;
+    guint num_ref_frames;
+    /* Forward only(P kind frame) may have diff refs num in l0 */
+    guint forward_only_ref_num;
+    guint forward_ref_num;
+    guint backward_ref_num;
+    guint frame_num_since_kf;
+    gboolean enable_order_hint;
+    GstVaAV1GFGroup current_group;
+    GstVideoCodecFrame *last_keyframe;
+    GstVideoCodecFrame *ref_list[GST_AV1_NUM_REF_FRAMES];
+  } gop;
+
+  struct
+  {
+    guint sb_rows;
+    guint sb_cols;
+    gboolean use_128x128_superblock;
+    guint32 num_tile_cols;
+    guint32 num_tile_rows;
+    guint32 tile_groups;
+    guint32 tile_cols_log2;
+    guint32 tile_rows_log2;
+    gboolean uniform;
+    guint32 tile_width_sb;
+    guint32 tile_height_sb;
+    /* To calculate tile size bytes in tile group obu */
+    guint32 tile_size_bytes_minus_1;
+    guint32 max_tile_num;
+  } partition;
+
+  struct
+  {
+    guint target_usage;
+    guint32 target_percentage;
+    guint32 cpb_size;
+    guint32 cpb_length_bits;
+    guint32 rc_ctrl_mode;
+    guint max_bitrate;
+    guint max_bitrate_bits;
+    guint target_bitrate;
+    guint target_bitrate_bits;
+    guint32 base_qindex;
+    guint32 min_qindex;
+    guint32 max_qindex;
+    guint32 mbbrc;
+  } rc;
+
+  struct
+  {
+    gboolean enable_cdef;
+    gboolean cdef_channel_strength;
+    guint8 cdef_bits;
+    gboolean enable_filter_intra;
+    gboolean enable_intra_edge_filter;
+    gboolean enable_interintra_compound;
+    gboolean enable_masked_compound;
+    gboolean enable_warped_motion;
+    gboolean enable_palette_mode;
+    gboolean enable_dual_filter;
+    gboolean enable_jnt_comp;
+    gboolean enable_ref_frame_mvs;
+    gboolean enable_superres;
+    gboolean enable_restoration;
+    gboolean allow_intrabc;
+    gboolean enable_segmentation;
+    /* (1 << interpolation_filter) means support not not. */
+    guint32 interpolation_filter_support;
+    /* The interpolation type we choose */
+    GstAV1InterpolationFilter interpolation_type;
+    /* The size field bytes in obu header */
+    guint obu_size_bytes;
+    /* (tx_mode_support & mode) == 1 means support the mode. */
+    guint tx_mode_support;
+  } features;
+
+  GstAV1SequenceHeaderOBU sequence_hdr;
+};
+
+struct _GstVaAV1EncClass
+{
+  GstVaBaseEncClass parent_class;
+
+  GType rate_control_type;
+  char rate_control_type_name[64];
+  GEnumValue rate_control[16];
+};
+
+/**
+ * GstVaAV1LevelLimits:
+ * @level_name: the level name
+ * @seq_level_idx: specifies the level index value
+ * @MaxPicSize: the maximum of picture size in samples
+ * @MaxHSize: the maximum of picture width in samples
+ * @MaxVSize: the maximum of picture height in samples
+ * @MaxDisplayRate: the maximum of display luma samples rate per second
+ * @MaxDecodeRate: the maximum of decode luma samples rate per second
+ * @MaxHeaderRate: the maximum number of frame/frame_header per second
+ * @MainMbps: the maximum bit rate in for main tier
+ * @HighMbps: the maximum bit rate in for high tier
+ * @MainCR: the minimum picture compress ratio for main tier
+ * @HighCR: the minimum picture compress ratio for high tier
+ * @MaxTiles: the maximum tile number
+ * @MaxTileCols: the maximum tile number in column
+ *
+ * The data structure that describes the limits of an AV1 level.
+ */
+struct _GstVaAV1LevelLimits
+{
+  const gchar *level_name;
+  guint8 seq_level_idx;
+  guint32 MaxPicSize;
+  guint32 MaxHSize;
+  guint32 MaxVSize;
+  guint64 MaxDisplayRate;
+  guint64 MaxDecodeRate;
+  guint32 MaxHeaderRate;
+  guint32 MainMbps;
+  guint32 HighMbps;
+  guint32 MainCR;
+  guint32 HighCR;
+  guint32 MaxTiles;
+  guint32 MaxTileCols;
+};
+
+/* A.3. Levels */
+/* *INDENT-OFF* */
+static const GstVaAV1LevelLimits _va_av1_level_limits[] = {
+/* level idx MaxPicSize MaxHSize MaxVSize MaxDisplayRate MaxDecodeRate MaxHeaderRate MainMbps  HighMbps  MainCR HighCR MaxTiles MaxTileCols*/
+  {"2.0", 0, 147456,    2048,    1152,    4423680,       5529600,      150,          1500000,  0,        2,     0,     8,       4           },
+  {"2.1", 1, 278784,    2816,    1584,    8363520,       10454400,     150,          3000000,  0,        2,     0,     8,       4           },
+  {"3.0", 4, 665856,    4352,    2448,    19975680,      24969600,     150,          6000000,  0,        2,     0,     16,      6           },
+  {"3.1", 5, 1065024,   5504,    3096,    31950720,      39938400,     150,          10000000, 0,        2,     0,     16,      6           },
+  {"4.0", 8, 2359296,   6144,    3456,    70778880,      77856768,     300,          12000000, 30000000, 4,     4,     32,      8           },
+  {"4.1", 9, 2359296,   6144,    3456,    141557760,     155713536,    300,          20000000, 50000000, 4,     4,     32,      8           },
+  {"5.0", 12,8912896,   8192,    4352,    267386880,     273715200,    300,          30000000, 100000000,6,     4,     64,      8           },
+  {"5.1", 13,8912896,   8192,    4352,    534773760,     547430400,    300,          40000000, 160000000,8,     4,     64,      8           },
+  {"5.2", 14,8912896,   8192,    4352,    1069547520,    1094860800,   300,          60000000, 240000000,8,     4,     64,      8           },
+  {"5.3", 15,8912896,   8192,    4352,    1069547520,    1176502272,   300,          60000000, 240000000,8,     4,     64,      8           },
+  {"6.0", 16,35651584,  16384,   8704,    1069547520,    1176502272,   300,          60000000, 240000000,8,     4,     128,     16          },
+  {"6.1", 17,35651584,  16384,   8704,    2139095040,    2189721600,   300,          100000000,480000000,8,     4,     128,     16          },
+  {"6.2", 18,35651584,  16384,   8704,    4278190080,    4379443200,   300,          160000000,800000000,8,     4,     128,     16          },
+  {"6.3", 19,35651584,  16384,   8704,    4278190080,    4706009088,   300,          160000000,800000000,8,     4,     128,     16          },
+};
+/* *INDENT-ON* */
+
+static gboolean
+_av1_calculate_level_and_tier (GstVaAV1Enc * self)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  gint pic_size;
+  guint64 display_rate /* TotalDisplayLumaSampleRate */ ;
+  guint max_bitrate;
+  guint tier = 0;
+  int i;
+
+  pic_size = base->width * base->height;
+  display_rate = gst_util_uint64_scale_int_ceil (pic_size,
+      GST_VIDEO_INFO_FPS_N (&base->input_state->info),
+      GST_VIDEO_INFO_FPS_D (&base->input_state->info));
+
+  for (i = 0; i < G_N_ELEMENTS (_va_av1_level_limits); i++) {
+    const GstVaAV1LevelLimits *limits = &_va_av1_level_limits[i];
+
+    tier = 0;
+
+    if (pic_size > limits->MaxPicSize)
+      continue;
+
+    if (base->width > limits->MaxHSize)
+      continue;
+
+    if (base->height > limits->MaxVSize)
+      continue;
+
+    if (display_rate > limits->MaxDisplayRate)
+      continue;
+
+    max_bitrate = limits->HighMbps != 0 ? limits->HighMbps : limits->MainMbps;
+    if (self->rc.max_bitrate > max_bitrate)
+      continue;
+    if (self->rc.max_bitrate > limits->MainMbps)
+      tier = 1;
+
+    if (self->partition.num_tile_cols * self->partition.num_tile_rows >
+        limits->MaxTiles)
+      continue;
+
+    if (self->partition.num_tile_cols > limits->MaxTileCols)
+      continue;
+
+    /* decode rate, header rate, compress rate, etc. are not considered. */
+    break;
+  }
+
+  if (i == G_N_ELEMENTS (_va_av1_level_limits)) {
+    GST_ERROR_OBJECT (self,
+        "failed to find suitable level and tier matching codec config");
+    return FALSE;
+  }
+
+  self->level_idx = _va_av1_level_limits[i].seq_level_idx;
+  self->level_str = _va_av1_level_limits[i].level_name;
+  self->tier = tier;
+  self->cr =
+      tier ? _va_av1_level_limits[i].HighCR : _va_av1_level_limits[i].MainCR;
+  g_assert (self->cr > 0);
+
+  GST_INFO_OBJECT (self, "Use level: %s, tier is %d, cr is %d",
+      self->level_str, self->tier, self->cr);
+  return TRUE;
+}
+
+static gint
+_av1_helper_msb (guint n)
+{
+  int log = 0;
+  guint value = n;
+  int i;
+
+  g_assert (n != 0);
+
+  for (i = 4; i >= 0; --i) {
+    const gint shift = (1 << i);
+    const guint x = value >> shift;
+    if (x != 0) {
+      value = x;
+      log += shift;
+    }
+  }
+
+  return log;
+}
+
+static inline GstVaAV1EncFrame *
+_enc_frame (GstVideoCodecFrame * frame)
+{
+  GstVaAV1EncFrame *enc_frame = gst_video_codec_frame_get_user_data (frame);
+
+  g_assert (enc_frame);
+
+  return enc_frame;
+}
+
+#ifndef GST_DISABLE_GST_DEBUG
+static const gchar *
+_rate_control_get_name (guint32 rc_mode)
+{
+  GParamSpecEnum *spec;
+  guint i;
+
+  if (!(properties[PROP_RATE_CONTROL]
+          && G_IS_PARAM_SPEC_ENUM (properties[PROP_RATE_CONTROL])))
+    return NULL;
+
+  spec = G_PARAM_SPEC_ENUM (properties[PROP_RATE_CONTROL]);
+  for (i = 0; i < spec->enum_class->n_values; i++) {
+    if (spec->enum_class->values[i].value == rc_mode)
+      return spec->enum_class->values[i].value_nick;
+  }
+
+  return NULL;
+}
+#endif /* end of GST_DISABLE_GST_DEBUG */
+
+static GstVaAV1EncFrame *
+gst_va_av1_enc_frame_new (void)
+{
+  GstVaAV1EncFrame *frame;
+
+  frame = g_slice_new (GstVaAV1EncFrame);
+  frame->frame_num = -1;
+  frame->type = FRAME_TYPE_INVALID;
+  frame->temporal_id = 0;
+  frame->spatial_id = 0;
+  frame->picture = NULL;
+  frame->total_frame_count = 0;
+  frame->pyramid_level = 0;
+  frame->flags = 0;
+  frame->bidir_ref = FALSE;
+  frame->update_index = -1;
+  frame->order_hint = -1;
+  frame->repeat_index = -1;
+  frame->repeat_frame_header_size = 0;
+
+  return frame;
+}
+
+static void
+gst_va_av1_enc_frame_free (gpointer pframe)
+{
+  GstVaAV1EncFrame *frame = pframe;
+
+  g_clear_pointer (&frame->picture, gst_va_encode_picture_free);
+  g_slice_free (GstVaAV1EncFrame, frame);
+}
+
+static gboolean
+gst_va_av1_enc_new_frame (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
+{
+  GstVaAV1EncFrame *frame_in;
+
+  frame_in = gst_va_av1_enc_frame_new ();
+  frame_in->total_frame_count = base->input_frame_count++;
+  gst_video_codec_frame_set_user_data (frame, frame_in,
+      gst_va_av1_enc_frame_free);
+
+  return TRUE;
+}
+
+#ifndef GST_DISABLE_GST_DEBUG
+static const char *
+_av1_get_frame_type_name (GstAV1FrameType frame_type)
+{
+  const gchar *frame_type_name = NULL;
+  guint type = frame_type;
+
+  if (type & FRAME_TYPE_REPEAT)
+    return "Repeat ";
+
+  switch (type) {
+    case GST_AV1_KEY_FRAME:
+      frame_type_name = "Key    ";
+      break;
+    case GST_AV1_INTER_FRAME:
+      frame_type_name = "Inter  ";
+      break;
+    case GST_AV1_INTRA_ONLY_FRAME:
+      frame_type_name = "Intra  ";
+      break;
+    case GST_AV1_SWITCH_FRAME:
+      frame_type_name = "Switch ";
+      break;
+    default:
+      frame_type_name = "Unknown";
+      break;
+  }
+
+  return frame_type_name;
+}
+#endif
+
+static void
+_av1_print_gf_group (GstVaAV1Enc * self, GstVaAV1GFGroup * gf_group)
+{
+#ifndef GST_DISABLE_GST_DEBUG
+  gint pushed_frame_num = gf_group->last_pushed_num < 0 ? 0 :
+      gf_group->last_pushed_num - gf_group->start_frame_offset + 1;
+  GString *str;
+  gint i;
+
+  if (gst_debug_category_get_threshold (GST_CAT_DEFAULT) < GST_LEVEL_LOG)
+    return;
+
+  str = g_string_new (NULL);
+
+  g_string_append_printf (str, "\n============================"
+      " GF Group ===========================\n");
+  g_string_append_printf (str, " start:%d,  size:%d  ",
+      gf_group->start_frame_offset, gf_group->group_frame_num);
+  g_string_append_printf (str, "pushed:%d,  poped:%d  ",
+      pushed_frame_num, gf_group->last_poped_index + 1);
+  g_string_append_printf (str, "\n ALT: %s  max level: %d  output num: %d",
+      gf_group->use_alt ? "yes" : "no", gf_group->highest_level,
+      gf_group->output_frame_num);
+
+  g_string_append_printf (str, "\n----------------------------"
+      "-------------------------------------\n");
+  g_string_append_printf (str, "|     |  type   | level |"
+      "             flags            | offset |\n");
+
+  g_string_append_printf (str, "----------------------------"
+      "-------------------------------------\n");
+  for (i = 0; i < gf_group->output_frame_num; i++) {
+    g_string_append_printf (str, "| %3d ", i);
+    g_string_append_printf (str, "| %s ",
+        _av1_get_frame_type_name (gf_group->frame_types[i]));
+
+    g_string_append_printf (str, "| %5d | ", gf_group->pyramid_levels[i]);
+
+    if (gf_group->flags[i] & FRAME_FLAG_GF) {
+      g_string_append_printf (str, "GF ");
+    } else {
+      g_string_append_printf (str, "   ");
+    }
+
+    if (gf_group->flags[i] & FRAME_FLAG_LAST_IN_GF) {
+      g_string_append_printf (str, "Last ");
+    } else {
+      g_string_append_printf (str, "     ");
+    }
+
+    if (gf_group->flags[i] & (FRAME_FLAG_ALT | FRAME_FLAG_ALT_INL)) {
+      g_string_append_printf (str, "ALT ");
+    } else {
+      g_string_append_printf (str, "    ");
+    }
+
+    if (gf_group->flags[i] & FRAME_FLAG_NOT_SHOW) {
+      g_string_append_printf (str, "Unshown ");
+    } else {
+      g_string_append_printf (str, "Shown   ");
+    }
+
+    if (gf_group->flags[i] & FRAME_FLAG_LEAF) {
+      g_string_append_printf (str, "Leaf ");
+    } else {
+      g_string_append_printf (str, "     ");
+    }
+
+    if (gf_group->flags[i] & FRAME_FLAG_UPDATE_REF) {
+      g_string_append_printf (str, "Ref ");
+    } else {
+      g_string_append_printf (str, "    ");
+    }
+
+    g_string_append_printf (str, "| %-5d  | ", gf_group->frame_offsets[i]);
+
+    g_string_append_printf (str, "\n");
+  }
+
+  g_string_append_printf (str, "---------------------------"
+      "--------------------------------------\n");
+
+  GST_LOG_OBJECT (self, "%s", str->str);
+
+  g_string_free (str, TRUE);
+
+#endif
+}
+
+#ifndef GST_DISABLE_GST_DEBUG
+static void
+_av1_print_ref_list (GstVaAV1Enc * self, GString * str)
+{
+  gint i;
+
+  g_string_append_printf (str, "\n================== Reference List "
+      "===================\n");
+
+  g_string_append_printf (str, "|   index   |");
+  for (i = 0; i < GST_AV1_NUM_REF_FRAMES; i++)
+    g_string_append_printf (str, "%3d |", i);
+
+  g_string_append_printf (str, "\n-------------------------------"
+      "----------------------\n");
+
+  g_string_append_printf (str, "| frame num |");
+  for (i = 0; i < GST_AV1_NUM_REF_FRAMES; i++) {
+    if (self->gop.ref_list[i]) {
+      GstVaAV1EncFrame *va_frame = _enc_frame (self->gop.ref_list[i]);
+      g_string_append_printf (str, "%3d |", va_frame->frame_num);
+    } else {
+      g_string_append_printf (str, "%3d |", -1);
+    }
+  }
+  g_string_append_printf (str, "\n-------------------------------"
+      "----------------------\n");
+}
+#endif
+
+static void
+_av1_print_frame_reference (GstVaAV1Enc * self, GstVideoCodecFrame * frame)
+{
+#ifndef GST_DISABLE_GST_DEBUG
+  GString *str;
+  GstVaAV1EncFrame *va_frame;
+  gint i;
+
+  if (gst_debug_category_get_threshold (GST_CAT_DEFAULT) < GST_LEVEL_LOG)
+    return;
+
+  str = g_string_new (NULL);
+
+  _av1_print_ref_list (self, str);
+
+  va_frame = _enc_frame (frame);
+
+  g_string_append_printf (str, "Current %sframe num: %d,  ",
+      va_frame->frame_num == 0 ? "key " : "", va_frame->frame_num);
+
+  if (va_frame->type & FRAME_TYPE_REPEAT) {
+    g_string_append_printf (str, "repeat index %d", va_frame->repeat_index);
+    goto print;
+  }
+
+  g_string_append_printf (str, "Reference: [");
+
+  for (i = GST_AV1_REF_LAST_FRAME; i < GST_AV1_NUM_REF_FRAMES; i++) {
+    switch (i) {
+      case GST_AV1_REF_LAST_FRAME:
+        g_string_append_printf (str, " %s", "Last");
+        break;
+      case GST_AV1_REF_LAST2_FRAME:
+        g_string_append_printf (str, " %s", "Last2");
+        break;
+      case GST_AV1_REF_LAST3_FRAME:
+        g_string_append_printf (str, " %s", "Last3");
+        break;
+      case GST_AV1_REF_GOLDEN_FRAME:
+        g_string_append_printf (str, " %s", "Golden");
+        break;
+      case GST_AV1_REF_BWDREF_FRAME:
+        g_string_append_printf (str, " %s", "Bwd");
+        break;
+      case GST_AV1_REF_ALTREF2_FRAME:
+        g_string_append_printf (str, " %s", "Alt2");
+        break;
+      case GST_AV1_REF_ALTREF_FRAME:
+        g_string_append_printf (str, " %s", "Alt");
+        break;
+      default:
+        g_assert_not_reached ();
+        break;
+    }
+    g_string_append_printf (str, ":");
+
+    if (va_frame->ref_frame_idx[i] == -1) {
+      g_string_append_printf (str, "unused");
+    } else {
+      g_string_append_printf (str, "%d", va_frame->ref_frame_idx[i]);
+    }
+
+    if (i != GST_AV1_NUM_REF_FRAMES - 1) {
+      g_string_append_printf (str, ", ");
+    } else {
+      g_string_append_printf (str, " ");
+    }
+  }
+
+  g_string_append_printf (str, "]");
+
+print:
+  GST_LOG_OBJECT (self, "%s", str->str);
+
+  g_string_free (str, TRUE);
+#endif
+}
+
+static void
+_av1_print_ref_list_update (GstVaAV1Enc * self, gint update_index,
+    GstVideoCodecFrame * del_frame, GstVideoCodecFrame * add_frame)
+{
+#ifndef GST_DISABLE_GST_DEBUG
+  GString *str;
+
+  if (gst_debug_category_get_threshold (GST_CAT_DEFAULT) < GST_LEVEL_LOG)
+    return;
+
+  str = g_string_new (NULL);
+
+  _av1_print_ref_list (self, str);
+
+  if (_enc_frame (add_frame)->frame_num == 0)
+    g_string_append_printf (str, "Key frame clear all reference list.\n");
+
+  if (update_index >= 0) {
+    if (del_frame) {
+      g_string_append_printf (str, "Replace index %d, delete frame num %d, "
+          "add frame num %d.", update_index, _enc_frame (del_frame)->frame_num,
+          _enc_frame (add_frame)->frame_num);
+    } else {
+      g_string_append_printf (str, "Add frame %d to index %d.",
+          _enc_frame (add_frame)->frame_num, update_index);
+    }
+  }
+
+  GST_LOG_OBJECT (self, "%s", str->str);
+
+  g_string_free (str, TRUE);
+#endif
+}
+
+/* [ start, end ) */
+static void
+_set_multi_layer (GstVaAV1GFGroup * gf_group, gint * frame_index,
+    gint start, gint end, guint level, guint max_level)
+{
+  const gint num_frames_to_process = end - start;
+  guint m = (start + end - 1) / 2;
+
+  g_assert (level <= max_level);
+
+  if (level == max_level || num_frames_to_process <= 2) {
+    guint i;
+
+    for (i = 0; i < num_frames_to_process; i++) {
+      gf_group->frame_types[*frame_index] = GST_AV1_INTER_FRAME;
+      gf_group->pyramid_levels[*frame_index] = level;
+      gf_group->flags[*frame_index] = FRAME_FLAG_LEAF | FRAME_FLAG_UPDATE_REF;
+      gf_group->frame_offsets[*frame_index] = start + i;
+      (*frame_index)++;
+    }
+    return;
+  }
+
+  gf_group->frame_types[*frame_index] = GST_AV1_INTER_FRAME;
+  gf_group->pyramid_levels[*frame_index] = level;
+  gf_group->flags[*frame_index] = FRAME_FLAG_ALT_INL | FRAME_FLAG_UPDATE_REF;
+  gf_group->flags[*frame_index] |= FRAME_FLAG_NOT_SHOW;
+  gf_group->frame_offsets[*frame_index] = m;
+  (*frame_index)++;
+
+  /* The frames between start and this internal ALT */
+  _set_multi_layer (gf_group, frame_index, start, m, level + 1, max_level);
+
+  /* Repeat for this internal ALT frame */
+  gf_group->frame_types[*frame_index] = FRAME_TYPE_REPEAT;
+  gf_group->pyramid_levels[*frame_index] = -1;
+  gf_group->flags[*frame_index] = 0;
+  gf_group->frame_offsets[*frame_index] = m;
+  (*frame_index)++;
+
+  /* The frames between this internal ALT and end */
+  _set_multi_layer (gf_group, frame_index, m + 1, end, level + 1, max_level);
+}
+
+static void
+_av1_init_gf_group (GstVaAV1GFGroup * gf_group, GQueue * reorder_list)
+{
+  guint i;
+
+  gf_group->start_frame_offset = -1;
+  gf_group->group_frame_num = 0;
+  gf_group->last_pushed_num = -1;
+  gf_group->use_alt = FALSE;
+  gf_group->intra_only = FALSE;
+  gf_group->last_poped_index = -1;
+
+  for (i = 0; i < MAX_GF_GROUP_SIZE * 2; i++) {
+    gf_group->frame_types[i] = FRAME_TYPE_INVALID;
+    gf_group->pyramid_levels[i] = INVALID_PYRAMID_LEVEL;
+    gf_group->flags[i] = 0;
+    gf_group->frame_offsets[i] = -1;
+  }
+
+  /* We just use it, not own it. */
+  gf_group->reorder_list = reorder_list;
+}
+
+static void
+_av1_start_gf_group (GstVaAV1Enc * self, GstVideoCodecFrame * gf_frame)
+{
+  GstVaAV1GFGroup *gf_group = &self->gop.current_group;
+  guint group_size = self->gop.gf_group_size + 1;
+  gboolean use_alt = self->gop.backward_ref_num > 0;
+  gboolean intra_only = (self->gop.num_ref_frames == 0);
+  guint max_level = self->gop.max_level;
+  GstVaAV1EncFrame *frame = _enc_frame (gf_frame);
+  gboolean key_frame_start = (frame->frame_num == 0);
+  gint frame_index;
+  guint i;
+
+  if (use_alt) {
+    /* At least 2 levels if bi-direction ref,
+       1st for ALT, and 2nd for leaves. */
+    g_assert (max_level >= 2);
+    g_assert (intra_only == FALSE);
+  }
+
+  /* + 1 for golden frame itself. */
+  g_assert (group_size <= MAX_GF_GROUP_SIZE + 1);
+  g_assert (max_level <= HIGHEST_PYRAMID_LEVELS);
+  /* If size < 3, no backward ref needed. */
+  g_assert (group_size > 3 || use_alt == FALSE);
+
+  gf_group->start_frame_offset = frame->frame_num;
+  gf_group->group_frame_num = group_size;
+  gf_group->last_pushed_num = frame->frame_num;
+  gf_group->use_alt = use_alt;
+  gf_group->intra_only = intra_only;
+
+  gf_group->last_poped_index = -1;
+  /* An already encoded frame as the GF,
+     for example, the ALT of the previous GF group. */
+  if (frame->flags & FRAME_FLAG_ALREADY_ENCODED)
+    gf_group->last_poped_index = 0;
+
+  for (i = 0; i < MAX_GF_GROUP_SIZE * 2; i++) {
+    gf_group->frame_types[i] = FRAME_TYPE_INVALID;
+    gf_group->pyramid_levels[i] = INVALID_PYRAMID_LEVEL;
+    gf_group->flags[i] = 0;
+    gf_group->frame_offsets[i] = -1;
+  }
+
+  frame_index = 0;
+  /* GF frame is the first */
+  gf_group->frame_types[frame_index] = key_frame_start ? GST_AV1_KEY_FRAME :
+      intra_only ? GST_AV1_INTRA_ONLY_FRAME : GST_AV1_INTER_FRAME;
+  gf_group->pyramid_levels[frame_index] = 0;
+  gf_group->flags[frame_index] = FRAME_FLAG_GF;
+  gf_group->flags[frame_index] |= FRAME_FLAG_UPDATE_REF;
+  gf_group->frame_offsets[frame_index] = 0;
+  frame_index++;
+
+  /* No backward ref, in simple I/P mode */
+  if (gf_group->use_alt == FALSE) {
+    for (; frame_index < gf_group->group_frame_num; frame_index++) {
+      gf_group->frame_types[frame_index] =
+          intra_only ? GST_AV1_INTRA_ONLY_FRAME : GST_AV1_INTER_FRAME;
+      gf_group->pyramid_levels[frame_index] = 1;
+      gf_group->flags[frame_index] = FRAME_FLAG_UPDATE_REF | FRAME_FLAG_LEAF;
+      if (frame_index == gf_group->group_frame_num - 1)
+        gf_group->flags[frame_index] |= FRAME_FLAG_LAST_IN_GF;
+      gf_group->frame_offsets[frame_index] = frame_index;
+    }
+
+    gf_group->output_frame_num = gf_group->group_frame_num;
+    gf_group->highest_level = 1;
+
+    _av1_print_gf_group (self, gf_group);
+    return;
+  }
+
+  /* ALT frame */
+  gf_group->frame_types[frame_index] = GST_AV1_INTER_FRAME;
+  gf_group->pyramid_levels[frame_index] = 1;
+  gf_group->flags[frame_index] = FRAME_FLAG_ALT | FRAME_FLAG_UPDATE_REF;
+  gf_group->flags[frame_index] |= FRAME_FLAG_LAST_IN_GF;
+  gf_group->flags[frame_index] |= FRAME_FLAG_NOT_SHOW;
+  gf_group->frame_offsets[frame_index] = gf_group->group_frame_num - 1;
+  frame_index++;
+
+  /* The frames between GF and ALT */
+  _set_multi_layer (gf_group, &frame_index, 1,
+      gf_group->group_frame_num - 1, 2, max_level);
+
+  /* Repeat for ALT frame */
+  gf_group->frame_types[frame_index] = FRAME_TYPE_REPEAT;
+  gf_group->pyramid_levels[frame_index] = -1;
+  gf_group->flags[frame_index] = 0;
+  gf_group->frame_offsets[frame_index] = gf_group->group_frame_num - 1;
+  frame_index++;
+
+  gf_group->output_frame_num = frame_index;
+
+  gf_group->highest_level = 0;
+  for (i = 0; i < gf_group->output_frame_num; i++) {
+    if (gf_group->highest_level < gf_group->pyramid_levels[i])
+      gf_group->highest_level = gf_group->pyramid_levels[i];
+  }
+
+  _av1_print_gf_group (self, gf_group);
+  return;
+}
+
+static gboolean
+_av1_gf_group_push_frame (GstVaAV1GFGroup * gf_group,
+    GstVideoCodecFrame * gst_frame)
+{
+  GstVaAV1EncFrame *frame = _enc_frame (gst_frame);
+  gint pushed_frame_num = gf_group->last_pushed_num < 0 ? 0 :
+      gf_group->last_pushed_num - gf_group->start_frame_offset + 1;
+
+  /* No room for a new one. */
+  g_return_val_if_fail (pushed_frame_num < gf_group->group_frame_num, FALSE);
+  /* The frame num should just increase. */
+  g_return_val_if_fail (frame->frame_num == gf_group->last_pushed_num + 1,
+      FALSE);
+
+  if (gf_group->use_alt)
+    /* If we already begin pop, no more push again. */
+    g_return_val_if_fail (gf_group->last_poped_index <= 0, FALSE);
+
+  g_queue_push_tail (gf_group->reorder_list,
+      gst_video_codec_frame_ref (gst_frame));
+
+  gf_group->last_pushed_num = frame->frame_num;
+  return TRUE;
+}
+
+static gboolean
+_av1_gf_group_pop_frame (GstVaAV1GFGroup * gf_group,
+    GstVideoCodecFrame * ref_list[GST_AV1_NUM_REF_FRAMES],
+    GstVideoCodecFrame ** out_frame)
+{
+  GstVaAV1EncFrame *vaframe;
+  GstVideoCodecFrame *frame;
+  gint pushed_frame_num = gf_group->last_pushed_num < 0 ? 0 :
+      gf_group->last_pushed_num - gf_group->start_frame_offset + 1;
+  guint i;
+
+  g_assert (pushed_frame_num <= gf_group->group_frame_num);
+
+  if (pushed_frame_num == 0)
+    goto no_frame;
+
+  if (!gf_group->use_alt) {
+    g_assert (gf_group->last_poped_index < pushed_frame_num);
+
+    if (gf_group->last_poped_index + 1 < pushed_frame_num) {
+      gf_group->last_poped_index++;
+      goto find_frame;
+    }
+
+    goto no_frame;
+  }
+
+  /* The first frame of a GF group has no backward ref, pop immediately. */
+  if (gf_group->last_poped_index < 0) {
+    gf_group->last_poped_index++;
+    goto find_frame;
+  }
+
+  /* The ALT frame has not come. */
+  if (pushed_frame_num < gf_group->group_frame_num)
+    goto no_frame;
+
+  gf_group->last_poped_index++;
+  g_assert (gf_group->last_poped_index < gf_group->output_frame_num);
+
+find_frame:
+  vaframe = NULL;
+  frame = NULL;
+
+  /* If repeating some frame, it should be in reference list,
+     or it should be in reorder list. */
+  if (gf_group->frame_types[gf_group->last_poped_index] == FRAME_TYPE_REPEAT) {
+    for (i = 0; i < GST_AV1_NUM_REF_FRAMES; i++) {
+      GstVaAV1EncFrame *vaf;
+
+      if (ref_list[i] == NULL)
+        continue;
+
+      vaf = _enc_frame (ref_list[i]);
+      if (vaf->frame_num == gf_group->start_frame_offset +
+          gf_group->frame_offsets[gf_group->last_poped_index]) {
+        vaframe = vaf;
+        frame = ref_list[i];
+        break;
+      }
+    }
+
+    g_return_val_if_fail (vaframe, FALSE);
+
+    g_assert (vaframe->flags & FRAME_FLAG_ALREADY_ENCODED);
+    vaframe->type |= FRAME_TYPE_REPEAT;
+  } else {
+    for (i = 0; i < g_queue_get_length (gf_group->reorder_list); i++) {
+      GstVaAV1EncFrame *vaf;
+      GstVideoCodecFrame *f;
+
+      f = g_queue_peek_nth (gf_group->reorder_list, i);
+      vaf = _enc_frame (f);
+      if (vaf->frame_num == gf_group->start_frame_offset +
+          gf_group->frame_offsets[gf_group->last_poped_index]) {
+        vaframe = vaf;
+        frame = f;
+        break;
+      }
+    }
+    /* We push the frame num in increment order, so it must exist. */
+    g_return_val_if_fail (vaframe, FALSE);
+    /* Clear that frame from reorder list. */
+    g_queue_pop_nth (gf_group->reorder_list, i);
+
+    vaframe->type = gf_group->frame_types[gf_group->last_poped_index];
+    vaframe->pyramid_level =
+        gf_group->pyramid_levels[gf_group->last_poped_index];
+    vaframe->flags = gf_group->flags[gf_group->last_poped_index];
+
+    /* unref frame popped from reorder queue */
+    gst_video_codec_frame_unref (frame);
+  }
+
+  *out_frame = frame;
+  return TRUE;
+
+no_frame:
+  *out_frame = NULL;
+  return TRUE;
+}
+
+/* Force to finish current group, no matter how many frames we have. */
+static void
+_av1_finish_current_gf_group (GstVaAV1Enc * self, GstVaAV1GFGroup * gf_group)
+{
+  gint frame_index;
+  gint pushed_frame_num = gf_group->last_pushed_num < 0 ? 0 :
+      gf_group->last_pushed_num - gf_group->start_frame_offset + 1;
+  guint i;
+
+  g_assert (pushed_frame_num <= gf_group->group_frame_num);
+
+  /* Alt comes and already finished. */
+  if (gf_group->use_alt && gf_group->last_poped_index > 0)
+    return;
+
+  /* Already pushed all frames. */
+  if (pushed_frame_num == gf_group->group_frame_num)
+    return;
+
+  /* Not enough frames, no need to use backward ref. */
+  if (gf_group->use_alt && pushed_frame_num <= 3)
+    gf_group->use_alt = FALSE;
+
+  if (gf_group->use_alt == FALSE) {
+    g_assert (gf_group->last_poped_index < pushed_frame_num);
+
+    gf_group->group_frame_num = pushed_frame_num;
+
+    for (frame_index = 1; frame_index < gf_group->group_frame_num;
+        frame_index++) {
+      gf_group->frame_types[frame_index] =
+          gf_group->intra_only ? GST_AV1_INTRA_ONLY_FRAME : GST_AV1_INTER_FRAME;
+      gf_group->pyramid_levels[frame_index] = 1;
+      gf_group->flags[frame_index] = FRAME_FLAG_UPDATE_REF | FRAME_FLAG_LEAF;
+      gf_group->frame_offsets[frame_index] = frame_index;
+      if (frame_index == gf_group->group_frame_num - 1) {
+        gf_group->flags[frame_index] |= FRAME_FLAG_LAST_IN_GF;
+      }
+
+    }
+
+    gf_group->output_frame_num = gf_group->group_frame_num;
+    gf_group->highest_level = 1;
+
+    GST_LOG_OBJECT (self, "Finish current golden group.");
+    _av1_print_gf_group (self, gf_group);
+    return;
+  }
+
+  g_assert (gf_group->highest_level >= 2);
+
+  gf_group->group_frame_num = pushed_frame_num;
+
+  frame_index = 1;
+  /* ALT frame */
+  gf_group->frame_types[frame_index] = GST_AV1_INTER_FRAME;
+  gf_group->pyramid_levels[frame_index] = 1;
+  gf_group->flags[frame_index] = FRAME_FLAG_ALT | FRAME_FLAG_UPDATE_REF;
+  gf_group->flags[frame_index] |= FRAME_FLAG_LAST_IN_GF;
+  gf_group->flags[frame_index] |= FRAME_FLAG_NOT_SHOW;
+  gf_group->frame_offsets[frame_index] = gf_group->group_frame_num - 1;
+  frame_index++;
+
+  /* The frames between GF and ALT */
+  _set_multi_layer (gf_group, &frame_index, 1, gf_group->group_frame_num - 1,
+      2, gf_group->highest_level);
+
+  /* Repeat of ALT frame */
+  gf_group->frame_types[frame_index] = FRAME_TYPE_REPEAT;
+  gf_group->pyramid_levels[frame_index] = -1;
+  gf_group->flags[frame_index] = 0;
+  gf_group->frame_offsets[frame_index] = gf_group->group_frame_num - 1;
+  frame_index++;
+
+  gf_group->output_frame_num = frame_index;
+
+  gf_group->highest_level = 0;
+  for (i = 0; i < gf_group->output_frame_num; i++) {
+    if (gf_group->highest_level < gf_group->pyramid_levels[i])
+      gf_group->highest_level = gf_group->pyramid_levels[i];
+  }
+
+  GST_LOG_OBJECT (self, "Finish current golden group.");
+  _av1_print_gf_group (self, gf_group);
+  return;
+}
+
+static inline gboolean
+_av1_gf_group_is_empty (GstVaAV1GFGroup * gf_group)
+{
+  gint pushed_frame_num = gf_group->last_pushed_num < 0 ? 0 :
+      gf_group->last_pushed_num - gf_group->start_frame_offset + 1;
+
+  if (pushed_frame_num <= 0)
+    return TRUE;
+
+  if (gf_group->use_alt == FALSE) {
+    g_assert (gf_group->last_poped_index + 1 <= pushed_frame_num);
+    if (gf_group->last_poped_index + 1 == pushed_frame_num)
+      return TRUE;
+
+    return FALSE;
+  }
+
+  g_assert (gf_group->last_poped_index < gf_group->output_frame_num);
+  if (gf_group->last_poped_index == gf_group->output_frame_num - 1)
+    return TRUE;
+
+  return FALSE;
+}
+
+static inline gboolean
+_av1_gf_group_is_finished (GstVaAV1GFGroup * gf_group)
+{
+  g_assert (gf_group->last_poped_index < gf_group->output_frame_num);
+  if (gf_group->last_poped_index == gf_group->output_frame_num - 1)
+    return TRUE;
+
+  return FALSE;
+}
+
+static GstVideoCodecFrame *
+_av1_find_next_golden_frame (GstVaAV1Enc * self)
+{
+  guint i;
+  GstVideoCodecFrame *f, *f_max_frame_num;
+  GstVaAV1EncFrame *vaf;
+  gint max_frame_num;
+
+  g_assert (_av1_gf_group_is_empty (&self->gop.current_group));
+
+  f = NULL;
+  f_max_frame_num = NULL;
+  max_frame_num = -1;
+  for (i = 0; i < GST_AV1_NUM_REF_FRAMES; i++) {
+    if (self->gop.ref_list[i] == NULL)
+      continue;
+
+    vaf = _enc_frame (self->gop.ref_list[i]);
+    if (vaf->flags & FRAME_FLAG_LAST_IN_GF) {
+      /* Should not have 2 of group end frame at the same time. */
+      g_assert (f == NULL);
+      f = self->gop.ref_list[i];
+    }
+
+    if (vaf->frame_num > max_frame_num) {
+      max_frame_num = vaf->frame_num;
+      f_max_frame_num = self->gop.ref_list[i];
+    }
+
+    /* clear all flags about last GF group. */
+    vaf->flags &= ~(FRAME_FLAG_LAST_IN_GF | FRAME_FLAG_ALT_INL |
+        FRAME_FLAG_ALT | FRAME_FLAG_GF);
+  }
+
+  if (f == NULL)
+    f = f_max_frame_num;
+
+  vaf = _enc_frame (f);
+  vaf->flags |= FRAME_FLAG_GF;
+
+  GST_LOG_OBJECT (self, "Find the next golden frame num %d", vaf->frame_num);
+
+  return f;
+}
+
+static gboolean
+gst_va_av1_enc_reorder_frame (GstVaBaseEnc * base, GstVideoCodecFrame * frame,
+    gboolean bump_all, GstVideoCodecFrame ** out_frame)
+{
+  GstVaAV1Enc *self = GST_VA_AV1_ENC (base);
+  GstVaAV1EncFrame *va_frame;
+
+  *out_frame = NULL;
+
+  if (bump_all) {
+    g_return_val_if_fail (frame == NULL, FALSE);
+
+    _av1_finish_current_gf_group (self, &self->gop.current_group);
+
+    if (!_av1_gf_group_is_finished (&self->gop.current_group)) {
+      g_assert (!_av1_gf_group_is_empty (&self->gop.current_group));
+      goto pop;
+    }
+
+    /* no more frames, the cached key frame is the last frame */
+    if (self->gop.last_keyframe) {
+      g_assert (_av1_gf_group_is_empty (&self->gop.current_group));
+
+      *out_frame = self->gop.last_keyframe;
+      self->gop.last_keyframe = NULL;
+    }
+
+    goto finish;
+  }
+
+  /* Pop only. We can pop some frame if:
+     1. The current GF group is not finished.
+     2. Encountered a key frame last time and force to finish
+     the current GF group. */
+  if (frame == NULL) {
+    if (!_av1_gf_group_is_empty (&self->gop.current_group))
+      goto pop;
+
+    if (self->gop.last_keyframe) {
+      GstVideoCodecFrame *f = self->gop.last_keyframe;
+      self->gop.last_keyframe = NULL;
+
+      _av1_start_gf_group (self, f);
+      goto pop;
+    }
+
+    goto finish;
+  }
+
+  if (self->gop.frame_num_since_kf == self->gop.keyframe_interval)
+    self->gop.frame_num_since_kf = 0;
+
+  if (GST_VIDEO_CODEC_FRAME_IS_FORCE_KEYFRAME (frame))
+    self->gop.frame_num_since_kf = 0;
+
+  va_frame = _enc_frame (frame);
+  va_frame->frame_num = self->gop.frame_num_since_kf;
+  self->gop.frame_num_since_kf++;
+
+  GST_LOG_OBJECT (self, "push frame: system_frame_number %d, frame_num: %d",
+      frame->system_frame_number, va_frame->frame_num);
+
+  /* A new key frame force to finish the current GF group. */
+  if (va_frame->frame_num == 0) {
+    _av1_finish_current_gf_group (self, &self->gop.current_group);
+
+    g_queue_push_tail (&base->reorder_list, gst_video_codec_frame_ref (frame));
+
+    if (_av1_gf_group_is_finished (&self->gop.current_group)) {
+      g_assert (_av1_gf_group_is_empty (&self->gop.current_group));
+
+      /* Already poped all of the last group,
+         so begin a new group with this keyframe. */
+      _av1_start_gf_group (self, frame);
+    } else {
+      g_assert (!_av1_gf_group_is_empty (&self->gop.current_group));
+
+      /* The reorder() should exhaust all available frames in the
+         reorder list before push a frame again, so the last key
+         frame should already be popped. */
+      g_return_val_if_fail (self->gop.last_keyframe == NULL, FALSE);
+      self->gop.last_keyframe = frame;
+    }
+
+    goto pop;
+  }
+
+  if (_av1_gf_group_is_finished (&self->gop.current_group)) {
+    GstVideoCodecFrame *gf_frame;
+
+    g_assert (_av1_gf_group_is_empty (&self->gop.current_group));
+
+    gf_frame = _av1_find_next_golden_frame (self);
+    /* At least, there are some frames inside the reference list. */
+    g_assert (gf_frame);
+
+    _av1_start_gf_group (self, gf_frame);
+  }
+
+  if (!_av1_gf_group_push_frame (&self->gop.current_group, frame)) {
+    GST_WARNING_OBJECT (base, "Failed to push the frame,"
+        " system_frame_number %d.", frame->system_frame_number);
+    goto error;
+  }
+
+pop:
+  frame = NULL;
+
+  if (!_av1_gf_group_pop_frame (&self->gop.current_group, self->gop.ref_list,
+          out_frame))
+    goto error;
+
+finish:
+  if (*out_frame) {
+    va_frame = _enc_frame (*out_frame);
+    GST_LOG_OBJECT (self, "pop frame: system_frame_number %d,"
+        " frame_num: %d, frame_type %s", (*out_frame)->system_frame_number,
+        va_frame->frame_num, _av1_get_frame_type_name (va_frame->type));
+  }
+
+  return TRUE;
+
+error:
+  if (frame) {
+    GST_ERROR_OBJECT (base, "Failed to reorder the frame,"
+        " system_frame_number %d.", frame->system_frame_number);
+  } else {
+    GST_ERROR_OBJECT (base, "error when poping frame.");
+  }
+  return FALSE;
+}
+
+static gint
+_av1_sort_by_frame_num (gconstpointer a, gconstpointer b, gpointer user_data)
+{
+  GstVaAV1EncFrame *frame1 = _enc_frame (((GstVaAV1Ref *) a)->frame);
+  GstVaAV1EncFrame *frame2 = _enc_frame (((GstVaAV1Ref *) b)->frame);
+
+  g_assert (frame1->frame_num != frame2->frame_num);
+
+  return frame1->frame_num - frame2->frame_num;
+}
+
+static gboolean
+_av1_assign_ref_index (GstVaAV1Enc * self, GstVideoCodecFrame * frame)
+{
+  GstVaAV1Ref all_refs[GST_AV1_NUM_REF_FRAMES];
+  guint ref_num;
+  gint forward_num, backward_num;
+  gint forward_ref_num, backward_ref_num;;
+  GstVaAV1EncFrame *va_frame = _enc_frame (frame);
+  gint i, num;
+
+  memset (va_frame->ref_frame_idx, -1, sizeof (va_frame->ref_frame_idx));
+
+  if (va_frame->type & FRAME_TYPE_REPEAT) {
+    va_frame->repeat_index = -1;
+
+    for (i = 0; i < GST_AV1_NUM_REF_FRAMES; i++) {
+      if (self->gop.ref_list[i] == frame) {
+        va_frame->repeat_index = i;
+        break;
+      }
+    }
+
+    g_return_val_if_fail (va_frame->repeat_index >= 0, FALSE);
+    goto finish;
+  }
+
+  /* key frame has no ref */
+  if (va_frame->frame_num == 0) {
+    g_assert (va_frame->type == GST_AV1_KEY_FRAME);
+    va_frame->bidir_ref = FALSE;
+    goto finish;
+  }
+
+  /* intra frame has no ref */
+  if (va_frame->type == GST_AV1_INTRA_ONLY_FRAME) {
+    va_frame->bidir_ref = FALSE;
+    goto finish;
+  }
+
+  ref_num = forward_num = backward_num = 0;
+  for (i = 0; i < GST_AV1_NUM_REF_FRAMES; i++) {
+    GstVaAV1EncFrame *va_f;
+
+    if (self->gop.ref_list[i] == NULL)
+      continue;
+
+    all_refs[ref_num].frame = self->gop.ref_list[i];
+    all_refs[ref_num].index_in_dpb = i;
+    ref_num++;
+
+    va_f = _enc_frame (self->gop.ref_list[i]);
+    g_assert (va_f->frame_num != va_frame->frame_num);
+    if (va_f->frame_num < va_frame->frame_num) {
+      forward_num++;
+    } else {
+      backward_num++;
+      g_assert (va_f->flags & FRAME_FLAG_ALT ||
+          va_f->flags & FRAME_FLAG_ALT_INL);
+    }
+
+    if (va_f->flags & FRAME_FLAG_GF)
+      va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME] = i;
+  }
+
+  if (va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME] == -1) {
+    GST_WARNING_OBJECT (self, "failed to find the golden frame.");
+    return FALSE;
+  }
+
+  g_qsort_with_data (all_refs, ref_num, sizeof (GstVaAV1Ref),
+      _av1_sort_by_frame_num, NULL);
+
+  /* Setting the forward refs. GOLDEN is always set first.
+     LAST is set to the nearest frame in the past if forward_ref_num
+     is enough. LAST2 and LAST3 are set to next nearest frames in the
+     past if forward_ref_num is enough.
+     If forward_ref_num is not enough, they are just set to GOLDEN. */
+  va_frame->bidir_ref = FALSE;
+
+  num = forward_num - 1;
+  if (backward_num > 0) {
+    forward_ref_num = self->gop.forward_ref_num - 1 /* already assign gf */ ;
+  } else {
+    /* if forward only, should use forward_only_ref_num */
+    forward_ref_num =
+        self->gop.forward_only_ref_num - 1 /* already assign gf */ ;
+  }
+
+  if (num >= 0 && all_refs[num].index_in_dpb ==
+      va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME])
+    num--;
+
+  if (num >= 0 && forward_ref_num > 0) {
+    va_frame->ref_frame_idx[GST_AV1_REF_LAST_FRAME] =
+        all_refs[num].index_in_dpb;
+  } else {
+    va_frame->ref_frame_idx[GST_AV1_REF_LAST_FRAME] =
+        va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME];
+  }
+
+  num--;
+  forward_ref_num--;
+  if (num >= 0 && all_refs[num].index_in_dpb ==
+      va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME])
+    num--;
+
+  if (num >= 0 && forward_ref_num > 0) {
+    va_frame->ref_frame_idx[GST_AV1_REF_LAST2_FRAME] =
+        all_refs[num].index_in_dpb;
+  } else {
+    va_frame->ref_frame_idx[GST_AV1_REF_LAST2_FRAME] =
+        va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME];
+  }
+
+  num--;
+  forward_ref_num--;
+  if (num >= 0 && all_refs[num].index_in_dpb ==
+      va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME])
+    num--;
+
+  if (num >= 0 && forward_ref_num > 0) {
+    va_frame->ref_frame_idx[GST_AV1_REF_LAST3_FRAME] =
+        all_refs[num].index_in_dpb;
+  } else {
+    va_frame->ref_frame_idx[GST_AV1_REF_LAST3_FRAME] =
+        va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME];
+  }
+
+  /* Setting the backward refs */
+  if (backward_num > 0 && self->gop.backward_ref_num > 0) {
+    backward_ref_num = self->gop.backward_ref_num;
+
+    g_assert (_enc_frame (all_refs[ref_num - 1].frame)->flags & FRAME_FLAG_ALT);
+
+    va_frame->bidir_ref = TRUE;
+
+    if (backward_num >= 3 && backward_ref_num >= 3) {
+      /* Set the BWDREF to the nearest future frame, ALTREF2 to the next
+         nearest future frame and ALTREF to the furthest future frame
+         in the GF group. */
+      va_frame->ref_frame_idx[GST_AV1_REF_ALTREF_FRAME] =
+          all_refs[ref_num - 1].index_in_dpb;
+      va_frame->ref_frame_idx[GST_AV1_REF_ALTREF2_FRAME] =
+          all_refs[forward_num + 1].index_in_dpb;
+      va_frame->ref_frame_idx[GST_AV1_REF_BWDREF_FRAME] =
+          all_refs[forward_num].index_in_dpb;
+    } else if (backward_num == 2 && backward_ref_num >= 2) {
+      /* Set the BWDREF to the nearest future frame and ALTREF to the furthest
+         future frame in the GF group. ALTREF2 is just set to GOLDEN. */
+      va_frame->ref_frame_idx[GST_AV1_REF_ALTREF_FRAME] =
+          all_refs[ref_num - 1].index_in_dpb;
+      va_frame->ref_frame_idx[GST_AV1_REF_BWDREF_FRAME] =
+          all_refs[forward_num].index_in_dpb;
+
+      va_frame->ref_frame_idx[GST_AV1_REF_ALTREF2_FRAME] =
+          va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME];
+    } else {
+      /* Set the ALTREF to the nearest future frame. ALTREF2 and BWDREF
+         are just set to GOLDEN. */
+      va_frame->ref_frame_idx[GST_AV1_REF_ALTREF_FRAME] =
+          all_refs[forward_num].index_in_dpb;
+
+      va_frame->ref_frame_idx[GST_AV1_REF_ALTREF2_FRAME] =
+          va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME];
+      va_frame->ref_frame_idx[GST_AV1_REF_BWDREF_FRAME] =
+          va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME];
+    }
+  } else {
+    /* If no backward refs, BWDREF, ALTREF and ALTREF2 are set to GOLDEN. */
+    va_frame->ref_frame_idx[GST_AV1_REF_ALTREF_FRAME] =
+        va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME];
+    va_frame->ref_frame_idx[GST_AV1_REF_ALTREF2_FRAME] =
+        va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME];
+    va_frame->ref_frame_idx[GST_AV1_REF_BWDREF_FRAME] =
+        va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME];
+  }
+
+finish:
+  _av1_print_frame_reference (self, frame);
+  return TRUE;
+}
+
+static void
+_av1_find_ref_to_update (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
+{
+  GstVaAV1Enc *self = GST_VA_AV1_ENC (base);
+  GstVaAV1EncFrame *va_frame = _enc_frame (frame);
+  gint slot;
+  gint lowest_slot;
+  gint lowest_frame_num = MAX_KEY_FRAME_INTERVAL + 1;
+  gint i;
+
+  if (va_frame->type & FRAME_TYPE_REPEAT)
+    return;
+
+  if ((va_frame->flags & FRAME_FLAG_UPDATE_REF) == 0) {
+    /* Key frame should always clean the reference list. */
+    g_assert (va_frame->type != GST_AV1_KEY_FRAME);
+    return;
+  }
+
+  va_frame->update_index = -1;
+
+  /* key frame will clear the whole ref list, just use the 0 */
+  if (va_frame->type == GST_AV1_KEY_FRAME) {
+    va_frame->update_index = 0;
+    return;
+  }
+
+  /* 1. Find an empty slot in the reference list.
+     2. If the list is full, kick out the non GF frame with lowest
+     frame num. GF frame should not be kicked out because we always
+     set GOLDEN to GF frame.
+     3. If still not find, we drop ourself. */
+  lowest_frame_num = MAX_KEY_FRAME_INTERVAL + 1;
+  slot = lowest_slot = -1;
+  for (i = 0; i < GST_AV1_NUM_REF_FRAMES; i++) {
+    GstVaAV1EncFrame *va_f;
+
+    if (self->gop.ref_list[i] == NULL) {
+      slot = i;
+      break;
+    }
+
+    va_f = _enc_frame (self->gop.ref_list[i]);
+    if (va_f->flags & FRAME_FLAG_GF)
+      continue;
+
+    if (va_f->frame_num > va_frame->frame_num)
+      continue;
+
+    if (va_f->frame_num < lowest_frame_num) {
+      lowest_frame_num = va_f->frame_num;
+      lowest_slot = i;
+    }
+  }
+
+  if (slot < 0 && lowest_slot >= 0)
+    slot = lowest_slot;
+
+  if (slot >= 0)
+    va_frame->update_index = slot;
+}
+
+static void
+_av1_update_ref_list (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
+{
+  GstVaAV1Enc *self = GST_VA_AV1_ENC (base);
+  GstVaAV1EncFrame *va_frame = _enc_frame (frame);
+  GstVideoCodecFrame *del_f;
+  gint i;
+
+  if (va_frame->type & FRAME_TYPE_REPEAT)
+    return;
+
+  /* key frame, clear the whole ref list. */
+  if (va_frame->type == GST_AV1_KEY_FRAME) {
+    g_assert (va_frame->update_index == 0);
+    g_assert (va_frame->flags & FRAME_FLAG_UPDATE_REF);
+
+    for (i = 0; i < GST_AV1_NUM_REF_FRAMES; i++) {
+      if (self->gop.ref_list[i] == NULL)
+        continue;
+
+      g_queue_remove (&base->ref_list, self->gop.ref_list[i]);
+      gst_video_codec_frame_unref (self->gop.ref_list[i]);
+      self->gop.ref_list[i] = NULL;
+    }
+
+    g_assert (g_queue_is_empty (&base->ref_list));
+  }
+
+  /* We drop ourself. */
+  if (va_frame->update_index < 0) {
+    GST_DEBUG_OBJECT (self, "Drop the non ref frame %d,"
+        " reference list unchanged", va_frame->frame_num);
+    return;
+  }
+
+  del_f = self->gop.ref_list[va_frame->update_index];
+
+  g_queue_push_tail (&base->ref_list, gst_video_codec_frame_ref (frame));
+  self->gop.ref_list[va_frame->update_index] = frame;
+
+  _av1_print_ref_list_update (self, va_frame->update_index, del_f, frame);
+
+  if (del_f) {
+    g_queue_remove (&base->ref_list, del_f);
+    gst_video_codec_frame_unref (del_f);
+  }
+}
+
+static void
+gst_va_av1_enc_reset_state (GstVaBaseEnc * base)
+{
+  GstVaAV1Enc *self = GST_VA_AV1_ENC (base);
+
+  GST_VA_BASE_ENC_CLASS (parent_class)->reset_state (base);
+
+  GST_OBJECT_LOCK (self);
+  self->rc.rc_ctrl_mode = self->prop.rc_ctrl;
+  self->rc.target_usage = self->prop.target_usage;
+  self->rc.base_qindex = self->prop.qp;
+  self->rc.min_qindex = self->prop.min_qp;
+  self->rc.max_qindex = self->prop.max_qp;
+  self->rc.target_percentage = self->prop.target_percentage;
+  self->rc.cpb_size = self->prop.cpb_size;
+  self->rc.mbbrc = self->prop.mbbrc;
+
+  self->gop.keyframe_interval = self->prop.keyframe_interval;
+  self->gop.gf_group_size = self->prop.gf_group_size;
+  self->gop.num_ref_frames = self->prop.num_ref_frames;
+  self->gop.max_level = self->prop.max_hierarchical_level;
+  self->partition.use_128x128_superblock = self->prop.use_128x128_superblock;
+  self->partition.num_tile_cols = self->prop.num_tile_cols;
+  self->partition.num_tile_rows = self->prop.num_tile_rows;
+  self->partition.tile_groups = self->prop.tile_groups;
+  GST_OBJECT_UNLOCK (self);
+
+  self->packed_headers = 0;
+
+  self->mi_rows = 0;
+  self->mi_cols = 0;
+  self->depth = 0;
+  self->chrome = 0;
+  self->level_idx = -1;
+  self->level_str = NULL;
+  self->tier = 0;
+  self->cr = 0;
+  self->last_pts = GST_CLOCK_TIME_NONE;
+  self->last_dts = GST_CLOCK_TIME_NONE;
+
+  self->features.enable_filter_intra = FALSE;
+  self->features.enable_intra_edge_filter = FALSE;
+  self->features.enable_interintra_compound = FALSE;
+  self->features.enable_masked_compound = FALSE;
+  self->features.enable_warped_motion = FALSE;
+  self->features.enable_palette_mode = FALSE;
+  self->features.enable_dual_filter = FALSE;
+  self->features.enable_jnt_comp = FALSE;
+  self->features.enable_ref_frame_mvs = FALSE;
+  self->features.enable_superres = FALSE;
+  self->features.enable_restoration = FALSE;
+  self->features.allow_intrabc = FALSE;
+  self->features.enable_segmentation = FALSE;
+  self->features.enable_cdef = FALSE;
+  self->features.cdef_bits = 0;
+  self->features.interpolation_filter_support = 0;
+  self->features.interpolation_type = 0;
+  self->features.obu_size_bytes = 0;
+  self->features.tx_mode_support = 0;
+  self->features.cdef_channel_strength = FALSE;
+
+  _av1_init_gf_group (&self->gop.current_group, &base->reorder_list);
+  self->gop.last_keyframe = NULL;
+  memset (self->gop.ref_list, 0, sizeof (self->gop.ref_list));
+  self->gop.frame_num_since_kf = 0;
+  self->gop.forward_only_ref_num = 0;
+  self->gop.forward_ref_num = 0;
+  self->gop.backward_ref_num = 0;
+  self->gop.enable_order_hint = FALSE;
+
+  self->partition.sb_rows = 0;
+  self->partition.sb_cols = 0;
+  self->partition.tile_size_bytes_minus_1 = 0;
+  self->partition.tile_width_sb = 0;
+  self->partition.tile_height_sb = 0;
+  self->partition.uniform = TRUE;
+  self->partition.max_tile_num = 0;
+  self->partition.tile_cols_log2 = 0;
+  self->partition.tile_rows_log2 = 0;
+
+  self->rc.max_bitrate = 0;
+  self->rc.target_bitrate = 0;
+  self->rc.max_bitrate_bits = 0;
+  self->rc.cpb_length_bits = 0;
+
+  memset (&self->sequence_hdr, 0, sizeof (self->sequence_hdr));
+}
+
+static gboolean
+gst_va_av1_enc_flush (GstVideoEncoder * venc)
+{
+  GstVaAV1Enc *self = GST_VA_AV1_ENC (venc);
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+
+  /* begin from an key frame after flush. */
+  self->gop.frame_num_since_kf = 0;
+
+  /* Parent's flush will release all frames for us. */
+  _av1_init_gf_group (&self->gop.current_group, &base->reorder_list);
+  self->gop.last_keyframe = NULL;
+  memset (self->gop.ref_list, 0, sizeof (self->gop.ref_list));
+
+  return GST_VIDEO_ENCODER_CLASS (parent_class)->flush (venc);
+}
+
+static guint
+_av1_get_rtformat (GstVaAV1Enc * self, GstVideoFormat format,
+    guint * depth, guint * chrome)
+{
+  guint chroma;
+
+  chroma = gst_va_chroma_from_video_format (format);
+
+  switch (chroma) {
+    case VA_RT_FORMAT_YUV400:
+      *depth = 8;
+      *chrome = 0;
+      break;
+    case VA_RT_FORMAT_YUV420:
+      *depth = 8;
+      *chrome = 1;
+      break;
+    case VA_RT_FORMAT_YUV420_10:
+      *depth = 10;
+      *chrome = 1;
+      break;
+    case VA_RT_FORMAT_YUV444:
+      *depth = 8;
+      *chrome = 3;
+      break;
+    case VA_RT_FORMAT_YUV422_10:
+      *depth = 10;
+      *chrome = 2;
+      break;
+    default:
+      chroma = 0;
+      GST_ERROR_OBJECT (self, "Unsupported chroma for video format: %s",
+          gst_video_format_to_string (format));
+      break;
+  }
+
+  return chroma;
+}
+
+#define update_property(type, obj, old_val, new_val, prop_id)           \
+  gst_va_base_enc_update_property_##type (obj, old_val, new_val, properties[prop_id])
+#define update_property_uint(obj, old_val, new_val, prop_id)    \
+  update_property (uint, obj, old_val, new_val, prop_id)
+#define update_property_bool(obj, old_val, new_val, prop_id)    \
+  update_property (bool, obj, old_val, new_val, prop_id)
+
+static gboolean
+_av1_decide_profile (GstVaAV1Enc * self)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  gboolean ret = FALSE;
+  GstCaps *allowed_caps = NULL;
+  guint num_structures, i;
+  GstStructure *structure;
+  const GValue *v_profile;
+  GArray *candidates = NULL;
+  VAProfile va_profile;
+
+  candidates = g_array_new (TRUE, TRUE, sizeof (VAProfile));
+
+  /* First, check whether the downstream requires a specified profile. */
+  allowed_caps = gst_pad_get_allowed_caps (GST_VIDEO_ENCODER_SRC_PAD (base));
+  if (!allowed_caps)
+    allowed_caps = gst_pad_query_caps (GST_VIDEO_ENCODER_SRC_PAD (base), NULL);
+
+  if (allowed_caps && !gst_caps_is_empty (allowed_caps)) {
+    num_structures = gst_caps_get_size (allowed_caps);
+    for (i = 0; i < num_structures; i++) {
+      structure = gst_caps_get_structure (allowed_caps, i);
+      v_profile = gst_structure_get_value (structure, "profile");
+      if (!v_profile)
+        continue;
+
+      if (G_VALUE_HOLDS_STRING (v_profile)) {
+        va_profile =
+            gst_va_profile_from_name (AV1, g_value_get_string (v_profile));
+        g_array_append_val (candidates, va_profile);
+      } else if (GST_VALUE_HOLDS_LIST (v_profile)) {
+        guint j;
+
+        for (j = 0; j < gst_value_list_get_size (v_profile); j++) {
+          const GValue *p = gst_value_list_get_value (v_profile, j);
+          if (!p)
+            continue;
+
+          va_profile = gst_va_profile_from_name (AV1, g_value_get_string (p));
+          g_array_append_val (candidates, va_profile);
+        }
+      }
+    }
+  }
+
+  if (candidates->len == 0) {
+    GST_ERROR_OBJECT (self, "No available profile in caps");
+    ret = FALSE;
+    goto out;
+  }
+
+  /* 6.4.1:
+     seq_profile  Bit depth  Monochrome support  Chroma subsampling
+     0            8 or 10    Yes                 YUV 4:2:0
+     1            8 or 10    No                  YUV 4:4:4
+     2            8 or 10    Yes                 YUV 4:2:2
+     2            12         Yes                 YUV 4:2:0,YUV 4:2:2,YUV 4:4:4
+   */
+  /* We only support 0 and 1 profile now */
+  if (self->chrome == 0 || self->chrome == 1) {
+    va_profile = VAProfileAV1Profile0;
+  } else if (self->chrome == 3) {
+    va_profile = VAProfileAV1Profile1;
+  } else {
+    va_profile = VAProfileNone;
+    GST_ERROR_OBJECT (self, "No suitable profile for chroma value %d",
+        self->chrome);
+    ret = FALSE;
+    goto out;
+  }
+
+  ret = FALSE;
+  for (i = 0; i < candidates->len; i++) {
+    VAProfile p;
+
+    p = g_array_index (candidates, VAProfile, i);
+    if (!gst_va_encoder_has_profile (base->encoder, p))
+      continue;
+
+    if ((base->rt_format & gst_va_encoder_get_rtformat (base->encoder,
+                p, GST_VA_BASE_ENC_ENTRYPOINT (base))) == 0)
+      continue;
+
+    if (p == va_profile) {
+      base->profile = p;
+      ret = TRUE;
+      goto out;
+    }
+  }
+
+out:
+  return ret;
+}
+
+static gboolean
+_av1_init_packed_headers (GstVaAV1Enc * self)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint32 packed_headers;
+  guint32 desired_packed_headers = VA_ENC_PACKED_HEADER_SEQUENCE        /* Sequence Header */
+      | VA_ENC_PACKED_HEADER_PICTURE    /* Frame Header */
+      | VA_ENC_PACKED_HEADER_RAW_DATA;  /* Meta, TU, etc. */
+
+  self->packed_headers = 0;
+
+  if (!gst_va_encoder_get_packed_headers (base->encoder, base->profile,
+          GST_VA_BASE_ENC_ENTRYPOINT (base), &packed_headers))
+    return FALSE;
+
+  if (desired_packed_headers & ~packed_headers) {
+    GST_INFO_OBJECT (self, "Driver does not support some wanted packed headers "
+        "(wanted %#x, found %#x)", desired_packed_headers, packed_headers);
+  }
+
+  self->packed_headers = desired_packed_headers & packed_headers;
+
+  return TRUE;
+}
+
+static gboolean
+_av1_generate_gop_structure (GstVaAV1Enc * self)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint32 list0, list1, listp_0;
+
+  /* If not set, generate a key frame every 2 second */
+  if (self->gop.keyframe_interval == 0) {
+    self->gop.keyframe_interval =
+        (2 * GST_VIDEO_INFO_FPS_N (&base->input_state->info)
+        + GST_VIDEO_INFO_FPS_D (&base->input_state->info) - 1) /
+        GST_VIDEO_INFO_FPS_D (&base->input_state->info);
+  }
+
+  if (self->gop.keyframe_interval > MAX_KEY_FRAME_INTERVAL)
+    self->gop.keyframe_interval = MAX_KEY_FRAME_INTERVAL;
+
+  if (self->gop.gf_group_size >= self->gop.keyframe_interval)
+    self->gop.gf_group_size = self->gop.keyframe_interval - 1;
+
+  if (!gst_va_encoder_get_max_num_reference (base->encoder, base->profile,
+          GST_VA_BASE_ENC_ENTRYPOINT (base), &listp_0, &list0, &list1)) {
+    GST_INFO_OBJECT (self, "Failed to get the max num reference");
+    list0 = 1;
+    list1 = 0;
+    listp_0 = list0;
+  }
+
+  /* At most, 4 forward refs */
+  if (list0 > 4)
+    list0 = 4;
+  if (listp_0 > 4)
+    listp_0 = 4;
+
+  /* At most, 3 backward refs */
+  if (list1 > 3)
+    list1 = 3;
+
+  /* No more backward refs than forward refs. */
+  if (list1 > list0)
+    list1 = list0;
+
+  /* Do not let P frames have more refs than B frames. */
+  if (listp_0 > list0 + list1)
+    listp_0 = list0 + list1;
+  /* B frame should not have more forward refs than P frame */
+  if (listp_0 != 0 && list0 > listp_0)
+    list0 = listp_0;
+
+  /* Only I/P mode is needed */
+  if (self->gop.max_level < 2 || self->gop.gf_group_size < 3) {
+    list1 = 0;
+    list0 = listp_0;
+  }
+
+  if (self->gop.num_ref_frames == 0) {
+    list0 = 0;
+    listp_0 = 0;
+    list1 = 0;
+    self->gop.num_ref_frames = list0 + list1;
+    GST_INFO_OBJECT (self, "No reference for each frame, intra only stream");
+  } else if (self->gop.num_ref_frames <= 2) {
+    list0 = MIN (self->gop.num_ref_frames, list0);
+    listp_0 = list0;
+    list1 = 0;
+    self->gop.num_ref_frames = list0 + list1;
+    GST_INFO_OBJECT (self, "Only %d reference frames, disable backward ref",
+        self->gop.num_ref_frames);
+  } else {
+    if (self->gop.num_ref_frames > list0 + list1) {
+      self->gop.num_ref_frames = list0 + list1;
+      GST_INFO_OBJECT (self, "Lowering the number of reference frames to %d "
+          "because of the reference number limit", self->gop.num_ref_frames);
+    } else if (self->gop.num_ref_frames < list0 + list1) {
+      guint l0 = 0;
+      guint l1 = 0;
+
+      g_assert (list0 > 0);
+      g_assert (list0 >= list1);
+
+      while (list0 > 0 || list1 > 0) {
+        if (list0 > 0) {
+          l0++;
+          list0--;
+        }
+        if (l0 + l1 > self->gop.num_ref_frames)
+          break;
+
+        if (list1 > 0) {
+          l1++;
+          list1--;
+        }
+
+        if (l0 + l1 > self->gop.num_ref_frames)
+          break;
+      }
+
+      list0 = l0;
+      list1 = l1;
+      listp_0 = MIN (l0 + l1, listp_0);
+
+      self->gop.num_ref_frames = list0 + list1;
+    }
+  }
+
+  self->gop.forward_only_ref_num = listp_0;
+  self->gop.forward_ref_num = list0;
+  self->gop.backward_ref_num = list1;
+
+  if (self->gop.num_ref_frames > 0) {
+    self->gop.enable_order_hint = TRUE;
+  } else {
+    self->gop.enable_order_hint = FALSE;
+  }
+
+  GST_INFO_OBJECT (self, "key frame interval %d, golden frame group size %d,"
+      " max hierarchical level %d, reference num %d, forward_only_ref_num %d,"
+      " forward ref num %d, backward ref num %d, order hint is %d",
+      self->gop.keyframe_interval, self->gop.gf_group_size, self->gop.max_level,
+      self->gop.num_ref_frames, self->gop.forward_only_ref_num,
+      self->gop.forward_ref_num, self->gop.backward_ref_num,
+      self->gop.enable_order_hint);
+
+  update_property_uint (base, &self->prop.keyframe_interval,
+      self->gop.keyframe_interval, PROP_KEYFRAME_INT);
+  update_property_uint (base, &self->prop.gf_group_size,
+      self->gop.gf_group_size, PROP_GOLDEN_GROUP_SIZE);
+  update_property_uint (base, &self->prop.num_ref_frames,
+      self->gop.num_ref_frames, PROP_NUM_REF_FRAMES);
+  update_property_uint (base, &self->prop.max_hierarchical_level,
+      self->gop.max_level, PROP_HIERARCHICAL_LEVEL);
+
+  _av1_init_gf_group (&self->gop.current_group, &base->reorder_list);
+
+  return TRUE;
+}
+
+/* 5.9.16. Tile size calculation function */
+static gint
+_av1_tile_log2 (gint blkSize, gint target)
+{
+  gint k;
+
+  for (k = 0; (blkSize << k) < target; k++);
+
+  return k;
+}
+
+static gboolean
+_av1_setup_tile_partition (GstVaAV1Enc * self)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint sb_shift, sb_size;
+  guint max_tile_width_sb, max_tile_area_sb;
+  guint min_log2_tile_cols, max_log2_tile_cols,
+      max_log2_tile_rows, min_log2_tiles;
+
+  /* 5.9.15. Tile info syntax */
+  self->partition.sb_cols = self->partition.use_128x128_superblock ?
+      ((self->mi_cols + 31) >> 5) : ((self->mi_cols + 15) >> 4);
+  self->partition.sb_rows = self->partition.use_128x128_superblock ?
+      ((self->mi_rows + 31) >> 5) : ((self->mi_rows + 15) >> 4);
+
+  sb_shift = self->partition.use_128x128_superblock ? 5 : 4;
+  sb_size = sb_shift + 2;
+  max_tile_width_sb = GST_AV1_MAX_TILE_WIDTH >> sb_size;
+  max_tile_area_sb = GST_AV1_MAX_TILE_AREA >> (2 * sb_size);
+
+  min_log2_tile_cols =
+      _av1_tile_log2 (max_tile_width_sb, self->partition.sb_cols);
+  max_log2_tile_cols =
+      _av1_tile_log2 (1, MIN (self->partition.sb_cols, GST_AV1_MAX_TILE_COLS));
+  max_log2_tile_rows =
+      _av1_tile_log2 (1, MIN (self->partition.sb_rows, GST_AV1_MAX_TILE_ROWS));
+  min_log2_tiles = MAX (min_log2_tile_cols, _av1_tile_log2 (max_tile_area_sb,
+          self->partition.sb_rows * self->partition.sb_cols));
+
+  if (self->partition.max_tile_num < (1 << min_log2_tiles)) {
+    GST_ERROR_OBJECT (self, "HW only support %d tiles, less than the min"
+        " required tile number %d", self->partition.max_tile_num,
+        (1 << min_log2_tiles));
+    return FALSE;
+  }
+
+  if (self->partition.num_tile_cols * self->partition.num_tile_rows >
+      self->partition.max_tile_num) {
+    GST_ERROR_OBJECT (self, "HW only support %d tiles, less than the"
+        " total tile number %dx%d = %d we set", self->partition.max_tile_num,
+        self->partition.num_tile_cols, self->partition.num_tile_rows,
+        self->partition.num_tile_cols * self->partition.num_tile_rows);
+    return FALSE;
+  }
+
+  self->partition.tile_cols_log2 =
+      _av1_tile_log2 (1, self->partition.num_tile_cols);
+  if (self->partition.tile_cols_log2 < min_log2_tile_cols)
+    self->partition.tile_cols_log2 = min_log2_tile_cols;
+  if (self->partition.tile_cols_log2 > max_log2_tile_cols)
+    self->partition.tile_cols_log2 = max_log2_tile_cols;
+
+  self->partition.tile_rows_log2 =
+      _av1_tile_log2 (1, self->partition.num_tile_rows);
+  if (self->partition.tile_rows_log2 > max_log2_tile_rows)
+    self->partition.tile_rows_log2 = max_log2_tile_rows;
+  if (self->partition.tile_cols_log2 + self->partition.tile_rows_log2 <
+      min_log2_tiles)
+    self->partition.tile_rows_log2 =
+        min_log2_tiles - self->partition.tile_cols_log2;
+
+  /* Only support uniform now */
+  self->partition.uniform = TRUE;
+  self->partition.tile_width_sb = (self->partition.sb_cols +
+      (1 << self->partition.tile_cols_log2) - 1)
+      >> self->partition.tile_cols_log2;
+  self->partition.tile_height_sb = (self->partition.sb_rows +
+      (1 << self->partition.tile_rows_log2) - 1)
+      >> self->partition.tile_rows_log2;
+
+  self->partition.num_tile_cols = (self->partition.sb_cols +
+      self->partition.tile_width_sb - 1) / self->partition.tile_width_sb;
+  self->partition.num_tile_rows = (self->partition.sb_rows +
+      self->partition.tile_height_sb - 1) / self->partition.tile_height_sb;
+
+  /* At least one tile for each tile group. */
+  if (self->partition.tile_groups >
+      self->partition.num_tile_cols * self->partition.num_tile_rows)
+    self->partition.tile_groups =
+        self->partition.num_tile_cols * self->partition.num_tile_rows;
+
+  update_property_uint (base, &self->prop.num_tile_cols,
+      self->partition.num_tile_cols, PROP_NUM_TILE_COLS);
+  update_property_uint (base, &self->prop.num_tile_rows,
+      self->partition.num_tile_rows, PROP_NUM_TILE_ROWS);
+  update_property_uint (base, &self->prop.tile_groups,
+      self->partition.tile_groups, PROP_TILE_GROUPS);
+
+  GST_INFO_OBJECT (self, "Tile info: uniform = %d, num_tile_cols = %d, "
+      "num_tile_rows = %d, tile_cols_log2 = %d, tile_rows_log2 = %d, "
+      "tile_width_sb = %d, tile_height_sb = %d, tile_groups = %d",
+      self->partition.uniform, self->partition.num_tile_cols,
+      self->partition.num_tile_rows, self->partition.tile_cols_log2,
+      self->partition.tile_rows_log2, self->partition.tile_width_sb,
+      self->partition.tile_height_sb, self->partition.tile_groups);
+
+  return TRUE;
+}
+
+/* We need to decide the profile and entrypoint before call this.
+   It applies the optimized features provided by the va driver. */
+static void
+_av1_setup_encoding_features (GstVaAV1Enc * self)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  VAStatus status;
+  VAConfigAttrib attrib;
+
+  attrib.type = VAConfigAttribEncAV1;
+  attrib.value = 0;
+  status = vaGetConfigAttributes (gst_va_display_get_va_dpy (base->display),
+      base->profile, GST_VA_BASE_ENC_ENTRYPOINT (base), &attrib, 1);
+  if (status != VA_STATUS_SUCCESS || attrib.value == VA_ATTRIB_NOT_SUPPORTED) {
+    if (status != VA_STATUS_SUCCESS) {
+      GST_INFO_OBJECT (self, "Failed to query encoding features: %s",
+          vaErrorStr (status));
+    } else {
+      GST_INFO_OBJECT (self, "Driver does not support query encoding features");
+    }
+
+    GST_INFO_OBJECT (self, "Use default values for AV1 features");
+
+    self->partition.use_128x128_superblock = FALSE;
+    GST_INFO_OBJECT (self, "128x128 superblock query not supported,"
+        " just disable it");
+
+    self->features.enable_filter_intra = FALSE;
+    self->features.enable_intra_edge_filter = FALSE;
+    self->features.enable_interintra_compound = FALSE;
+    self->features.enable_masked_compound = FALSE;
+    self->features.enable_warped_motion = FALSE;
+    self->features.enable_palette_mode = FALSE;
+    self->features.enable_dual_filter = FALSE;
+    self->features.enable_jnt_comp = FALSE;
+    self->features.enable_ref_frame_mvs = FALSE;
+    self->features.enable_superres = FALSE;
+    self->features.enable_restoration = FALSE;
+    self->features.allow_intrabc = FALSE;
+    self->features.enable_cdef = FALSE;
+    self->features.cdef_channel_strength = FALSE;
+    self->features.cdef_bits = 0;
+  } else {
+    VAConfigAttribValEncAV1 features;
+
+    features.value = attrib.value;
+
+    if (self->partition.use_128x128_superblock
+        && (features.bits.support_128x128_superblock == 0)) {
+      GST_INFO_OBJECT (self, "128x128 superblock is not supported.");
+      self->partition.use_128x128_superblock = FALSE;
+    }
+
+    self->features.enable_filter_intra =
+        (features.bits.support_filter_intra != 0);
+    self->features.enable_intra_edge_filter =
+        (features.bits.support_intra_edge_filter != 0);
+    self->features.enable_interintra_compound =
+        (features.bits.support_interintra_compound != 0);
+    self->features.enable_masked_compound =
+        (features.bits.support_masked_compound != 0);
+    /* not enable it now. */
+    self->features.enable_warped_motion = FALSE;
+    // (features.bits.support_warped_motion != 0);
+    self->features.enable_palette_mode =
+        (features.bits.support_palette_mode != 0);
+    self->features.enable_dual_filter =
+        (features.bits.support_dual_filter != 0);
+    self->features.enable_jnt_comp = (features.bits.support_jnt_comp != 0);
+    self->features.enable_ref_frame_mvs =
+        (features.bits.support_ref_frame_mvs != 0);
+    /* not enable it now. */
+    self->features.enable_superres = FALSE;
+    self->features.enable_restoration = FALSE;
+    // (features.bits.support_restoration != 0);
+    /* not enable it now. */
+    self->features.allow_intrabc = FALSE;
+    self->features.enable_cdef = TRUE;
+    self->features.cdef_channel_strength =
+        (features.bits.support_cdef_channel_strength != 0);
+    self->features.cdef_bits = 0;
+  }
+
+  update_property_bool (base, &self->prop.use_128x128_superblock,
+      self->partition.use_128x128_superblock, PROP_128X128_SUPERBLOCK);
+
+  attrib.type = VAConfigAttribEncAV1Ext1;
+  attrib.value = 0;
+  status = vaGetConfigAttributes (gst_va_display_get_va_dpy (base->display),
+      base->profile, GST_VA_BASE_ENC_ENTRYPOINT (base), &attrib, 1);
+  if (status != VA_STATUS_SUCCESS || attrib.value == VA_ATTRIB_NOT_SUPPORTED) {
+    if (status != VA_STATUS_SUCCESS) {
+      GST_INFO_OBJECT (self, "Failed to query encoding feature ext1: %s",
+          vaErrorStr (status));
+    } else {
+      GST_INFO_OBJECT (self, "Driver does not support query encoding"
+          " feature ext1");
+    }
+
+    GST_INFO_OBJECT (self, "Use default values for AV1 feature ext1");
+
+    /* Only EIGHTTAP */
+    self->features.interpolation_filter_support =
+        1 << GST_AV1_INTERPOLATION_FILTER_EIGHTTAP;
+    self->features.interpolation_type = GST_AV1_INTERPOLATION_FILTER_EIGHTTAP;
+
+    self->features.enable_segmentation = FALSE;
+  } else {
+    VAConfigAttribValEncAV1Ext1 features_ext1;
+    guint i;
+
+    features_ext1.value = attrib.value;
+
+    self->features.interpolation_filter_support =
+        (features_ext1.bits.interpolation_filter & 0x1f);
+    if (self->features.interpolation_filter_support == 0) {
+      GST_INFO_OBJECT (self, "No interpolation filter support,"
+          " just assume it supports EIGHTTAP type");
+      self->features.interpolation_filter_support =
+          1 << GST_AV1_INTERPOLATION_FILTER_EIGHTTAP;
+    }
+
+    for (i = 0; i < 5; i++) {
+      if (self->features.interpolation_filter_support & (1 << i)) {
+        self->features.interpolation_type = i;
+        break;
+      }
+    }
+
+    /* not enable segmentation now. */
+    self->features.enable_segmentation = FALSE;
+  }
+
+  attrib.type = VAConfigAttribEncAV1Ext2;
+  attrib.value = 0;
+  status = vaGetConfigAttributes (gst_va_display_get_va_dpy (base->display),
+      base->profile, GST_VA_BASE_ENC_ENTRYPOINT (base), &attrib, 1);
+  if (status != VA_STATUS_SUCCESS || attrib.value == VA_ATTRIB_NOT_SUPPORTED) {
+    if (status != VA_STATUS_SUCCESS) {
+      GST_INFO_OBJECT (self, "Failed to query encoding feature ext2: %s",
+          vaErrorStr (status));
+    } else {
+      GST_INFO_OBJECT (self, "Driver does not support query encoding"
+          " feature ext2");
+    }
+
+    GST_INFO_OBJECT (self, "Use default values for AV1 feature ext2");
+
+    self->partition.tile_size_bytes_minus_1 = 3;
+    self->features.obu_size_bytes = 4;
+    self->features.tx_mode_support = GST_AV1_TX_MODE_LARGEST;
+    self->partition.max_tile_num = 1;
+  } else {
+    VAConfigAttribValEncAV1Ext2 features_ext2;
+
+    features_ext2.value = attrib.value;
+
+    self->partition.tile_size_bytes_minus_1 =
+        features_ext2.bits.tile_size_bytes_minus1;
+    self->features.obu_size_bytes =
+        features_ext2.bits.obu_size_bytes_minus1 + 1;
+
+    self->features.tx_mode_support = features_ext2.bits.tx_mode_support;
+    if (!(self->features.tx_mode_support &
+            (GST_AV1_TX_MODE_LARGEST | GST_AV1_TX_MODE_SELECT))) {
+      GST_WARNING_OBJECT (self, "query tx_mode_support get invalid"
+          " value 0x%x, set to support TX_MODE_LARGEST",
+          self->features.tx_mode_support);
+      self->features.tx_mode_support = GST_AV1_TX_MODE_LARGEST;
+    }
+
+    self->partition.max_tile_num = features_ext2.bits.max_tile_num_minus1 + 1;
+  }
+
+  GST_INFO_OBJECT (self, "Setting the features: use_128x128_superblock = %d,"
+      " enable_filter_intra = %d, enable_intra_edge_filter = %d,"
+      " enable_interintra_compound = %d, enable_masked_compound = %d,"
+      " enable_warped_motion = %d, enable_palette_mode = %d,"
+      " enable_dual_filter = %d, enable_jnt_comp = %d,"
+      " enable_ref_frame_mvs = %d, enable_superres = %d,"
+      " enable_restoration = %d, allow_intrabc = %d,"
+      " enable_cdef = %d, cdef_channel_strength = %d,"
+      " interpolation_filter_support = %d,"
+      " interpolation_type = %d, enable_segmentation = %d,"
+      " tile_size_bytes_minus_1 = %d, obu_size_bytes = %d,"
+      " tx_mode_support = 0x%x, max_tile_num = %d",
+      self->partition.use_128x128_superblock,
+      self->features.enable_filter_intra,
+      self->features.enable_intra_edge_filter,
+      self->features.enable_interintra_compound,
+      self->features.enable_masked_compound,
+      self->features.enable_warped_motion, self->features.enable_palette_mode,
+      self->features.enable_dual_filter, self->features.enable_jnt_comp,
+      self->features.enable_ref_frame_mvs, self->features.enable_superres,
+      self->features.enable_restoration, self->features.allow_intrabc,
+      self->features.enable_cdef, self->features.cdef_channel_strength,
+      self->features.interpolation_filter_support,
+      self->features.interpolation_type, self->features.enable_segmentation,
+      self->partition.tile_size_bytes_minus_1, self->features.obu_size_bytes,
+      self->features.tx_mode_support, self->partition.max_tile_num);
+}
+
+static void
+_av1_calculate_coded_size (GstVaAV1Enc * self)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint un_compressed_size /* UnCompressedSize */ ;
+  guint pic_size_profile_factor /* PicSizeProfileFactor */ ;
+
+  /* Annex A: */
+  switch (base->profile) {
+    case VAProfileAV1Profile0:
+      pic_size_profile_factor = 15;
+      break;
+    case VAProfileAV1Profile1:
+      pic_size_profile_factor = 30;
+      break;
+    default:
+      pic_size_profile_factor = 36;
+      break;
+  }
+
+  un_compressed_size =
+      ((base->width * base->height * pic_size_profile_factor) >> 3);
+
+  /* FIXME: Using only a rough approximation for bitstream headers.
+     We do not calculate SpeedAdj and do not consider still_picture. */
+  base->codedbuf_size = un_compressed_size / self->cr;
+
+  GST_INFO_OBJECT (self, "Calculate codedbuf size: %u", base->codedbuf_size);
+}
+
+/* Normalizes bitrate (and CPB size) for HRD conformance */
+static void
+_av1_calculate_bitrate_hrd (GstVaAV1Enc * self)
+{
+  guint bitrate_bits, cpb_bits_size;
+
+  bitrate_bits = self->rc.max_bitrate * 1000;
+  GST_DEBUG_OBJECT (self, "Max bitrate: %u bits/sec", bitrate_bits);
+  self->rc.max_bitrate_bits = bitrate_bits;
+
+  bitrate_bits = self->rc.target_bitrate * 1000;
+  GST_DEBUG_OBJECT (self, "Target bitrate: %u bits/sec", bitrate_bits);
+  self->rc.target_bitrate_bits = bitrate_bits;
+
+  if (self->rc.cpb_size > 0 && self->rc.cpb_size < (self->rc.max_bitrate / 2)) {
+    GST_INFO_OBJECT (self, "Too small cpb_size: %d", self->rc.cpb_size);
+    self->rc.cpb_size = 0;
+  }
+
+  if (self->rc.cpb_size == 0) {
+    /* We cache 2 second coded data by default. */
+    self->rc.cpb_size = self->rc.max_bitrate * 2;
+    GST_INFO_OBJECT (self, "Adjust cpb_size to: %d", self->rc.cpb_size);
+  }
+
+  cpb_bits_size = self->rc.cpb_size * 1000;
+
+  GST_DEBUG_OBJECT (self, "HRD CPB size: %u bits", cpb_bits_size);
+  self->rc.cpb_length_bits = cpb_bits_size;
+}
+
+/* Estimates a good enough bitrate if none was supplied */
+static gboolean
+_av1_ensure_rate_control (GstVaAV1Enc * self)
+{
+  /* User can specify the properties of: "bitrate", "target-percentage",
+   * "max-qp", "min-qp", "qp", "mbbrc", "cpb-size", "rate-control" and
+   * "target-usage" to control the RC behavior.
+   *
+   * "target-usage" is different from the others, it controls the encoding
+   * speed and quality, while the others control encoding bit rate and
+   * quality. The lower value has better quality(maybe bigger MV search
+   * range) but slower speed, the higher value has faster speed but lower
+   * quality.
+   *
+   * The possible composition to control the bit rate and quality:
+   *
+   * 1. CQP mode: "rate-control=cqp", then "qp"(the qindex in AV1) specify
+   *    the QP of frames(within the "max-qp" and "min-qp" range). The QP
+   *    will not change during the whole stream. Other properties related
+   *    to rate control are ignored.
+   *
+   * 2. CBR mode: "rate-control=CBR", then the "bitrate" specify the
+   *    target bit rate and the "cpb-size" specifies the max coded
+   *    picture buffer size to avoid overflow. If the "bitrate" is not
+   *    set, it is calculated by the picture resolution and frame
+   *    rate. If "cpb-size" is not set, it is set to the size of
+   *    caching 2 second coded data. Encoder will try its best to make
+   *    the QP with in the ["max-qp", "min-qp"] range. "mbbrc" can
+   *    enable bit rate control in macro block level. Other paramters
+   *    are ignored.
+   *
+   * 3. VBR mode: "rate-control=VBR", then the "bitrate" specify the
+   *    target bit rate, "target-percentage" is used to calculate the
+   *    max bit rate of VBR mode by ("bitrate" * 100) /
+   *    "target-percentage". It is also used by driver to calculate
+   *    the min bit rate. The "cpb-size" specifies the max coded
+   *    picture buffer size to avoid overflow. If the "bitrate" is not
+   *    set, the target bit rate will be calculated by the picture
+   *    resolution and frame rate. Encoder will try its best to make
+   *    the QP with in the ["max-qp", "min-qp"] range. "mbbrc" can
+   *    enable bit rate control in macro block level. Other paramters
+   *    are ignored.
+   *
+   * 4. VCM mode: "rate-control=VCM", then the "bitrate" specify the
+   *    target bit rate, and encoder will try its best to make the QP
+   *    with in the ["max-qp", "min-qp"] range. Other paramters are
+   *    ignored.
+   */
+
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint bitrate;
+  guint32 rc_ctrl, rc_mode, quality_level;
+
+  quality_level = gst_va_encoder_get_quality_level (base->encoder,
+      base->profile, GST_VA_BASE_ENC_ENTRYPOINT (base));
+  if (self->rc.target_usage > quality_level) {
+    GST_INFO_OBJECT (self, "User setting target-usage: %d is not supported, "
+        "fallback to %d", self->rc.target_usage, quality_level);
+    self->rc.target_usage = quality_level;
+
+    update_property_uint (base, &self->prop.target_usage, self->rc.target_usage,
+        PROP_TARGET_USAGE);
+  }
+
+  GST_OBJECT_LOCK (self);
+  rc_ctrl = self->prop.rc_ctrl;
+  GST_OBJECT_UNLOCK (self);
+
+  if (rc_ctrl != VA_RC_NONE) {
+    rc_mode = gst_va_encoder_get_rate_control_mode (base->encoder,
+        base->profile, GST_VA_BASE_ENC_ENTRYPOINT (base));
+    if (!(rc_mode & rc_ctrl)) {
+      guint32 defval =
+          G_PARAM_SPEC_ENUM (properties[PROP_RATE_CONTROL])->default_value;
+      GST_INFO_OBJECT (self, "The rate control mode %s is not supported, "
+          "fallback to %s mode", _rate_control_get_name (rc_ctrl),
+          _rate_control_get_name (defval));
+      self->rc.rc_ctrl_mode = defval;
+
+      update_property_uint (base, &self->prop.rc_ctrl, self->rc.rc_ctrl_mode,
+          PROP_RATE_CONTROL);
+    }
+  } else {
+    self->rc.rc_ctrl_mode = VA_RC_NONE;
+  }
+
+  if (self->rc.min_qindex > self->rc.max_qindex) {
+    GST_INFO_OBJECT (self, "The min_qindex %d is bigger than the max_qindex"
+        " %d, set it to the max_qindex", self->rc.min_qindex,
+        self->rc.max_qindex);
+    self->rc.min_qindex = self->rc.max_qindex;
+
+    update_property_uint (base, &self->prop.min_qp, self->rc.min_qindex,
+        PROP_MIN_QP);
+  }
+
+  /* Make the qp in the valid range */
+  if (self->rc.base_qindex < self->rc.min_qindex) {
+    if (self->rc.base_qindex != DEFAULT_BASE_QINDEX)
+      GST_INFO_OBJECT (self, "The base_qindex %d is smaller than the"
+          " min_qindex %d, set it to the min_qindex", self->rc.base_qindex,
+          self->rc.min_qindex);
+    self->rc.base_qindex = self->rc.min_qindex;
+  }
+  if (self->rc.base_qindex > self->rc.max_qindex) {
+    if (self->rc.base_qindex != DEFAULT_BASE_QINDEX)
+      GST_INFO_OBJECT (self, "The base_qindex %d is bigger than the"
+          " max_qindex %d, set it to the max_qindex", self->rc.base_qindex,
+          self->rc.max_qindex);
+    self->rc.base_qindex = self->rc.max_qindex;
+  }
+
+  GST_OBJECT_LOCK (self);
+  bitrate = self->prop.bitrate;
+  GST_OBJECT_UNLOCK (self);
+
+  /* Calculate a bitrate if it is not set. */
+  if ((self->rc.rc_ctrl_mode == VA_RC_CBR || self->rc.rc_ctrl_mode == VA_RC_VBR
+          || self->rc.rc_ctrl_mode == VA_RC_VCM) && bitrate == 0) {
+    /* FIXME: Provide better estimation. */
+    /* Choose the max value of all levels' MainCR which is 8, and x2 for
+       conservative calculation. So just using a 1/16 compression ratio,
+       12 bits per pixel for 4:2:0, 16 bits per pixel for 4:2:2 and 24 bits
+       per pixel for 4:4:4. Also the depth should be considered. */
+    guint64 factor;
+    guint depth = 8, chrome = 1;
+    guint bits_per_pix;
+
+    if (!_av1_get_rtformat (self,
+            GST_VIDEO_INFO_FORMAT (&base->input_state->info), &depth, &chrome))
+      g_assert_not_reached ();
+
+    if (chrome == 3) {
+      bits_per_pix = 24;
+    } else if (chrome == 2) {
+      bits_per_pix = 16;
+    } else {
+      bits_per_pix = 12;
+    }
+    bits_per_pix = bits_per_pix + bits_per_pix * (depth - 8) / 8;
+
+    factor = (guint64) base->width * base->height * bits_per_pix / 16;
+    bitrate = gst_util_uint64_scale (factor,
+        GST_VIDEO_INFO_FPS_N (&base->input_state->info),
+        GST_VIDEO_INFO_FPS_D (&base->input_state->info)) / 1000;
+
+    GST_INFO_OBJECT (self, "target bitrate computed to %u kbps", bitrate);
+
+    self->prop.bitrate = bitrate;
+    g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_BITRATE]);
+  }
+
+  /* Adjust the setting based on RC mode. */
+  switch (self->rc.rc_ctrl_mode) {
+    case VA_RC_NONE:
+    case VA_RC_CQP:
+      self->rc.max_bitrate = 0;
+      self->rc.target_bitrate = 0;
+      self->rc.target_percentage = 0;
+      self->rc.cpb_size = 0;
+      self->rc.mbbrc = 0;
+      break;
+    case VA_RC_CBR:
+      self->rc.max_bitrate = bitrate;
+      self->rc.target_bitrate = bitrate;
+      self->rc.target_percentage = 100;
+      self->rc.base_qindex = DEFAULT_BASE_QINDEX;
+      break;
+    case VA_RC_VBR:
+      g_assert (self->rc.target_percentage >= 10);
+      self->rc.max_bitrate = (guint) gst_util_uint64_scale_int (bitrate,
+          100, self->rc.target_percentage);
+      self->rc.target_bitrate = bitrate;
+      self->rc.base_qindex = DEFAULT_BASE_QINDEX;
+      break;
+    case VA_RC_VCM:
+      self->rc.max_bitrate = bitrate;
+      self->rc.target_bitrate = bitrate;
+      self->rc.target_percentage = 0;
+      self->rc.base_qindex = DEFAULT_BASE_QINDEX;
+      self->rc.cpb_size = 0;
+
+      if (self->gop.max_level > 1) {
+        GST_INFO_OBJECT (self, "VCM mode does not reorder frames");
+        self->gop.max_level = 1;
+      }
+      break;
+    default:
+      GST_WARNING_OBJECT (self, "Unsupported rate control");
+      return FALSE;
+      break;
+  }
+
+  GST_DEBUG_OBJECT (self, "Max bitrate: %u bits/sec, "
+      "Target bitrate: %u bits/sec", self->rc.max_bitrate,
+      self->rc.target_bitrate);
+
+  if (self->rc.rc_ctrl_mode != VA_RC_NONE && self->rc.rc_ctrl_mode != VA_RC_CQP)
+    _av1_calculate_bitrate_hrd (self);
+
+  /* notifications */
+  update_property_uint (base, &self->prop.cpb_size, self->rc.cpb_size,
+      PROP_CPB_SIZE);
+  update_property_uint (base, &self->prop.target_percentage,
+      self->rc.target_percentage, PROP_TARGET_PERCENTAGE);
+  update_property_uint (base, &self->prop.qp, self->rc.base_qindex, PROP_QP);
+  update_property_uint (base, &self->prop.mbbrc, self->rc.mbbrc, PROP_MBBRC);
+
+  return TRUE;
+}
+
+static gboolean
+gst_va_av1_enc_reconfig (GstVaBaseEnc * base)
+{
+  GstVideoEncoder *venc = GST_VIDEO_ENCODER (base);
+  GstVaAV1Enc *self = GST_VA_AV1_ENC (base);
+  GstCaps *out_caps;
+  GstVideoCodecState *output_state;
+  GstVideoFormat in_format;
+  guint max_ref_frames;
+
+  gst_va_base_enc_reset_state (base);
+
+  base->width = GST_VIDEO_INFO_WIDTH (&base->input_state->info);
+  base->height = GST_VIDEO_INFO_HEIGHT (&base->input_state->info);
+  self->mi_cols = 2 * ((base->width + 7) >> 3);
+  self->mi_rows = 2 * ((base->height + 7) >> 3);
+
+  /* Frame rate is needed for rate control and PTS setting. */
+  if (GST_VIDEO_INFO_FPS_N (&base->input_state->info) == 0
+      || GST_VIDEO_INFO_FPS_D (&base->input_state->info) == 0) {
+    GST_INFO_OBJECT (self, "Unknown framerate, just set to 30 fps");
+    GST_VIDEO_INFO_FPS_N (&base->input_state->info) = 30;
+    GST_VIDEO_INFO_FPS_D (&base->input_state->info) = 1;
+  }
+  base->frame_duration = gst_util_uint64_scale (GST_SECOND,
+      GST_VIDEO_INFO_FPS_D (&base->input_state->info),
+      GST_VIDEO_INFO_FPS_N (&base->input_state->info));
+
+  in_format = GST_VIDEO_INFO_FORMAT (&base->input_state->info);
+  base->rt_format =
+      _av1_get_rtformat (self, in_format, &self->depth, &self->chrome);
+  if (!base->rt_format) {
+    GST_ERROR_OBJECT (self, "unrecognized input format.");
+    return FALSE;
+  }
+
+  if (!_av1_decide_profile (self))
+    return FALSE;
+
+  if (!_av1_ensure_rate_control (self))
+    return FALSE;
+
+  if (!_av1_calculate_level_and_tier (self))
+    return FALSE;
+
+  if (!_av1_init_packed_headers (self))
+    return FALSE;
+
+  _av1_setup_encoding_features (self);
+
+  if (!_av1_generate_gop_structure (self))
+    return FALSE;
+
+  if (!_av1_setup_tile_partition (self))
+    return FALSE;
+
+  _av1_calculate_coded_size (self);
+
+  max_ref_frames = GST_AV1_NUM_REF_FRAMES + 3 /* scratch frames */ ;
+  if (!gst_va_encoder_open (base->encoder, base->profile,
+          GST_VIDEO_INFO_FORMAT (&base->input_state->info), base->rt_format,
+          base->width, base->height, base->codedbuf_size, max_ref_frames,
+          self->rc.rc_ctrl_mode, self->packed_headers)) {
+    GST_ERROR_OBJECT (self, "Failed to open the VA encoder.");
+    return FALSE;
+  }
+
+  /* Add some tags */
+  gst_va_base_enc_add_codec_tag (base, "AV1");
+
+  out_caps = gst_va_profile_caps (base->profile);
+  g_assert (out_caps);
+  out_caps = gst_caps_fixate (out_caps);
+
+  if (self->level_str)
+    gst_caps_set_simple (out_caps, "level", G_TYPE_STRING, self->level_str,
+        NULL);
+
+  gst_caps_set_simple (out_caps, "width", G_TYPE_INT, base->width,
+      "height", G_TYPE_INT, base->height, "alignment", G_TYPE_STRING, "frame",
+      "stream-format", G_TYPE_STRING, "obu-stream", NULL);
+
+  GST_DEBUG_OBJECT (self, "output caps is %" GST_PTR_FORMAT, out_caps);
+
+  output_state =
+      gst_video_encoder_set_output_state (venc, out_caps, base->input_state);
+  gst_video_codec_state_unref (output_state);
+
+  if (!gst_video_encoder_negotiate (venc)) {
+    GST_ERROR_OBJECT (self, "Failed to negotiate with the downstream");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static inline void
+_av1_fill_sequence_param (GstVaAV1Enc * self,
+    VAEncSequenceParameterBufferAV1 * sequence)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint8 seq_profile;
+
+  if (base->profile == VAProfileAV1Profile0) {
+    seq_profile = 0;
+  } else if (base->profile == VAProfileAV1Profile1) {
+    seq_profile = 1;
+  } else {
+    GST_ERROR_OBJECT (self, "VA profile %d not supported", base->profile);
+    g_assert_not_reached ();
+    return;
+  }
+
+  /* *INDENT-OFF* */
+  *sequence = (VAEncSequenceParameterBufferAV1) {
+    .seq_profile = seq_profile,
+    .seq_level_idx = self->level_idx,
+    .seq_tier = self->tier,
+    .intra_period = self->gop.num_ref_frames == 0 ? 1 :
+        self->gop.keyframe_interval,
+    .ip_period = self->gop.backward_ref_num == 0 ? 1 :
+        self->gop.gf_group_size,
+    .bits_per_second = self->rc.target_bitrate_bits,
+    .seq_fields.bits = {
+      .still_picture = 0,
+      .use_128x128_superblock = self->partition.use_128x128_superblock,
+      .enable_filter_intra = self->features.enable_filter_intra,
+      .enable_intra_edge_filter = self->features.enable_intra_edge_filter,
+      .enable_interintra_compound = self->features.enable_interintra_compound,
+      .enable_masked_compound = self->features.enable_masked_compound,
+      .enable_warped_motion = self->features.enable_warped_motion,
+      .enable_dual_filter = self->features.enable_dual_filter,
+      .enable_order_hint = self->gop.enable_order_hint,
+      .enable_jnt_comp = self->features.enable_jnt_comp,
+      .enable_ref_frame_mvs = self->features.enable_ref_frame_mvs,
+      .enable_superres = self->features.enable_superres,
+      .enable_cdef = self->features.enable_cdef,
+      .enable_restoration = self->features.enable_restoration,
+      .bit_depth_minus8 = self->depth - 8,
+      .subsampling_x = (self->chrome != 3),
+      .subsampling_y = (self->chrome != 3 && self->chrome != 2),
+    },
+    .order_hint_bits_minus_1 = _av1_helper_msb (self->gop.keyframe_interval + 1),
+  };
+  /* *INDENT-ON* */
+}
+
+static void
+_av1_fill_sequence_header (GstVaAV1Enc * self,
+    VAEncSequenceParameterBufferAV1 * seq_param)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+
+  /* *INDENT-OFF* */
+  self->sequence_hdr = (GstAV1SequenceHeaderOBU) {
+    .seq_profile = seq_param->seq_profile,
+    .still_picture = 0,
+    .num_planes = (self->chrome == 0 ? 1 : 3),
+    .reduced_still_picture_header = 0,
+    .timing_info_present_flag = 0,
+    .decoder_model_info_present_flag = 0,
+    .initial_display_delay_present_flag = 0,
+    .operating_points_cnt_minus_1 = 0,
+    .operating_points = {
+      {
+        .seq_level_idx = seq_param->seq_level_idx,
+        .seq_tier = seq_param->seq_tier,
+        .idc = 0,
+      },
+    },
+    .frame_width_bits_minus_1 = _av1_helper_msb (base->width),
+    .frame_height_bits_minus_1 = _av1_helper_msb (base->height),
+    .max_frame_width_minus_1 = base->width - 1,
+    .max_frame_height_minus_1 = base->height - 1,
+    .frame_id_numbers_present_flag = 0,
+    .use_128x128_superblock = seq_param->seq_fields.bits.use_128x128_superblock,
+    .enable_filter_intra = seq_param->seq_fields.bits.enable_filter_intra,
+    .enable_intra_edge_filter = seq_param->seq_fields.bits.enable_intra_edge_filter,
+    .enable_interintra_compound = seq_param->seq_fields.bits.enable_interintra_compound,
+    .enable_masked_compound = seq_param->seq_fields.bits.enable_masked_compound,
+    .enable_warped_motion = seq_param->seq_fields.bits.enable_warped_motion,
+    .enable_dual_filter = seq_param->seq_fields.bits.enable_dual_filter,
+    .enable_order_hint = seq_param->seq_fields.bits.enable_order_hint,
+    .enable_jnt_comp = seq_param->seq_fields.bits.enable_jnt_comp,
+    .enable_ref_frame_mvs = seq_param->seq_fields.bits.enable_ref_frame_mvs,
+    .seq_choose_screen_content_tools = 0,
+    .order_hint_bits_minus_1 = seq_param->order_hint_bits_minus_1,
+    .enable_superres = seq_param->seq_fields.bits.enable_superres,
+    .enable_cdef = seq_param->seq_fields.bits.enable_cdef,
+    .enable_restoration = seq_param->seq_fields.bits.enable_restoration,
+    .color_config = {
+      .high_bitdepth = (seq_param->seq_fields.bits.bit_depth_minus8 > 0),
+      .mono_chrome = (self->chrome == 0),
+      .color_description_present_flag = 0,
+      .color_primaries = GST_AV1_CP_UNSPECIFIED,
+      .transfer_characteristics = GST_AV1_TC_UNSPECIFIED,
+      .matrix_coefficients = GST_AV1_MC_UNSPECIFIED,
+      .color_range = 0,
+      .subsampling_x = seq_param->seq_fields.bits.subsampling_x,
+      .subsampling_y = seq_param->seq_fields.bits.subsampling_y,
+      .chroma_sample_position = 0,
+      .separate_uv_delta_q = 0,
+    },
+    .film_grain_params_present = 0,
+  };
+  /* *INDENT-ON* */
+}
+
+static gboolean
+_av1_add_sequence_param (GstVaAV1Enc * self, GstVaEncodePicture * picture,
+    VAEncSequenceParameterBufferAV1 * sequence)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+
+  if (!gst_va_encoder_add_param (base->encoder, picture,
+          VAEncSequenceParameterBufferType, sequence, sizeof (*sequence))) {
+    GST_ERROR_OBJECT (self, "Failed to create the sequence parameter");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+_av1_add_sequence_header (GstVaAV1Enc * self, GstVaAV1EncFrame * frame,
+    guint * size_offset)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint size;
+  guint8 packed_sps[256] = { 0, };
+
+  size = sizeof (packed_sps);
+  if (gst_av1_bit_writer_sequence_header_obu (&self->sequence_hdr, TRUE,
+          packed_sps, &size)
+      != GST_AV1_BIT_WRITER_OK) {
+    GST_ERROR_OBJECT (self, "Failed to write sequence header.");
+    return FALSE;
+  }
+
+  *size_offset += size;
+
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+          VAEncPackedHeaderSequence, packed_sps, size * 8, FALSE)) {
+    GST_ERROR_OBJECT (self, "Failed to add packed sequence header.");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+_av1_fill_frame_param (GstVaAV1Enc * self, GstVaAV1EncFrame * va_frame,
+    VAEncPictureParameterBufferAV1 * pic_param)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint i;
+  uint8_t primary_ref_frame = GST_AV1_PRIMARY_REF_NONE;
+  uint8_t refresh_frame_flags = 0xff;
+  gboolean frame_is_intra;
+  gboolean allow_intrabc;
+  guint tx_mode;
+  guint reference_mode;
+
+  g_assert (!(va_frame->type & FRAME_TYPE_REPEAT));
+
+  /* *INDENT-OFF* */
+  tx_mode = (self->features.tx_mode_support & GST_AV1_TX_MODE_SELECT) ?
+      GST_AV1_TX_MODE_SELECT : GST_AV1_TX_MODE_LARGEST;
+
+  frame_is_intra = (va_frame->type == GST_AV1_INTRA_ONLY_FRAME
+      || va_frame->type == GST_AV1_KEY_FRAME);
+
+  /* Prefer to let the driver make decision. */
+  reference_mode = frame_is_intra ? 0 : (va_frame->bidir_ref ? 2 : 0);
+
+  if (va_frame->type != GST_AV1_INTER_FRAME) {
+    primary_ref_frame = GST_AV1_PRIMARY_REF_NONE;
+  } else {
+    /* Set it to GST_AV1_REF_LAST_FRAME */
+    primary_ref_frame = GST_AV1_REF_LAST_FRAME - GST_AV1_REF_LAST_FRAME;
+  }
+
+  if (va_frame->type != GST_AV1_KEY_FRAME
+      && va_frame->type != GST_AV1_SWITCH_FRAME) {
+    if (va_frame->update_index >= 0) {
+      refresh_frame_flags = (1 << va_frame->update_index);
+    } else {
+      refresh_frame_flags = 0;
+    }
+  }
+
+  allow_intrabc = self->features.allow_intrabc;
+  if (va_frame->type != GST_AV1_KEY_FRAME
+      && va_frame->type != GST_AV1_INTRA_ONLY_FRAME)
+    allow_intrabc = 0;
+
+  *pic_param = (VAEncPictureParameterBufferAV1) {
+    .frame_width_minus_1 = base->width - 1,
+    .frame_height_minus_1 = base->height - 1,
+    .reconstructed_frame =
+        gst_va_encode_picture_get_reconstruct_surface (va_frame->picture),
+    .coded_buf = va_frame->picture->coded_buffer,
+    .primary_ref_frame = primary_ref_frame,
+    .order_hint = va_frame->order_hint,
+    .refresh_frame_flags = refresh_frame_flags,
+    /* Set ref_frame_ctrl later if inter frame. */
+    .ref_frame_ctrl_l0 = { },
+    .ref_frame_ctrl_l1 = { },
+    .picture_flags.bits = {
+      .frame_type = va_frame->type,
+      /* We do not support error resilient mode now. */
+      .error_resilient_mode = (va_frame->type == GST_AV1_KEY_FRAME),
+      .disable_cdf_update = 0,
+      .use_superres = self->features.enable_superres,
+      .allow_high_precision_mv = (frame_is_intra == FALSE),
+      .use_ref_frame_mvs = self->features.enable_ref_frame_mvs,
+      .disable_frame_end_update_cdf = 0,
+      .reduced_tx_set = 0,
+      /* We just use frame header + tile group mode */
+      .enable_frame_obu = 0,
+      .long_term_reference = 0,
+      .disable_frame_recon = 0,
+      .allow_intrabc = allow_intrabc,
+      .palette_mode_enable = self->features.enable_palette_mode,
+    },
+    /* segmentation does not support now */
+    .seg_id_block_size = 0,
+    .num_tile_groups_minus1 = self->partition.tile_groups - 1,
+    .temporal_id = va_frame->temporal_id,
+    .filter_level = { 0, 0 },
+    .filter_level_u = 0,
+    .filter_level_v = 0,
+    .loop_filter_flags.bits = {
+      .sharpness_level = 0,
+      .mode_ref_delta_enabled = 0,
+      .mode_ref_delta_update = 0,
+    },
+    .superres_scale_denominator = 0,
+    .interpolation_filter = self->features.interpolation_type,
+    /* Default ref deltas */
+    .ref_deltas = { 1, 0, 0, 0, -1, 0, -1, -1 },
+    .mode_deltas = { 0, 0 },
+    .base_qindex = self->rc.base_qindex,
+    /* Just set to 0. */
+    .y_dc_delta_q = 0,
+    .u_dc_delta_q = 0,
+    .u_ac_delta_q = 0,
+    .v_dc_delta_q = 0,
+    .v_ac_delta_q = 0,
+    .min_base_qindex = self->rc.min_qindex,
+    .max_base_qindex = self->rc.max_qindex,
+    .qmatrix_flags.bits = {
+      .using_qmatrix = 0,
+      .qm_y = 0,
+      .qm_u = 0,
+      .qm_v = 0,
+    },
+    .mode_control_flags.bits = {
+      .delta_q_present = 0,
+      .delta_q_res = 0,
+      .delta_lf_present = 0,
+      .delta_lf_res = 0,
+      .delta_lf_multi = 0,
+      .tx_mode = tx_mode,
+      .reference_mode = reference_mode,
+      .skip_mode_present = 0,
+    },
+    /* Do not enable segments now. */
+    .segments.seg_flags.bits.segmentation_enabled =
+        self->features.enable_segmentation,
+    .tile_cols = self->partition.num_tile_cols,
+    .tile_rows = self->partition.num_tile_rows,
+    /* Set it later. */
+    .width_in_sbs_minus_1 = { 0 },
+    .height_in_sbs_minus_1 = { 0 },
+    .context_update_tile_id = 0,
+    .cdef_damping_minus_3 = 0,
+    .cdef_bits = self->features.cdef_bits,
+    .cdef_y_strengths = { 0, },
+    .cdef_uv_strengths = { 0, },
+    .loop_restoration_flags.bits = {
+      .yframe_restoration_type = 0,
+      .cbframe_restoration_type = 0,
+      .crframe_restoration_type = 0,
+      .lr_unit_shift = 0,
+      .lr_uv_shift = 0,
+    },
+    /* TODO: wm setting. */
+    .wm = { },
+    /* Feed all the offsets later. */
+    .tile_group_obu_hdr_info.bits = {
+      .obu_extension_flag = 0,
+      .obu_has_size_field = 1,
+      .temporal_id = va_frame->temporal_id,
+      .spatial_id = va_frame->spatial_id,
+    },
+    .number_skip_frames = 0,
+    .skip_frames_reduced_size = 0,
+  };
+  /* *INDENT-ON* */
+
+  for (i = 0; i < self->partition.num_tile_cols - 1; i++)
+    pic_param->width_in_sbs_minus_1[i] = self->partition.tile_width_sb - 1;
+  pic_param->width_in_sbs_minus_1[i] = self->partition.sb_cols -
+      (self->partition.num_tile_cols - 1) * self->partition.tile_width_sb - 1;
+
+  for (i = 0; i < self->partition.num_tile_rows - 1; i++)
+    pic_param->height_in_sbs_minus_1[i] = self->partition.tile_height_sb - 1;
+  pic_param->height_in_sbs_minus_1[i] = self->partition.sb_rows -
+      (self->partition.num_tile_rows - 1) * self->partition.tile_height_sb - 1;
+
+  if (va_frame->type == GST_AV1_INTER_FRAME) {
+    for (i = 0; i < 8; i++) {
+      if (self->gop.ref_list[i] == NULL) {
+        pic_param->reference_frames[i] = VA_INVALID_SURFACE;
+        continue;
+      }
+
+      pic_param->reference_frames[i] =
+          gst_va_encode_picture_get_reconstruct_surface
+          (_enc_frame (self->gop.ref_list[i])->picture);
+    }
+
+    for (i = 0; i < 7; i++) {
+      if (va_frame->ref_frame_idx[i + GST_AV1_REF_LAST_FRAME] == -1) {
+        pic_param->ref_frame_idx[i] = 0xFF;
+        continue;
+      }
+
+      pic_param->ref_frame_idx[i] =
+          va_frame->ref_frame_idx[i + GST_AV1_REF_LAST_FRAME];
+    }
+
+    g_assert (va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME] != -1);
+    pic_param->ref_frame_ctrl_l0.fields.search_idx0 = GST_AV1_REF_GOLDEN_FRAME;
+    if (va_frame->ref_frame_idx[GST_AV1_REF_LAST_FRAME] != -1 &&
+        va_frame->ref_frame_idx[GST_AV1_REF_LAST_FRAME] !=
+        va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME])
+      pic_param->ref_frame_ctrl_l0.fields.search_idx1 = GST_AV1_REF_LAST_FRAME;
+    if (va_frame->ref_frame_idx[GST_AV1_REF_LAST2_FRAME] != -1 &&
+        va_frame->ref_frame_idx[GST_AV1_REF_LAST2_FRAME] !=
+        va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME])
+      pic_param->ref_frame_ctrl_l0.fields.search_idx2 = GST_AV1_REF_LAST2_FRAME;
+    if (va_frame->ref_frame_idx[GST_AV1_REF_LAST3_FRAME] != -1 &&
+        va_frame->ref_frame_idx[GST_AV1_REF_LAST3_FRAME] !=
+        va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME])
+      pic_param->ref_frame_ctrl_l0.fields.search_idx3 = GST_AV1_REF_LAST3_FRAME;
+
+    if (va_frame->bidir_ref) {
+      if (va_frame->ref_frame_idx[GST_AV1_REF_ALTREF_FRAME] != -1)
+        pic_param->ref_frame_ctrl_l1.fields.search_idx0 =
+            GST_AV1_REF_ALTREF_FRAME;
+      if (va_frame->ref_frame_idx[GST_AV1_REF_ALTREF2_FRAME] != -1 &&
+          va_frame->ref_frame_idx[GST_AV1_REF_ALTREF2_FRAME] !=
+          va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME])
+        pic_param->ref_frame_ctrl_l1.fields.search_idx1 =
+            GST_AV1_REF_ALTREF2_FRAME;
+      if (va_frame->ref_frame_idx[GST_AV1_REF_BWDREF_FRAME] != -1 &&
+          va_frame->ref_frame_idx[GST_AV1_REF_BWDREF_FRAME] !=
+          va_frame->ref_frame_idx[GST_AV1_REF_GOLDEN_FRAME])
+        pic_param->ref_frame_ctrl_l1.fields.search_idx2 =
+            GST_AV1_REF_BWDREF_FRAME;
+    }
+  } else {
+    for (i = 0; i < 8; i++)
+      pic_param->reference_frames[i] = VA_INVALID_SURFACE;
+    for (i = 0; i < 7; i++)
+      pic_param->ref_frame_idx[i] = 0xFF;
+  }
+
+  return TRUE;
+}
+
+/* 5.9.3 */
+static gint
+_av1_get_relative_dist (GstAV1SequenceHeaderOBU * seq_header, gint a, gint b)
+{
+  gint m, diff;
+  if (!seq_header->enable_order_hint)
+    return 0;
+
+  diff = a - b;
+  m = 1 << seq_header->order_hint_bits_minus_1;
+  diff = (diff & (m - 1)) - (diff & m);
+  return diff;
+}
+
+/* We need to calculate whether the skip mode is available */
+static void
+_av1_set_skip_mode_frame (GstVaAV1Enc * self, GstVaAV1EncFrame * va_frame,
+    GstAV1FrameHeaderOBU * frame_hdr)
+{
+  GstAV1SequenceHeaderOBU *seq_header;
+  gint skip_mode_allowed /* skipModeAllowed */ ;
+  GstVideoCodecFrame *ref_frame;
+  guint i;
+
+  seq_header = &self->sequence_hdr;
+  skip_mode_allowed = 0;
+
+  if (frame_hdr->frame_is_intra || !frame_hdr->reference_select
+      || !seq_header->enable_order_hint) {
+    skip_mode_allowed = 0;
+  } else {
+    gint forward_idx = -1 /* forwardIdx */ ;
+    gint forward_hint = 0 /* forwardHint */ ;
+    gint backward_idx = -1 /* backwardIdx */ ;
+    gint backward_hint = 0 /* backwardHint */ ;
+    gint ref_hint = 0 /* refHint */ ;
+
+    for (i = 0; i < GST_AV1_REFS_PER_FRAME; i++) {
+      ref_frame = self->gop.ref_list[va_frame->ref_frame_idx[i +
+              GST_AV1_REF_LAST_FRAME]];
+      g_assert (ref_frame);
+      ref_hint = _enc_frame (ref_frame)->order_hint;
+
+      if (_av1_get_relative_dist (seq_header, ref_hint,
+              frame_hdr->order_hint) < 0) {
+        if (forward_idx < 0 || _av1_get_relative_dist (seq_header, ref_hint,
+                forward_hint) > 0) {
+          forward_idx = i;
+          forward_hint = ref_hint;
+        }
+      } else
+          if (_av1_get_relative_dist (seq_header, ref_hint,
+              frame_hdr->order_hint) > 0) {
+        if (backward_idx < 0 || _av1_get_relative_dist (seq_header, ref_hint,
+                backward_hint) < 0) {
+          backward_idx = i;
+          backward_hint = ref_hint;
+        }
+      }
+    }
+
+    if (forward_idx < 0) {
+      skip_mode_allowed = 0;
+    } else if (backward_idx >= 0) {
+      skip_mode_allowed = 1;
+      frame_hdr->skip_mode_frame[0] =
+          GST_AV1_REF_LAST_FRAME + MIN (forward_idx, backward_idx);
+      frame_hdr->skip_mode_frame[1] =
+          GST_AV1_REF_LAST_FRAME + MAX (forward_idx, backward_idx);
+    } else {
+      gint second_forward_idx = -1 /* secondForwardIdx */ ;
+      gint second_forward_hint = 0 /* secondForwardHint */ ;
+
+      for (i = 0; i < GST_AV1_REFS_PER_FRAME; i++) {
+        ref_frame = self->gop.ref_list[va_frame->ref_frame_idx[i +
+                GST_AV1_REF_LAST_FRAME]];
+        g_assert (ref_frame);
+        ref_hint = _enc_frame (ref_frame)->order_hint;
+
+        if (_av1_get_relative_dist (seq_header, ref_hint, forward_hint) < 0) {
+          if (second_forward_idx < 0 || _av1_get_relative_dist (seq_header,
+                  ref_hint, second_forward_hint) > 0) {
+            second_forward_idx = i;
+            second_forward_hint = ref_hint;
+          }
+        }
+      }
+
+      if (second_forward_idx < 0) {
+        skip_mode_allowed = 0;
+      } else {
+        skip_mode_allowed = 1;
+        frame_hdr->skip_mode_frame[0] =
+            GST_AV1_REF_LAST_FRAME + MIN (forward_idx, second_forward_idx);
+        frame_hdr->skip_mode_frame[1] =
+            GST_AV1_REF_LAST_FRAME + MAX (forward_idx, second_forward_idx);
+      }
+    }
+  }
+
+  if (skip_mode_allowed) {
+    g_assert (frame_hdr->skip_mode_frame[0] > 0 &&
+        frame_hdr->skip_mode_frame[1] > 0);
+  } else {
+    frame_hdr->skip_mode_frame[0] = 0;
+    frame_hdr->skip_mode_frame[1] = 0;
+  }
+}
+
+static void
+_av1_fill_frame_header (GstVaAV1Enc * self,
+    VAEncPictureParameterBufferAV1 * pic_param,
+    GstAV1FrameHeaderOBU * frame_hdr, GstVaAV1EncFrame * va_frame)
+{
+  guint i;
+  guint8 frame_is_intra = (va_frame->type == GST_AV1_INTRA_ONLY_FRAME
+      || va_frame->type == GST_AV1_KEY_FRAME);
+
+  /* *INDENT-OFF* */
+  *frame_hdr = (GstAV1FrameHeaderOBU) {
+    .frame_is_intra = frame_is_intra,
+    .show_existing_frame = 0,
+    .frame_type = va_frame->type,
+    .show_frame = !(va_frame->flags & FRAME_FLAG_NOT_SHOW),
+    .showable_frame = 1,
+    .error_resilient_mode = pic_param->picture_flags.bits.error_resilient_mode,
+    .disable_cdf_update = pic_param->picture_flags.bits.disable_cdf_update,
+    .allow_screen_content_tools = 0,
+    .frame_size_override_flag = 0,
+    .frame_width = self->sequence_hdr.max_frame_width_minus_1 + 1,
+    .frame_height = self->sequence_hdr.max_frame_height_minus_1 + 1,
+    .order_hint = pic_param->order_hint,
+    .primary_ref_frame = pic_param->primary_ref_frame,
+    .buffer_removal_time_present_flag = 0,
+    .refresh_frame_flags = pic_param->refresh_frame_flags,
+    .allow_intrabc = pic_param->picture_flags.bits.allow_intrabc,
+    .frame_refs_short_signaling = 0,
+    /* Set it later. */
+    .ref_frame_idx = { },
+    .allow_high_precision_mv =
+        pic_param->picture_flags.bits.allow_high_precision_mv,
+    .is_motion_mode_switchable = 0,
+    .use_ref_frame_mvs = pic_param->picture_flags.bits.use_ref_frame_mvs,
+    .disable_frame_end_update_cdf =
+        pic_param->picture_flags.bits.disable_frame_end_update_cdf,
+    .allow_warped_motion = self->features.enable_warped_motion,
+    .reduced_tx_set = pic_param->picture_flags.bits.reduced_tx_set,
+    .render_and_frame_size_different = 0,
+    .use_superres = pic_param->picture_flags.bits.use_superres,
+    .is_filter_switchable = (pic_param->interpolation_filter ==
+        GST_AV1_INTERPOLATION_FILTER_SWITCHABLE),
+    .interpolation_filter = pic_param->interpolation_filter,
+    .loop_filter_params = {
+      .loop_filter_level[0] = pic_param->filter_level[0],
+      .loop_filter_level[1] = pic_param->filter_level[1],
+      .loop_filter_level[2] = pic_param->filter_level_u,
+      .loop_filter_level[3] = pic_param->filter_level_v,
+      .loop_filter_sharpness =
+          pic_param->loop_filter_flags.bits.sharpness_level,
+      .loop_filter_delta_enabled =
+          pic_param->loop_filter_flags.bits.mode_ref_delta_enabled,
+      .loop_filter_delta_update =
+          pic_param->loop_filter_flags.bits.mode_ref_delta_update,
+      /* Set it later. */
+      .loop_filter_ref_deltas = { },
+      .loop_filter_mode_deltas = { },
+      .delta_lf_present = pic_param->mode_control_flags.bits.delta_lf_present,
+      .delta_lf_res = pic_param->mode_control_flags.bits.delta_lf_res,
+      .delta_lf_multi = pic_param->mode_control_flags.bits.delta_lf_multi,
+    },
+    .quantization_params = {
+      .base_q_idx = pic_param->base_qindex,
+      .diff_uv_delta = 0,
+      .using_qmatrix = pic_param->qmatrix_flags.bits.using_qmatrix,
+      .qm_y = pic_param->qmatrix_flags.bits.qm_y,
+      .qm_u = pic_param->qmatrix_flags.bits.qm_u,
+      .qm_v = pic_param->qmatrix_flags.bits.qm_v,
+      .delta_q_present = pic_param->mode_control_flags.bits.delta_q_present,
+      .delta_q_res = pic_param->mode_control_flags.bits.delta_q_res,
+      .delta_q_y_dc = pic_param->y_dc_delta_q,
+      .delta_q_u_dc = pic_param->u_dc_delta_q,
+      .delta_q_u_ac = pic_param->u_ac_delta_q,
+      .delta_q_v_dc = pic_param->v_dc_delta_q,
+      .delta_q_v_ac = pic_param->v_ac_delta_q,
+    },
+    .segmentation_params = {
+      /* Not enabled. */
+      .segmentation_enabled =
+          pic_param->segments.seg_flags.bits.segmentation_enabled,
+    },
+    .tile_info = {
+      .uniform_tile_spacing_flag = 1,
+      .tile_cols_log2 = self->partition.tile_cols_log2,
+      .tile_rows_log2 = self->partition.tile_rows_log2,
+      .context_update_tile_id = 0,
+      .tile_size_bytes_minus_1 = self->partition.tile_size_bytes_minus_1,
+    },
+    .cdef_params = {
+      .cdef_damping = pic_param->cdef_damping_minus_3 + 3,
+      .cdef_bits = pic_param->cdef_bits,
+      /* Only set to 0. */
+      .cdef_y_pri_strength = { },
+      .cdef_y_sec_strength = { },
+      .cdef_uv_pri_strength = { },
+      .cdef_uv_sec_strength = { },
+    },
+    /* TODO: disable seq->enable_restoration now. */
+    .loop_restoration_params = {
+    },
+    .tx_mode = pic_param->mode_control_flags.bits.tx_mode,
+    .skip_mode_present = pic_param->mode_control_flags.bits.skip_mode_present,
+    .reference_select = pic_param->mode_control_flags.bits.reference_mode != 0,
+    /* warped motion is not supported. */
+    .global_motion_params = {
+      .gm_type = {
+        GST_AV1_WARP_MODEL_IDENTITY,
+        GST_AV1_WARP_MODEL_IDENTITY,
+        GST_AV1_WARP_MODEL_IDENTITY,
+        GST_AV1_WARP_MODEL_IDENTITY,
+        GST_AV1_WARP_MODEL_IDENTITY,
+        GST_AV1_WARP_MODEL_IDENTITY,
+        GST_AV1_WARP_MODEL_IDENTITY,
+        GST_AV1_WARP_MODEL_IDENTITY
+      },
+    },
+    /* film grain is not supported. */
+    .film_grain_params = {
+      .apply_grain = FALSE,
+    },
+  };
+  /* *INDENT-ON* */
+
+  _av1_set_skip_mode_frame (self, va_frame, frame_hdr);
+
+  for (i = 0; i < GST_AV1_REFS_PER_FRAME; i++)
+    frame_hdr->ref_frame_idx[i] = pic_param->ref_frame_idx[i];
+
+  for (i = 0; i < GST_AV1_REFS_PER_FRAME; i++)
+    frame_hdr->loop_filter_params.loop_filter_ref_deltas[i] =
+        pic_param->ref_deltas[i];
+  for (i = 0; i < 2; i++)
+    frame_hdr->loop_filter_params.loop_filter_mode_deltas[i] =
+        pic_param->mode_deltas[i];
+}
+
+static gboolean
+_av1_add_tile_group_param (GstVaAV1Enc * self, GstVaAV1EncFrame * va_frame,
+    guint index)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  VAEncTileGroupBufferAV1 tile_group_param;
+  guint div;
+
+  div = self->partition.num_tile_cols * self->partition.num_tile_rows /
+      self->partition.tile_groups;
+
+  tile_group_param.tg_start = div * index;
+
+  if (index == self->partition.tile_groups - 1) {
+    tile_group_param.tg_end =
+        self->partition.num_tile_cols * self->partition.num_tile_rows - 1;
+  } else {
+    tile_group_param.tg_end = (index + 1) * div - 1;
+  }
+
+  if (!gst_va_encoder_add_param (base->encoder, va_frame->picture,
+          VAEncSliceParameterBufferType, &tile_group_param,
+          sizeof (VAEncTileGroupBufferAV1))) {
+    GST_ERROR_OBJECT (self, "Failed to add one tile group parameter");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+_av1_encode_one_frame (GstVaAV1Enc * self, GstVaAV1EncFrame * va_frame,
+    guint size_offset)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  VAEncPictureParameterBufferAV1 pic_param;
+  GstAV1FrameHeaderOBU frame_hdr;
+  guint frame_hdr_size;
+  guint8 packed_frame_hdr[512] = { 0, };
+  guint i;
+
+  va_frame->order_hint = va_frame->frame_num;
+
+  if (!_av1_fill_frame_param (self, va_frame, &pic_param)) {
+    GST_ERROR_OBJECT (self, "Fails to fill the frame parameter.");
+    return FALSE;
+  }
+
+  _av1_fill_frame_header (self, &pic_param, &frame_hdr, va_frame);
+
+  frame_hdr_size = sizeof (packed_frame_hdr);
+  if (self->rc.rc_ctrl_mode == VA_RC_CQP) {
+    if (gst_av1_bit_writer_frame_header_obu (&frame_hdr,
+            &self->sequence_hdr, va_frame->temporal_id, va_frame->spatial_id,
+            TRUE, packed_frame_hdr, &frame_hdr_size)
+        != GST_AV1_BIT_WRITER_OK) {
+      GST_ERROR_OBJECT (self, "Failed to write frame header.");
+      return FALSE;
+    }
+  } else {
+    guint qindex_offset = 0;
+    guint segmentation_offset = 0;
+    guint loopfilter_offset = 0;
+    guint cdef_offset = 0;
+    guint cdef_size_in_bits;
+
+    /* For rate control modes, the driver needs to adjust the values of
+       qindex, loop filter, etc. The accroding fields of frame header are
+       modified by the driver. And so the total frame header size may
+       also change and need rewrite. */
+    if (gst_av1_bit_writer_frame_header_obu_with_offsets (&frame_hdr,
+            &self->sequence_hdr, va_frame->temporal_id, va_frame->spatial_id,
+            self->features.obu_size_bytes, &qindex_offset, &segmentation_offset,
+            &loopfilter_offset, &cdef_offset, packed_frame_hdr, &frame_hdr_size)
+        != GST_AV1_BIT_WRITER_OK) {
+      GST_ERROR_OBJECT (self, "Failed to write frame header.");
+      return FALSE;
+    }
+
+    /* Fix all the offsets based on the packed frame header */
+    pic_param.bit_offset_qindex = qindex_offset;
+    if (pic_param.segments.seg_flags.bits.segmentation_enabled)
+      pic_param.bit_offset_segmentation = segmentation_offset;
+    pic_param.bit_offset_loopfilter_params = loopfilter_offset;
+    pic_param.bit_offset_cdef_params = cdef_offset;
+    cdef_size_in_bits = 2 + 2 + (1 << frame_hdr.cdef_params.cdef_bits) *
+        (4 + 2 + (self->sequence_hdr.num_planes > 1 ? (4 + 2) : 0));
+    pic_param.size_in_bits_cdef_params = cdef_size_in_bits;
+    pic_param.byte_offset_frame_hdr_obu_size = size_offset + 1 +
+        /* OBU extension header */
+        (va_frame->temporal_id > 0 || va_frame->spatial_id > 0);
+    pic_param.size_in_bits_frame_hdr_obu = frame_hdr_size * 8;
+  }
+
+  if (!gst_va_encoder_add_param (base->encoder, va_frame->picture,
+          VAEncPictureParameterBufferType, &pic_param, sizeof (pic_param))) {
+    GST_ERROR_OBJECT (self, "Failed to create the frame parameter");
+    return FALSE;
+  }
+
+  if (!gst_va_encoder_add_packed_header (base->encoder, va_frame->picture,
+          VAEncPackedHeaderPicture, packed_frame_hdr, frame_hdr_size * 8,
+          FALSE)) {
+    GST_ERROR_OBJECT (self, "Failed to add the packed frame header");
+    return FALSE;
+  }
+
+  for (i = 0; i < self->partition.tile_groups; i++) {
+    if (!_av1_add_tile_group_param (self, va_frame, i)) {
+      GST_ERROR_OBJECT (self, "Failed to add tile groups");
+      return FALSE;
+    }
+  }
+
+  if (!gst_va_encoder_encode (base->encoder, va_frame->picture)) {
+    GST_ERROR_OBJECT (self, "Encode frame error");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static void
+_av1_add_repeat_frame_header (GstVaAV1Enc * self, GstVaAV1EncFrame * va_frame)
+{
+  GstAV1FrameHeaderOBU frame_hdr = { };
+  guint td_data_size;
+  guint frame_hdr_data_size;
+
+  memset (va_frame->repeat_frame_header, 0,
+      sizeof (va_frame->repeat_frame_header));
+
+  /* Repeat frame always shows a frame and so begins with a TD. */
+  td_data_size = sizeof (va_frame->repeat_frame_header);
+  if (gst_av1_bit_writer_temporal_delimiter_obu (TRUE,
+          va_frame->repeat_frame_header,
+          &td_data_size) != GST_AV1_BIT_WRITER_OK) {
+    GST_ERROR_OBJECT (self, "Failed to write temporal delimiter.");
+    g_assert_not_reached ();
+  }
+
+  frame_hdr.show_existing_frame = 1;
+  frame_hdr.frame_to_show_map_idx = va_frame->repeat_index;
+  frame_hdr_data_size = sizeof (va_frame->repeat_frame_header) - td_data_size;
+  if (gst_av1_bit_writer_frame_header_obu (&frame_hdr, &self->sequence_hdr,
+          va_frame->temporal_id, va_frame->spatial_id, TRUE,
+          va_frame->repeat_frame_header + td_data_size, &frame_hdr_data_size)
+      != GST_AV1_BIT_WRITER_OK) {
+    GST_ERROR_OBJECT (self, "Failed to write repeat frame header.");
+    g_assert_not_reached ();
+  }
+
+  va_frame->repeat_frame_header_size = td_data_size + frame_hdr_data_size;
+}
+
+static gboolean
+_av1_add_td (GstVaAV1Enc * self, GstVaAV1EncFrame * frame, guint * size_offset)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint8 td_data[16] = { };
+  guint td_data_size = sizeof (td_data);
+
+  if (gst_av1_bit_writer_temporal_delimiter_obu (TRUE, td_data,
+          &td_data_size) != GST_AV1_BIT_WRITER_OK) {
+    GST_ERROR_OBJECT (self, "Failed to write temporal delimiter.");
+    g_assert_not_reached ();
+    return FALSE;
+  }
+
+  *size_offset += td_data_size;
+
+  if (!gst_va_encoder_add_packed_header (base->encoder, frame->picture,
+          VAEncPackedHeaderRawData, td_data, td_data_size * 8, FALSE)) {
+    GST_ERROR_OBJECT (self, "Failed to add the temporal delimiter.");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static GstFlowReturn
+gst_va_av1_enc_encode_frame (GstVaBaseEnc * base,
+    GstVideoCodecFrame * gst_frame, gboolean is_last)
+{
+  GstVaAV1Enc *self = GST_VA_AV1_ENC (base);
+  GstVaAV1EncFrame *va_frame = _enc_frame (gst_frame);
+  VAEncSequenceParameterBufferAV1 seq_param;
+
+  if (!_av1_assign_ref_index (self, gst_frame)) {
+    GST_ERROR_OBJECT (self, "Failed to assign reference for frame:"
+        "system_frame_number %d, frame_num: %d, frame_type %s",
+        gst_frame->system_frame_number, va_frame->frame_num,
+        _av1_get_frame_type_name (va_frame->type));
+    return GST_FLOW_ERROR;
+  }
+
+  if (va_frame->type & FRAME_TYPE_REPEAT) {
+    g_assert (va_frame->flags & FRAME_FLAG_ALREADY_ENCODED);
+    _av1_add_repeat_frame_header (self, va_frame);
+  } else {
+    guint size_offset = 0;
+
+    g_assert (va_frame->picture == NULL);
+    va_frame->picture = gst_va_encode_picture_new (base->encoder,
+        gst_frame->input_buffer);
+
+    _av1_find_ref_to_update (base, gst_frame);
+
+    if (!(va_frame->flags & FRAME_FLAG_NOT_SHOW)) {
+      if (!_av1_add_td (self, va_frame, &size_offset))
+        return FALSE;
+    }
+
+    /* Repeat the sequence for each key. */
+    if (va_frame->frame_num == 0) {
+      if (!gst_va_base_enc_add_rate_control_parameter (base, va_frame->picture,
+              self->rc.rc_ctrl_mode, self->rc.max_bitrate_bits,
+              self->rc.target_percentage, self->rc.base_qindex,
+              self->rc.min_qindex, self->rc.max_qindex, self->rc.mbbrc))
+        return FALSE;
+
+      if (!gst_va_base_enc_add_quality_level_parameter (base, va_frame->picture,
+              self->rc.target_usage))
+        return FALSE;
+
+      if (!gst_va_base_enc_add_frame_rate_parameter (base, va_frame->picture))
+        return FALSE;
+
+      if (!gst_va_base_enc_add_hrd_parameter (base, va_frame->picture,
+              self->rc.rc_ctrl_mode, self->rc.cpb_length_bits))
+        return FALSE;
+
+      _av1_fill_sequence_param (self, &seq_param);
+      if (!_av1_add_sequence_param (self, va_frame->picture, &seq_param))
+        return FALSE;
+
+      _av1_fill_sequence_header (self, &seq_param);
+      if (!_av1_add_sequence_header (self, va_frame, &size_offset))
+        return FALSE;
+    }
+
+    if (!_av1_encode_one_frame (self, va_frame, size_offset)) {
+      GST_ERROR_OBJECT (self, "Fails to encode one frame.");
+      return GST_FLOW_ERROR;
+    }
+
+    va_frame->flags |= FRAME_FLAG_ALREADY_ENCODED;
+  }
+
+  _av1_update_ref_list (base, gst_frame);
+
+  g_queue_push_tail (&base->output_list, gst_video_codec_frame_ref (gst_frame));
+
+  return GST_FLOW_OK;
+}
+
+static gboolean
+gst_va_av1_enc_prepare_output (GstVaBaseEnc * base,
+    GstVideoCodecFrame * frame, gboolean * complete)
+{
+  GstVaAV1Enc *self = GST_VA_AV1_ENC (base);
+  GstVaAV1EncFrame *frame_enc;
+  GstBuffer *buf = NULL;
+
+  frame_enc = _enc_frame (frame);
+
+  if (frame_enc->flags & FRAME_FLAG_NOT_SHOW &&
+      ((frame_enc->type & FRAME_TYPE_REPEAT) == 0)) {
+    frame->pts = self->last_pts;
+    frame->dts = self->last_dts;
+    frame->duration = GST_CLOCK_TIME_NONE;
+  } else {
+    frame->pts =
+        base->start_pts + base->frame_duration * frame_enc->total_frame_count;
+    /* The PTS should always be later than the DTS. */
+    frame->dts = frame->pts - base->frame_duration;
+    base->output_frame_count++;
+    frame->duration = base->frame_duration;
+
+    self->last_pts = frame->pts;
+    self->last_dts = frame->dts;
+  }
+
+  if (frame_enc->flags & FRAME_FLAG_ALREADY_OUTPUTTED) {
+    gsize sz;
+
+    /* Already outputted, must be a repeat this time. */
+    g_assert (frame_enc->type & FRAME_TYPE_REPEAT);
+
+    buf = gst_video_encoder_allocate_output_buffer
+        (GST_VIDEO_ENCODER_CAST (base), frame_enc->repeat_frame_header_size);
+    if (!buf) {
+      GST_ERROR_OBJECT (base, "Failed to create output buffer");
+      return FALSE;
+    }
+
+    sz = gst_buffer_fill (buf, 0, frame_enc->repeat_frame_header,
+        frame_enc->repeat_frame_header_size);
+
+    if (sz != frame_enc->repeat_frame_header_size) {
+      GST_ERROR_OBJECT (base, "Failed to write output buffer for repeat frame");
+      gst_clear_buffer (&buf);
+      return FALSE;
+    }
+
+    *complete = TRUE;
+  } else {
+    buf = gst_va_base_enc_create_output_buffer (base, frame_enc->picture);
+    if (!buf) {
+      GST_ERROR_OBJECT (base, "Failed to create output buffer");
+      return FALSE;
+    }
+
+    /* If no show frame, the later repeat will complete this frame. */
+    if (frame_enc->flags & FRAME_FLAG_NOT_SHOW) {
+      *complete = FALSE;
+    } else {
+      *complete = TRUE;
+    }
+
+    frame_enc->flags |= FRAME_FLAG_ALREADY_OUTPUTTED;
+  }
+
+  gst_buffer_replace (&frame->output_buffer, buf);
+  gst_clear_buffer (&buf);
+
+  return TRUE;
+}
+
+/* *INDENT-OFF* */
+static const gchar *sink_caps_str =
+    GST_VIDEO_CAPS_MAKE_WITH_FEATURES (GST_CAPS_FEATURE_MEMORY_VA,
+        "{ NV12 }") " ;"
+    GST_VIDEO_CAPS_MAKE ("{ NV12 }");
+/* *INDENT-ON* */
+
+static const gchar *src_caps_str = "video/x-av1,alignment=(string)frame,"
+    "stream-format=(string)obu-stream";
+
+static gpointer
+_register_debug_category (gpointer data)
+{
+  GST_DEBUG_CATEGORY_INIT (gst_va_av1enc_debug, "vaav1enc", 0,
+      "VA av1 encoder");
+
+  return NULL;
+}
+
+static void
+gst_va_av1_enc_init (GTypeInstance * instance, gpointer g_class)
+{
+  GstVaAV1Enc *self = GST_VA_AV1_ENC (instance);
+
+  /* default values */
+  self->prop.bitrate = 0;
+  self->prop.target_usage = 4;
+  self->prop.cpb_size = 0;
+  self->prop.target_percentage = 66;
+  self->prop.gf_group_size = MAX_GF_GROUP_SIZE;
+  self->prop.num_ref_frames = 7;
+  self->prop.max_hierarchical_level = HIGHEST_PYRAMID_LEVELS;
+  self->prop.use_128x128_superblock = FALSE;
+  self->prop.keyframe_interval = MAX_KEY_FRAME_INTERVAL;
+  self->prop.qp = DEFAULT_BASE_QINDEX;
+  self->prop.min_qp = 0;
+  self->prop.max_qp = 255;
+  self->prop.num_tile_cols = 1;
+  self->prop.num_tile_rows = 1;
+  self->prop.tile_groups = 1;
+  self->prop.mbbrc = 0;
+
+  if (properties[PROP_RATE_CONTROL]) {
+    self->prop.rc_ctrl =
+        G_PARAM_SPEC_ENUM (properties[PROP_RATE_CONTROL])->default_value;
+  } else {
+    self->prop.rc_ctrl = VA_RC_NONE;
+  }
+}
+
+static void
+gst_va_av1_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstVaAV1Enc *const self = GST_VA_AV1_ENC (object);
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+
+  if (base->encoder && gst_va_encoder_is_open (base->encoder)) {
+    GST_ERROR_OBJECT (object,
+        "failed to set any property after encoding started");
+    return;
+  }
+
+  GST_OBJECT_LOCK (self);
+
+  switch (prop_id) {
+    case PROP_KEYFRAME_INT:
+      self->prop.keyframe_interval = g_value_get_uint (value);
+      break;
+    case PROP_GOLDEN_GROUP_SIZE:
+      self->prop.gf_group_size = g_value_get_uint (value);
+      break;
+    case PROP_NUM_REF_FRAMES:
+      self->prop.num_ref_frames = g_value_get_uint (value);
+      break;
+    case PROP_HIERARCHICAL_LEVEL:
+      self->prop.max_hierarchical_level = g_value_get_uint (value);
+      break;
+    case PROP_128X128_SUPERBLOCK:
+      self->prop.use_128x128_superblock = g_value_get_boolean (value);
+      break;
+    case PROP_QP:
+      self->prop.qp = g_value_get_uint (value);
+      break;
+    case PROP_MAX_QP:
+      self->prop.max_qp = g_value_get_uint (value);
+      break;
+    case PROP_MIN_QP:
+      self->prop.min_qp = g_value_get_uint (value);
+      break;
+    case PROP_BITRATE:
+      self->prop.bitrate = g_value_get_uint (value);
+      break;
+    case PROP_NUM_TILE_COLS:
+      self->prop.num_tile_cols = g_value_get_uint (value);
+      break;
+    case PROP_NUM_TILE_ROWS:
+      self->prop.num_tile_rows = g_value_get_uint (value);
+      break;
+    case PROP_TILE_GROUPS:
+      self->prop.tile_groups = g_value_get_uint (value);
+      break;
+    case PROP_TARGET_USAGE:
+      self->prop.target_usage = g_value_get_uint (value);
+      break;
+    case PROP_TARGET_PERCENTAGE:
+      self->prop.target_percentage = g_value_get_uint (value);
+      break;
+    case PROP_CPB_SIZE:
+      self->prop.cpb_size = g_value_get_uint (value);
+      break;
+    case PROP_RATE_CONTROL:
+      self->prop.rc_ctrl = g_value_get_enum (value);
+      break;
+    case PROP_MBBRC:{
+      /* Macroblock-level rate control.
+       * 0: use default,
+       * 1: always enable,
+       * 2: always disable,
+       * other: reserved. */
+      switch (g_value_get_enum (value)) {
+        case GST_VA_FEATURE_DISABLED:
+          self->prop.mbbrc = 2;
+          break;
+        case GST_VA_FEATURE_ENABLED:
+          self->prop.mbbrc = 1;
+          break;
+        case GST_VA_FEATURE_AUTO:
+          self->prop.mbbrc = 0;
+          break;
+      }
+      break;
+    }
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+  }
+
+  GST_OBJECT_UNLOCK (self);
+}
+
+static void
+gst_va_av1_enc_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstVaAV1Enc *const self = GST_VA_AV1_ENC (object);
+
+  GST_OBJECT_LOCK (self);
+
+  switch (prop_id) {
+    case PROP_KEYFRAME_INT:
+      g_value_set_uint (value, self->prop.keyframe_interval);
+      break;
+    case PROP_GOLDEN_GROUP_SIZE:
+      g_value_set_uint (value, self->prop.gf_group_size);
+      break;
+    case PROP_NUM_REF_FRAMES:
+      g_value_set_uint (value, self->prop.num_ref_frames);
+      break;
+    case PROP_HIERARCHICAL_LEVEL:
+      g_value_set_uint (value, self->prop.max_hierarchical_level);
+      break;
+    case PROP_128X128_SUPERBLOCK:
+      g_value_set_boolean (value, self->prop.use_128x128_superblock);
+      break;
+    case PROP_QP:
+      g_value_set_uint (value, self->prop.qp);
+      break;
+    case PROP_MIN_QP:
+      g_value_set_uint (value, self->prop.min_qp);
+      break;
+    case PROP_MAX_QP:
+      g_value_set_uint (value, self->prop.max_qp);
+      break;
+    case PROP_NUM_TILE_COLS:
+      g_value_set_uint (value, self->prop.num_tile_cols);
+      break;
+    case PROP_NUM_TILE_ROWS:
+      g_value_set_uint (value, self->prop.num_tile_rows);
+      break;
+    case PROP_TILE_GROUPS:
+      g_value_set_uint (value, self->prop.tile_groups);
+      break;
+    case PROP_BITRATE:
+      g_value_set_uint (value, self->prop.bitrate);
+      break;
+    case PROP_TARGET_USAGE:
+      g_value_set_uint (value, self->prop.target_usage);
+      break;
+    case PROP_TARGET_PERCENTAGE:
+      g_value_set_uint (value, self->prop.target_percentage);
+      break;
+    case PROP_CPB_SIZE:
+      g_value_set_uint (value, self->prop.cpb_size);
+      break;
+    case PROP_RATE_CONTROL:
+      g_value_set_enum (value, self->prop.rc_ctrl);
+      break;
+    case PROP_MBBRC:
+      g_value_set_enum (value, self->prop.mbbrc);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+  }
+
+  GST_OBJECT_UNLOCK (self);
+}
+
+static void
+gst_va_av1_enc_class_init (gpointer g_klass, gpointer class_data)
+{
+  GstCaps *src_doc_caps, *sink_doc_caps;
+  GstPadTemplate *sink_pad_templ, *src_pad_templ;
+  GObjectClass *object_class = G_OBJECT_CLASS (g_klass);
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_klass);
+  GstVideoEncoderClass *venc_class = GST_VIDEO_ENCODER_CLASS (g_klass);
+  GstVaBaseEncClass *va_enc_class = GST_VA_BASE_ENC_CLASS (g_klass);
+  GstVaAV1EncClass *vaav1enc_class = GST_VA_AV1_ENC_CLASS (g_klass);
+  GstVaDisplay *display;
+  GstVaEncoder *encoder;
+  struct CData *cdata = class_data;
+  gchar *long_name;
+  const gchar *name, *desc;
+  gint n_props = N_PROPERTIES;
+
+  if (cdata->entrypoint == VAEntrypointEncSlice) {
+    desc = "VA-API based AV1 video encoder";
+    name = "VA-API AV1 Encoder";
+  } else {
+    desc = "VA-API based AV1 low power video encoder";
+    name = "VA-API AV1 Low Power Encoder";
+  }
+
+  if (cdata->description)
+    long_name = g_strdup_printf ("%s in %s", name, cdata->description);
+  else
+    long_name = g_strdup (name);
+
+  gst_element_class_set_metadata (element_class, long_name,
+      "Codec/Encoder/Video/Hardware", desc, "He Junyan <junyan.he@intel.com>");
+
+  sink_doc_caps = gst_caps_from_string (sink_caps_str);
+  src_doc_caps = gst_caps_from_string (src_caps_str);
+
+  parent_class = g_type_class_peek_parent (g_klass);
+
+  va_enc_class->codec = AV1;
+  va_enc_class->entrypoint = cdata->entrypoint;
+  va_enc_class->render_device_path = g_strdup (cdata->render_device_path);
+
+  sink_pad_templ = gst_pad_template_new ("sink", GST_PAD_SINK, GST_PAD_ALWAYS,
+      cdata->sink_caps);
+  gst_element_class_add_pad_template (element_class, sink_pad_templ);
+
+  gst_pad_template_set_documentation_caps (sink_pad_templ, sink_doc_caps);
+  gst_caps_unref (sink_doc_caps);
+
+  src_pad_templ = gst_pad_template_new ("src", GST_PAD_SRC, GST_PAD_ALWAYS,
+      cdata->src_caps);
+  gst_element_class_add_pad_template (element_class, src_pad_templ);
+
+  gst_pad_template_set_documentation_caps (src_pad_templ, src_doc_caps);
+  gst_caps_unref (src_doc_caps);
+
+  object_class->set_property = gst_va_av1_enc_set_property;
+  object_class->get_property = gst_va_av1_enc_get_property;
+
+  venc_class->flush = GST_DEBUG_FUNCPTR (gst_va_av1_enc_flush);
+  va_enc_class->reset_state = GST_DEBUG_FUNCPTR (gst_va_av1_enc_reset_state);
+  va_enc_class->reconfig = GST_DEBUG_FUNCPTR (gst_va_av1_enc_reconfig);
+  va_enc_class->new_frame = GST_DEBUG_FUNCPTR (gst_va_av1_enc_new_frame);
+  va_enc_class->reorder_frame =
+      GST_DEBUG_FUNCPTR (gst_va_av1_enc_reorder_frame);
+  va_enc_class->encode_frame = GST_DEBUG_FUNCPTR (gst_va_av1_enc_encode_frame);
+  va_enc_class->prepare_output =
+      GST_DEBUG_FUNCPTR (gst_va_av1_enc_prepare_output);
+
+  {
+    display =
+        gst_va_display_drm_new_from_path (va_enc_class->render_device_path);
+    encoder = gst_va_encoder_new (display, va_enc_class->codec,
+        va_enc_class->entrypoint);
+    if (gst_va_encoder_get_rate_control_enum (encoder,
+            vaav1enc_class->rate_control)) {
+      g_snprintf (vaav1enc_class->rate_control_type_name,
+          G_N_ELEMENTS (vaav1enc_class->rate_control_type_name) - 1,
+          "GstVaEncoderRateControl_%" GST_FOURCC_FORMAT "%s_%s",
+          GST_FOURCC_ARGS (va_enc_class->codec),
+          (va_enc_class->entrypoint == VAEntrypointEncSliceLP) ? "_LP" : "",
+          g_path_get_basename (va_enc_class->render_device_path));
+      vaav1enc_class->rate_control_type =
+          g_enum_register_static (vaav1enc_class->rate_control_type_name,
+          vaav1enc_class->rate_control);
+      gst_type_mark_as_plugin_api (vaav1enc_class->rate_control_type, 0);
+    }
+    gst_object_unref (encoder);
+    gst_object_unref (display);
+  }
+
+  g_free (long_name);
+  g_free (cdata->description);
+  g_free (cdata->render_device_path);
+  gst_caps_unref (cdata->src_caps);
+  gst_caps_unref (cdata->sink_caps);
+  g_free (cdata);
+
+  /**
+   * GstVaAV1Enc:key-int-max:
+   *
+   * The maximal distance between two keyframes.
+   */
+  properties[PROP_KEYFRAME_INT] = g_param_spec_uint ("key-int-max",
+      "Key frame maximal interval",
+      "The maximal distance between two keyframes. It decides the size of GOP"
+      " (0: auto-calculate)", 0, MAX_KEY_FRAME_INTERVAL, 60,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:gf-group-size:
+   *
+   * The size of the golden frame group.
+   */
+  properties[PROP_GOLDEN_GROUP_SIZE] = g_param_spec_uint ("gf-group-size",
+      "Golden frame group size",
+      "The size of the golden frame group.",
+      1, MAX_GF_GROUP_SIZE, MAX_GF_GROUP_SIZE,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:ref-frames:
+   *
+   * The number of reference frames.
+   */
+  properties[PROP_NUM_REF_FRAMES] = g_param_spec_uint ("ref-frames",
+      "Number of Reference Frames",
+      "Number of reference frames, including both the forward and the backward",
+      0, 7, 7, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:hierarchical-level:
+   *
+   * The hierarchical level for golden frame group.
+   */
+  properties[PROP_HIERARCHICAL_LEVEL] =
+      g_param_spec_uint ("hierarchical-level", "The hierarchical level",
+      "The hierarchical level for golden frame group. Setting to 1 disables "
+      "all future reference", 1, HIGHEST_PYRAMID_LEVELS,
+      HIGHEST_PYRAMID_LEVELS,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:superblock-128x128:
+   *
+   * Enable the 128x128 superblock mode.
+   */
+  properties[PROP_128X128_SUPERBLOCK] =
+      g_param_spec_boolean ("superblock-128x128", "128x128 superblock",
+      "Enable the 128x128 superblock mode", FALSE,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:min-qp:
+   *
+   * The minimum quantizer value.
+   */
+  properties[PROP_MIN_QP] = g_param_spec_uint ("min-qp", "Minimum QP",
+      "Minimum quantizer value for each frame", 0, 255, 0,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:max-qp:
+   *
+   * The maximum quantizer value.
+   */
+  properties[PROP_MAX_QP] = g_param_spec_uint ("max-qp", "Maximum QP",
+      "Maximum quantizer value for each frame", 1, 255, 255,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:qp:
+   *
+   * The basic quantizer value for all frames.
+   */
+  properties[PROP_QP] = g_param_spec_uint ("qp", "The frame QP",
+      "The basic quantizer value for all frames.", 0, 255, DEFAULT_BASE_QINDEX,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:bitrate:
+   *
+   * The desired target bitrate, expressed in kbps.
+   * This is not available in CQP mode.
+   *
+   * CBR: This applies equally to the minimum, maximum and target bitrate.
+   * VBR: This applies to the target bitrate. The driver will use the
+   * "target-percentage" together to calculate the minimum and maximum bitrate.
+   * VCM: This applies to the target bitrate. The minimum and maximum bitrate
+   * are not needed.
+   */
+  properties[PROP_BITRATE] = g_param_spec_uint ("bitrate", "Bitrate (kbps)",
+      "The desired bitrate expressed in kbps (0: auto-calculate)",
+      0, 2000 * 1024, 0,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:target-percentage:
+   *
+   * The target percentage of the max bitrate, and expressed in uint,
+   * equal to "target percentage"*100.
+   * "target percentage" = "target bitrate" * 100 / "max bitrate"
+   * This is available only when rate-control is VBR.
+   * The driver uses it to calculate the minimum and maximum bitrate.
+   */
+  properties[PROP_TARGET_PERCENTAGE] = g_param_spec_uint ("target-percentage",
+      "target bitrate percentage",
+      "The percentage for 'target bitrate'/'maximum bitrate' (Only in VBR)",
+      50, 100, 66,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:cpb-size:
+   *
+   * The desired max CPB size in Kb (0: auto-calculate).
+   */
+  properties[PROP_CPB_SIZE] = g_param_spec_uint ("cpb-size",
+      "max CPB size in Kb",
+      "The desired max CPB size in Kb (0: auto-calculate)", 0, 2000 * 1024, 0,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:target-usage:
+   *
+   * The target usage of the encoder. It controls and balances the encoding
+   * speed and the encoding quality. The lower value has better quality but
+   * slower speed, the higher value has faster speed but lower quality.
+   */
+  properties[PROP_TARGET_USAGE] = g_param_spec_uint ("target-usage",
+      "target usage",
+      "The target usage to control and balance the encoding speed/quality",
+      1, 7, 4, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:num-tile-cols:
+   *
+   * The number of tile columns when tile encoding is enabled.
+   */
+  properties[PROP_NUM_TILE_COLS] = g_param_spec_uint ("num-tile-cols",
+      "number of tile columns",
+      "The number of columns for tile encoding", 1, GST_AV1_MAX_TILE_COLS, 1,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:num-tile-rows:
+   *
+   * The number of tile rows when tile encoding is enabled.
+   */
+  properties[PROP_NUM_TILE_ROWS] = g_param_spec_uint ("num-tile-rows",
+      "number of tile rows",
+      "The number of rows for tile encoding", 1, GST_AV1_MAX_TILE_ROWS, 1,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:tile-groups:
+   *
+   * The number of tile groups for each frame.
+   */
+  properties[PROP_TILE_GROUPS] = g_param_spec_uint ("tile-groups",
+      "Number of tile groups", "Number of tile groups for each frame",
+      1, GST_AV1_MAX_TILE_COLS * GST_AV1_MAX_TILE_ROWS, 1,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaAV1Enc:mbbrc:
+   *
+   * Macroblock level bitrate control.
+   * This is not compatible with Constant QP rate control.
+   */
+  properties[PROP_MBBRC] = g_param_spec_enum ("mbbrc",
+      "Macroblock level Bitrate Control",
+      "Macroblock level Bitrate Control. It is not compatible with CQP",
+      GST_TYPE_VA_FEATURE, GST_VA_FEATURE_AUTO,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  if (vaav1enc_class->rate_control_type > 0) {
+    properties[PROP_RATE_CONTROL] = g_param_spec_enum ("rate-control",
+        "rate control mode",
+        "The desired rate control mode for the encoder",
+        vaav1enc_class->rate_control_type,
+        vaav1enc_class->rate_control[0].value,
+        GST_PARAM_CONDITIONALLY_AVAILABLE | G_PARAM_READWRITE |
+        G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+  } else {
+    n_props--;
+    properties[PROP_RATE_CONTROL] = NULL;
+  }
+
+  g_object_class_install_properties (object_class, n_props, properties);
+
+  /**
+   * GstVaFeature:
+   * @GST_VA_FEATURE_DISABLED: The feature is disabled.
+   * @GST_VA_FEATURE_ENABLED: The feature is enabled.
+   * @GST_VA_FEATURE_AUTO: The feature is enabled automatically.
+   *
+   * Since: 1.22
+   */
+  gst_type_mark_as_plugin_api (GST_TYPE_VA_FEATURE, 0);
+}
+
+static GstCaps *
+_complete_src_caps (GstCaps * srccaps)
+{
+  GstCaps *caps = gst_caps_copy (srccaps);
+  GValue val = G_VALUE_INIT;
+
+  g_value_init (&val, G_TYPE_STRING);
+  g_value_set_string (&val, "frame");
+  gst_caps_set_value (caps, "alignment", &val);
+  g_value_unset (&val);
+
+  g_value_init (&val, G_TYPE_STRING);
+  g_value_set_string (&val, "obu-stream");
+  gst_caps_set_value (caps, "stream-format", &val);
+  g_value_unset (&val);
+
+  return caps;
+}
+
+gboolean
+gst_va_av1_enc_register (GstPlugin * plugin, GstVaDevice * device,
+    GstCaps * sink_caps, GstCaps * src_caps, guint rank,
+    VAEntrypoint entrypoint)
+{
+  static GOnce debug_once = G_ONCE_INIT;
+  GType type;
+  GTypeInfo type_info = {
+    .class_size = sizeof (GstVaAV1EncClass),
+    .class_init = gst_va_av1_enc_class_init,
+    .instance_size = sizeof (GstVaAV1Enc),
+    .instance_init = gst_va_av1_enc_init,
+  };
+  struct CData *cdata;
+  gboolean ret;
+  gchar *type_name, *feature_name;
+
+  g_return_val_if_fail (GST_IS_PLUGIN (plugin), FALSE);
+  g_return_val_if_fail (GST_IS_VA_DEVICE (device), FALSE);
+  g_return_val_if_fail (GST_IS_CAPS (sink_caps), FALSE);
+  g_return_val_if_fail (GST_IS_CAPS (src_caps), FALSE);
+  g_return_val_if_fail (entrypoint == VAEntrypointEncSlice ||
+      entrypoint == VAEntrypointEncSliceLP, FALSE);
+
+  cdata = g_new (struct CData, 1);
+  cdata->entrypoint = entrypoint;
+  cdata->description = NULL;
+  cdata->render_device_path = g_strdup (device->render_device_path);
+  cdata->sink_caps = gst_caps_ref (sink_caps);
+  cdata->src_caps = _complete_src_caps (src_caps);
+
+  /* class data will be leaked if the element never gets instantiated */
+  GST_MINI_OBJECT_FLAG_SET (cdata->sink_caps,
+      GST_MINI_OBJECT_FLAG_MAY_BE_LEAKED);
+  GST_MINI_OBJECT_FLAG_SET (cdata->src_caps,
+      GST_MINI_OBJECT_FLAG_MAY_BE_LEAKED);
+
+  type_info.class_data = cdata;
+  if (entrypoint == VAEntrypointEncSlice) {
+    type_name = g_strdup ("GstVaAV1Enc");
+    feature_name = g_strdup ("vaav1enc");
+  } else {
+    type_name = g_strdup ("GstVaAV1LPEnc");
+    feature_name = g_strdup ("vaav1lpenc");
+  }
+
+  /* The first encoder to be registered should use a constant name,
+   * like vaav1enc, for any additional encoders, we create unique
+   * names, using inserting the render device name. */
+  if (g_type_from_name (type_name)) {
+    gchar *basename = g_path_get_basename (device->render_device_path);
+    g_free (type_name);
+    g_free (feature_name);
+    if (entrypoint == VAEntrypointEncSlice) {
+      type_name = g_strdup_printf ("GstVa%sAV1Enc", basename);
+      feature_name = g_strdup_printf ("va%sav1enc", basename);
+    } else {
+      type_name = g_strdup_printf ("GstVa%sAV1LPEnc", basename);
+      feature_name = g_strdup_printf ("va%sav1lpenc", basename);
+    }
+    cdata->description = basename;
+    /* lower rank for non-first device */
+    if (rank > 0)
+      rank--;
+  }
+
+  g_once (&debug_once, _register_debug_category, NULL);
+  type = g_type_register_static (GST_TYPE_VA_BASE_ENC,
+      type_name, &type_info, 0);
+  ret = gst_element_register (plugin, feature_name, rank, type);
+
+  g_free (type_name);
+  g_free (feature_name);
+
+  return ret;
+}
diff --git a/sys/va/gstvaav1enc.h b/sys/va/gstvaav1enc.h
new file mode 100644
index 0000000..4ebb3b5
--- /dev/null
+++ b/sys/va/gstvaav1enc.h
@@ -0,0 +1,34 @@
+/* GStreamer
+ *  Copyright (C) 2022 Intel Corporation
+ *     Author: He Junyan <junyan.he@intel.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#pragma once
+
+#include "gstvadevice.h"
+
+G_BEGIN_DECLS
+
+gboolean     gst_va_av1_enc_register                 (GstPlugin * plugin,
+                                                      GstVaDevice * device,
+                                                      GstCaps * sink_caps,
+                                                      GstCaps * src_caps,
+                                                      guint rank,
+                                                      VAEntrypoint entrypoint);
+
+G_END_DECLS
diff --git a/sys/va/gstvabaseenc.c b/sys/va/gstvabaseenc.c
index 56f73db..faf3ad2 100644
--- a/sys/va/gstvabaseenc.c
+++ b/sys/va/gstvabaseenc.c
@@ -317,7 +317,7 @@ invalid_buffer:
   }
 }
 
-static GstBuffer *
+GstBuffer *
 gst_va_base_enc_create_output_buffer (GstVaBaseEnc * base,
     GstVaEncodePicture * picture)
 {
@@ -378,6 +378,53 @@ error:
   return NULL;
 }
 
+/* Return 0 means error and -1 means not enough data. */
+gint
+gst_va_base_enc_copy_output_data (GstVaBaseEnc * base,
+    GstVaEncodePicture * picture, guint8 * data, gint size)
+{
+  guint coded_size;
+  VASurfaceID surface;
+  VACodedBufferSegment *seg, *seg_list;
+  gint ret_sz = 0;
+
+  /* Wait for encoding to finish */
+  surface = gst_va_encode_picture_get_raw_surface (picture);
+  if (!va_sync_surface (base->display, surface))
+    goto out;
+
+  seg_list = NULL;
+  if (!va_map_buffer (base->display, picture->coded_buffer,
+          (gpointer *) & seg_list))
+    goto out;
+
+  if (!seg_list) {
+    va_unmap_buffer (base->display, picture->coded_buffer);
+    GST_WARNING_OBJECT (base, "coded buffer has no segment list");
+    goto out;
+  }
+
+  coded_size = 0;
+  for (seg = seg_list; seg; seg = seg->next)
+    coded_size += seg->size;
+
+  if (coded_size > size) {
+    GST_DEBUG_OBJECT (base, "Not enough space for coded data");
+    ret_sz = -1;
+    goto out;
+  }
+
+  for (seg = seg_list; seg; seg = seg->next) {
+    memcpy (data + ret_sz, seg->buf, seg->size);
+    ret_sz += seg->size;
+  }
+
+  va_unmap_buffer (base->display, picture->coded_buffer);
+
+out:
+  return ret_sz;
+}
+
 static GstAllocator *
 _allocator_from_caps (GstVaBaseEnc * base, GstCaps * caps)
 {
@@ -454,37 +501,34 @@ config_failed:
 static GstFlowReturn
 _push_buffer_to_downstream (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
 {
-  GstVaEncodePicture *enc_picture;
   GstVaBaseEncClass *base_class = GST_VA_BASE_ENC_GET_CLASS (base);
-  GstBuffer *buf;
+  gboolean complete = TRUE;
 
-  if (base_class->prepare_output)
-    base_class->prepare_output (base, frame);
-
-  enc_picture =
-      *((GstVaEncodePicture **) gst_video_codec_frame_get_user_data (frame));
-
-  buf = gst_va_base_enc_create_output_buffer (base, enc_picture);
-  if (!buf) {
-    GST_ERROR_OBJECT (base, "Failed to create output buffer");
+  if (!base_class->prepare_output (base, frame, &complete)) {
+    GST_ERROR_OBJECT (base, "Failed to prepare output");
     goto error;
   }
 
-  gst_buffer_replace (&frame->output_buffer, buf);
-  gst_clear_buffer (&buf);
-
-  GST_LOG_OBJECT (base, "Push to downstream: frame system_frame_number: %d,"
-      " pts: %" GST_TIME_FORMAT ", dts: %" GST_TIME_FORMAT
-      " duration: %" GST_TIME_FORMAT ", buffer size: %" G_GSIZE_FORMAT,
-      frame->system_frame_number, GST_TIME_ARGS (frame->pts),
-      GST_TIME_ARGS (frame->dts), GST_TIME_ARGS (frame->duration),
-      gst_buffer_get_size (frame->output_buffer));
-
-  return gst_video_encoder_finish_frame (GST_VIDEO_ENCODER (base), frame);
+  if (frame->output_buffer)
+    GST_LOG_OBJECT (base, "Push to downstream: frame system_frame_number: %d,"
+        " pts: %" GST_TIME_FORMAT ", dts: %" GST_TIME_FORMAT
+        " duration: %" GST_TIME_FORMAT ", buffer size: %" G_GSIZE_FORMAT,
+        frame->system_frame_number, GST_TIME_ARGS (frame->pts),
+        GST_TIME_ARGS (frame->dts), GST_TIME_ARGS (frame->duration),
+        gst_buffer_get_size (frame->output_buffer));
+  if (complete) {
+    return gst_video_encoder_finish_frame (GST_VIDEO_ENCODER (base), frame);
+  } else {
+    if (frame->output_buffer) {
+     return gst_video_encoder_finish_subframe (GST_VIDEO_ENCODER (base), frame);
+    } else {
+      /* Allow to output later and no data here. */
+      return GST_FLOW_OK;
+    }
+  }
 
 error:
   gst_clear_buffer (&frame->output_buffer);
-  gst_clear_buffer (&buf);
   gst_video_encoder_finish_frame (GST_VIDEO_ENCODER (base), frame);
 
   return GST_FLOW_ERROR;
diff --git a/sys/va/gstvabaseenc.h b/sys/va/gstvabaseenc.h
index 2db7c76..3f27bd2 100644
--- a/sys/va/gstvabaseenc.h
+++ b/sys/va/gstvabaseenc.h
@@ -87,8 +87,9 @@ struct _GstVaBaseEncClass
   gboolean (*encode_frame)   (GstVaBaseEnc * encoder,
                               GstVideoCodecFrame * frame,
                               gboolean is_last);
-  void     (*prepare_output) (GstVaBaseEnc * encoder,
-                              GstVideoCodecFrame * frame);
+  gboolean (*prepare_output) (GstVaBaseEnc * encoder,
+                              GstVideoCodecFrame * frame,
+                              gboolean * complete);
 
   GstVaCodecs codec;
   VAEntrypoint entrypoint;
@@ -132,7 +133,12 @@ gboolean              gst_va_base_enc_add_trellis_parameter (GstVaBaseEnc * base
 void                  gst_va_base_enc_add_codec_tag       (GstVaBaseEnc * base,
                                                            const gchar * codec_name);
 void                  gst_va_base_enc_reset_state         (GstVaBaseEnc * base);
-
+GstBuffer *           gst_va_base_enc_create_output_buffer (GstVaBaseEnc * base,
+                                                            GstVaEncodePicture * picture);
+gint                  gst_va_base_enc_copy_output_data    (GstVaBaseEnc * base,
+                                                           GstVaEncodePicture * picture,
+                                                           guint8 * data,
+                                                           gint size);
 void                  gst_va_base_enc_update_property_uint (GstVaBaseEnc * base,
                                                             guint32 * old_val,
                                                             guint32 new_val,
diff --git a/sys/va/gstvaencoder.c b/sys/va/gstvaencoder.c
index fa8d64e..bb676cd 100644
--- a/sys/va/gstvaencoder.c
+++ b/sys/va/gstvaencoder.c
@@ -639,7 +639,7 @@ gst_va_encoder_get_slice_structure (GstVaEncoder * self,
 gboolean
 gst_va_encoder_get_max_num_reference (GstVaEncoder * self,
     VAProfile profile, VAEntrypoint entrypoint,
-    guint32 * list0, guint32 * list1)
+    guint32 * listp_0, guint32 * listb_0, guint32 * listb_1)
 {
   VAStatus status;
   VADisplay dpy;
@@ -659,18 +688,31 @@ gst_va_encoder_get_max_num_reference (GstVaEncoder * self,
   }
 
   if (attrib.value == VA_ATTRIB_NOT_SUPPORTED) {
-    if (list0)
-      *list0 = 0;
-    if (list1)
-      *list1 = 0;
+    if (listp_0)
+      *listp_0 = 0;
+    if (listb_0)
+      *listb_0 = 0;
+    if (listb_1)
+      *listb_1 = 0;
 
     return TRUE;
   }
 
-  if (list0)
-    *list0 = attrib.value & 0xffff;
-  if (list1)
-    *list1 = (attrib.value >> 16) & 0xffff;
+  if (profile == VAProfileAV1Profile0 || profile == VAProfileAV1Profile1) {
+    if (listp_0)
+      *listp_0 = attrib.value & 0xff;
+    if (listb_0)
+      *listb_0 = (attrib.value >> 8) & 0xff;
+    if (listb_1)
+      *listb_1 = (attrib.value >> 16) & 0xff;
+  } else {
+    if (listb_0)
+      *listb_0 = attrib.value & 0xffff;
+    if (listb_1)
+      *listb_1 = (attrib.value >> 16) & 0xffff;
+    if (listp_0)
+      *listp_0 = *listb_0;
+  }
 
   return TRUE;
 }
diff --git a/sys/va/gstvaencoder.h b/sys/va/gstvaencoder.h
index 290fb35..d233693 100644
--- a/sys/va/gstvaencoder.h
+++ b/sys/va/gstvaencoder.h
@@ -70,8 +70,9 @@ gint32                gst_va_encoder_get_slice_structure  (GstVaEncoder * self,
 gboolean              gst_va_encoder_get_max_num_reference (GstVaEncoder * self,
                                                             VAProfile profile,
                                                             VAEntrypoint entrypoint,
-                                                            guint32 * list0,
-                                                            guint32 * list1);
+                                                            guint32 * listp_0,
+                                                            guint32 * listb_0,
+                                                            guint32 * listb_1);
 guint                 gst_va_encoder_get_prediction_direction (GstVaEncoder * self,
                                                                VAProfile profile,
                                                                VAEntrypoint entrypoint);
diff --git a/sys/va/gstvah264enc.c b/sys/va/gstvah264enc.c
index 1072e25..b9cb6bb 100644
--- a/sys/va/gstvah264enc.c
+++ b/sys/va/gstvah264enc.c
@@ -983,7 +983,7 @@ _generate_gop_structure (GstVaH264Enc * self)
   }
 
   if (!gst_va_encoder_get_max_num_reference (base->encoder, base->profile,
-          GST_VA_BASE_ENC_ENTRYPOINT (base), &list0, &list1)) {
+          GST_VA_BASE_ENC_ENTRYPOINT (base), NULL, &list0, &list1)) {
     GST_INFO_OBJECT (self, "Failed to get the max num reference");
     list0 = 1;
     list1 = 0;
@@ -3036,11 +3036,13 @@ gst_va_h264_enc_flush (GstVideoEncoder * venc)
   return GST_VIDEO_ENCODER_CLASS (parent_class)->flush (venc);
 }
 
-static void
-gst_va_h264_enc_prepare_output (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
+static gboolean
+gst_va_h264_enc_prepare_output (GstVaBaseEnc * base,
+    GstVideoCodecFrame * frame, gboolean * complete)
 {
   GstVaH264Enc *self = GST_VA_H264_ENC (base);
   GstVaH264EncFrame *frame_enc;
+  GstBuffer *buf;
 
   frame_enc = _enc_frame (frame);
 
@@ -3052,6 +3054,18 @@ gst_va_h264_enc_prepare_output (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
       (gint64) self->gop.num_reorder_frames);
   base->output_frame_count++;
   frame->duration = base->frame_duration;
+
+  buf = gst_va_base_enc_create_output_buffer (base, frame_enc->picture);
+  if (!buf) {
+    GST_ERROR_OBJECT (base, "Failed to create output buffer");
+    return FALSE;
+  }
+
+  gst_buffer_replace (&frame->output_buffer, buf);
+  gst_clear_buffer (&buf);
+
+  *complete = TRUE;
+  return TRUE;
 }
 
 static gint
diff --git a/sys/va/gstvah265enc.c b/sys/va/gstvah265enc.c
index 796ec21..65206e7 100644
--- a/sys/va/gstvah265enc.c
+++ b/sys/va/gstvah265enc.c
@@ -1335,6 +1335,7 @@ _h265_fill_sequence_parameter (GstVaH265Enc * self,
 {
   GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
   guint profile_idc = 0;
+  gboolean palette_mode_enabled_flag = 0;
 
   switch (base->profile) {
     case VAProfileHEVCMain:
@@ -1364,6 +1365,9 @@ _h265_fill_sequence_parameter (GstVaH265Enc * self,
       return FALSE;
   }
 
+  if (_is_scc_enabled (self))
+    palette_mode_enabled_flag = TRUE;
+
   /* *INDENT-OFF* */
   *sequence = (VAEncSequenceParameterBufferHEVC) {
     .general_profile_idc = profile_idc,
@@ -1476,6 +1480,7 @@ _h265_fill_picture_parameter (GstVaH265Enc * self, GstVaH265EncFrame * frame,
   guint8 num_ref_idx_l0_default_active_minus1 = 0;
   guint8 num_ref_idx_l1_default_active_minus1 = 0;
   guint hierarchical_level_plus1 = 0;
+  gboolean pps_curr_pic_ref_enabled_flag = FALSE;
   guint i;
 
   /* *INDENT-OFF* */
@@ -1498,6 +1503,9 @@ _h265_fill_picture_parameter (GstVaH265Enc * self, GstVaH265EncFrame * frame,
         (self->gop.backward_ref_num > 0 ? self->gop.backward_ref_num - 1 : 0);
   }
 
+  if (_is_scc_enabled (self))
+    pps_curr_pic_ref_enabled_flag = TRUE;
+
   *pic_param = (VAEncPictureParameterBufferHEVC) {
     .decoded_curr_pic.picture_id =
         gst_va_encode_picture_get_reconstruct_surface (frame->picture),
@@ -3728,6 +3736,22 @@ _h265_calculate_coded_size (GstVaH265Enc * self)
   codedbuf_size += self->partition.num_slices * (4 +
       GST_ROUND_UP_8 (MAX_SLICE_HDR_SIZE + MAX_SHORT_TERM_REFPICSET_SIZE) / 8);
 
+  if (self->rc.rc_ctrl_mode != VA_RC_CQP) {
+    guint bytes_per_frame = 0;
+
+    bytes_per_frame = gst_util_uint64_scale (self->rc.target_bitrate_bits,
+        GST_VIDEO_INFO_FPS_D (&base->input_state->info),
+        GST_VIDEO_INFO_FPS_N (&base->input_state->info)) / 8;
+
+    /* FIXME: In rate control mode, the driver may even add padding bits to
+       meet the target bit rate requirement. Making the buffer 3 times bigger
+       than the average frame size should be safe. */
+    if (codedbuf_size < 3 * bytes_per_frame) {
+      GST_DEBUG_OBJECT (self, "Every bytes per frame is: %u", bytes_per_frame);
+      codedbuf_size = 3 * bytes_per_frame;
+    }
+  }
+
   base->codedbuf_size = codedbuf_size;
   GST_INFO_OBJECT (self, "Calculate codedbuf size: %u", base->codedbuf_size);
 }
@@ -3802,7 +3826,7 @@ _h265_generate_gop_structure (GstVaH265Enc * self)
   }
 
   if (!gst_va_encoder_get_max_num_reference (base->encoder, base->profile,
-          GST_VA_BASE_ENC_ENTRYPOINT (base), &list0, &list1)) {
+          GST_VA_BASE_ENC_ENTRYPOINT (base), NULL, &list0, &list1)) {
     GST_INFO_OBJECT (self, "Failed to get the max num reference");
     list0 = 1;
     list1 = 0;
@@ -4639,11 +4663,13 @@ gst_va_h265_enc_new_frame (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
   return TRUE;
 }
 
-static void
-gst_va_h265_enc_prepare_output (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
+static gboolean
+gst_va_h265_enc_prepare_output (GstVaBaseEnc * base,
+    GstVideoCodecFrame * frame, gboolean * complete)
 {
   GstVaH265Enc *self = GST_VA_H265_ENC (base);
   GstVaH265EncFrame *frame_enc;
+  GstBuffer *buf;
 
   frame_enc = _enc_frame (frame);
 
@@ -4655,6 +4681,18 @@ gst_va_h265_enc_prepare_output (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
       (gint64) self->gop.num_reorder_frames);
   base->output_frame_count++;
   frame->duration = base->frame_duration;
+
+  buf = gst_va_base_enc_create_output_buffer (base, frame_enc->picture);
+  if (!buf) {
+    GST_ERROR_OBJECT (base, "Failed to create output buffer");
+    return FALSE;
+  }
+
+  gst_buffer_replace (&frame->output_buffer, buf);
+  gst_clear_buffer (&buf);
+
+  *complete = TRUE;
+  return TRUE;
 }
 
 /* *INDENT-OFF* */
@@ -5291,6 +5329,13 @@ gst_va_h265_enc_register (GstPlugin * plugin, GstVaDevice * device,
       GST_MINI_OBJECT_FLAG_MAY_BE_LEAKED);
 
   type_info.class_data = cdata;
+  if (entrypoint == VAEntrypointEncSlice) {
+    type_name = g_strdup ("GstVaH265Enc");
+    feature_name = g_strdup ("vah265enc");
+  } else {
+    type_name = g_strdup ("GstVaH265LPEnc");
+    feature_name = g_strdup ("vah265lpenc");
+  }
 
   /* The first encoder to be registered should use a constant name,
    * like vah265enc, for any additional encoders, we create unique
diff --git a/sys/va/gstvavp9enc.c b/sys/va/gstvavp9enc.c
new file mode 100644
index 0000000..6e4c3ed
--- /dev/null
+++ b/sys/va/gstvavp9enc.c
@@ -0,0 +1,3175 @@
+/* GStreamer
+ *  Copyright (C) 2022 Intel Corporation
+ *     Author: He Junyan <junyan.he@intel.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:element-vavp9enc
+ * @title: vavp9enc
+ * @short_description: A VA-API based VP9 video encoder
+ *
+ * vavp9enc encodes raw video VA surfaces into VP9 bitstreams using
+ * the installed and chosen [VA-API](https://01.org/linuxmedia/vaapi)
+ * driver.
+ *
+ * The raw video frames in main memory can be imported into VA surfaces.
+ *
+ * ## Example launch line
+ * ```
+ * gst-launch-1.0 videotestsrc num-buffers=60 ! timeoverlay ! vavp9enc ! vp9parse ! mp4mux ! filesink location=test.mp4
+ * ```
+ *
+ * Since: 1.22
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstvavp9enc.h"
+
+#include <math.h>
+#include <gst/codecparsers/gstvp9bitwriter.h>
+#include <gst/va/gstva.h>
+#include <gst/va/gstvavideoformat.h>
+#include <gst/video/video.h>
+#include <va/va_drmcommon.h>
+
+#include "vacompat.h"
+#include "gstvabaseenc.h"
+#include "gstvaencoder.h"
+#include "gstvacaps.h"
+#include "gstvaprofile.h"
+#include "gstvadisplay_priv.h"
+
+GST_DEBUG_CATEGORY_STATIC (gst_va_vp9enc_debug);
+#define GST_CAT_DEFAULT gst_va_vp9enc_debug
+
+#define GST_VA_VP9_ENC(obj)            ((GstVaVp9Enc *) obj)
+#define GST_VA_VP9_ENC_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), G_TYPE_FROM_INSTANCE (obj), GstVaVp9EncClass))
+#define GST_VA_VP9_ENC_CLASS(klass)    ((GstVaVp9EncClass *) klass)
+
+typedef struct _GstVaVp9Enc GstVaVp9Enc;
+typedef struct _GstVaVp9EncClass GstVaVp9EncClass;
+typedef struct _GstVaVp9EncFrame GstVaVp9EncFrame;
+typedef struct _GstVaVp9GFGroup GstVaVp9GFGroup;
+typedef struct _GstVaVp9Ref GstVaVp9Ref;
+
+enum
+{
+  PROP_KEYFRAME_INT = 1,
+  PROP_GOLDEN_GROUP_SIZE,
+  PROP_NUM_REF_FRAMES,
+  PROP_HIERARCHICAL_LEVEL,
+  PROP_BITRATE,
+  PROP_TARGET_PERCENTAGE,
+  PROP_TARGET_USAGE,
+  PROP_RATE_CONTROL,
+  PROP_CPB_SIZE,
+  PROP_MBBRC,
+  PROP_QP,
+  PROP_MIN_QP,
+  PROP_MAX_QP,
+  PROP_LOOP_FILTER_LEVEL,
+  PROP_SHARPNESS_LEVEL,
+  N_PROPERTIES
+};
+
+static GParamSpec *properties[N_PROPERTIES];
+
+static GstObjectClass *parent_class = NULL;
+
+#define DEFAULT_BASE_QINDEX  60
+#define DEFAULT_LOOP_FILTER_LEVEL  10
+#define MAX_TILE_WIDTH_B64 64
+#define MAX_FRAME_WIDTH 4096
+#define MAX_FRAME_HEIGHT 4096
+#define MAX_KEY_FRAME_INTERVAL  1024
+#define MAX_GF_GROUP_SIZE  32
+#define DEFAULT_GF_GROUP_SIZE  8
+#define FRAME_TYPE_INVALID  -1
+#define HIGHEST_PYRAMID_LEVELS  6
+#define INVALID_PYRAMID_LEVEL  -1
+#define FRAME_TYPE_REPEAT  0x80
+/* The frame is golden frame */
+#define FRAME_FLAG_GF  0x01
+/* The frame is alt frame */
+#define FRAME_FLAG_ALT  0x02
+/* The frame is on the top level */
+#define FRAME_FLAG_LEAF  0x04
+/* The frame can be internal alt frame */
+#define FRAME_FLAG_ALT_INL  0x08
+/* The frame update the DPB reference */
+#define FRAME_FLAG_UPDATE_REF  0x10
+/* The frame is the last frame in a GF group */
+#define FRAME_FLAG_LAST_IN_GF  0x20
+/* The frame has already be encoded */
+#define FRAME_FLAG_ALREADY_ENCODED  0x40
+/* The frame is in a super frame */
+#define FRAME_FLAG_IN_SUPER_FRAME  0x80
+/* The frame has already outputted */
+#define FRAME_FLAG_ALREADY_OUTPUTTED  0x100
+/* The frame not show */
+#define FRAME_FLAG_NOT_SHOW  0x200
+
+struct _GstVaVp9GFGroup
+{
+  /* where this GF group start since key frame. */
+  gint start_frame_offset;
+  /* Total frame number of this group. */
+  gint group_frame_num;
+  /* Be different from group_frame_num, include repeat */
+  gint output_frame_num;
+  gint last_pushed_num;
+  gint last_poped_index;
+  guint8 highest_level;
+  gboolean use_alt;
+  GQueue *reorder_list;
+
+  /* Include FRAME_TYPEs or FRAME_TYPE_REPEAT. */
+  GstVp9FrameType frame_types[MAX_GF_GROUP_SIZE * 2];
+  gint8 pyramid_levels[MAX_GF_GROUP_SIZE * 2];
+  guint32 flags[MAX_GF_GROUP_SIZE * 2];
+  /* offset from start_frame_num. */
+  gint frame_offsets[MAX_GF_GROUP_SIZE * 2];
+};
+
+struct _GstVaVp9EncFrame
+{
+  GstVaEncodePicture *picture;
+  GstVp9FrameType type;
+  /* VP9 does not define a frame number.
+     This is a virtual number after the key frame. */
+  gint frame_num;
+  guint32 flags;
+  guint pyramid_level;
+  /* The total frame count we handled. */
+  guint total_frame_count;
+  gboolean bidir_ref;
+  gint8 ref_frame_idx[GST_VP9_REF_FRAME_MAX];
+  /* The index in reference list to update */
+  gint update_index;
+  gint order_hint;
+  /* repeat the current frame */
+  gint8 repeat_index;
+  guint repeat_frame_header_size;
+  guint8 repeat_frame_header[32];
+};
+
+struct _GstVaVp9Ref
+{
+  GstVideoCodecFrame *frame;
+  guint index_in_dpb;
+};
+
+struct _GstVaVp9EncClass
+{
+  GstVaBaseEncClass parent_class;
+
+  GType rate_control_type;
+  char rate_control_type_name[64];
+  GEnumValue rate_control[16];
+};
+
+struct _GstVaVp9Enc
+{
+  /*< private > */
+  GstVaBaseEnc parent;
+
+  guint32 packed_headers;
+
+  guint depth;
+  guint chrome;
+
+  /* properties */
+  struct
+  {
+    /* kbps */
+    guint bitrate;
+    /* VA_RC_XXX */
+    guint32 rc_ctrl;
+    guint32 cpb_size;
+    guint32 target_percentage;
+    guint32 target_usage;
+    guint keyframe_interval;
+    guint max_hierarchical_level;
+    guint gf_group_size;
+    guint num_ref_frames;
+    guint32 qp;
+    guint32 min_qp;
+    guint32 max_qp;
+    guint32 mbbrc;
+    gint32 filter_level;
+    guint32 sharpness_level;
+  } prop;
+
+  struct
+  {
+    guint keyframe_interval;
+    guint gf_group_size;
+    guint max_level;
+    guint num_ref_frames;
+    guint forward_ref_num;
+    guint backward_ref_num;
+    guint frame_num_since_kf;
+    GstVaVp9GFGroup current_group;
+    GstVideoCodecFrame *last_keyframe;
+    GstVideoCodecFrame *ref_list[GST_VP9_REF_FRAMES];
+  } gop;
+
+  struct
+  {
+    guint target_usage;
+    guint32 target_percentage;
+    guint32 cpb_size;
+    guint32 cpb_length_bits;
+    guint32 rc_ctrl_mode;
+    guint max_bitrate;
+    guint max_bitrate_bits;
+    guint target_bitrate;
+    guint target_bitrate_bits;
+    guint32 base_qindex;
+    guint32 min_qindex;
+    guint32 max_qindex;
+    guint32 mbbrc;
+    gint32 filter_level;
+    guint32 sharpness_level;
+  } rc;
+
+  /* The cached frames for super frame. */
+  GstVideoCodecFrame *frames_in_super[GST_VP9_MAX_FRAMES_IN_SUPERFRAME - 1];
+  guint frames_in_super_num;
+};
+
+static GstVaVp9EncFrame *
+gst_va_vp9_enc_frame_new (void)
+{
+  GstVaVp9EncFrame *frame;
+
+  frame = g_slice_new (GstVaVp9EncFrame);
+  frame->frame_num = -1;
+  frame->type = FRAME_TYPE_INVALID;
+  frame->picture = NULL;
+  frame->total_frame_count = 0;
+  frame->pyramid_level = 0;
+  frame->flags = 0;
+  frame->bidir_ref = FALSE;
+  frame->update_index = -1;
+  frame->order_hint = -1;
+  frame->repeat_index = -1;
+  frame->repeat_frame_header_size = 0;
+
+  return frame;
+}
+
+static void
+gst_va_vp9_enc_frame_free (gpointer pframe)
+{
+  GstVaVp9EncFrame *frame = pframe;
+
+  g_clear_pointer (&frame->picture, gst_va_encode_picture_free);
+  g_slice_free (GstVaVp9EncFrame, frame);
+}
+
+static gboolean
+gst_va_vp9_enc_new_frame (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
+{
+  GstVaVp9EncFrame *frame_in;
+
+  frame_in = gst_va_vp9_enc_frame_new ();
+  frame_in->total_frame_count = base->input_frame_count++;
+  gst_video_codec_frame_set_user_data (frame, frame_in,
+      gst_va_vp9_enc_frame_free);
+
+  return TRUE;
+}
+
+static inline GstVaVp9EncFrame *
+_enc_frame (GstVideoCodecFrame * frame)
+{
+  GstVaVp9EncFrame *enc_frame = gst_video_codec_frame_get_user_data (frame);
+
+  g_assert (enc_frame);
+
+  return enc_frame;
+}
+
+#ifndef GST_DISABLE_GST_DEBUG
+static const char *
+_vp9_get_frame_type_name (GstVp9FrameType frame_type)
+{
+  const gchar *frame_type_name = NULL;
+  guint type = frame_type;
+
+  if (type & FRAME_TYPE_REPEAT)
+    return "Repeat ";
+
+  switch (type) {
+    case GST_VP9_KEY_FRAME:
+      frame_type_name = "Key    ";
+      break;
+    case GST_VP9_INTER_FRAME:
+      frame_type_name = "Inter  ";
+      break;
+    default:
+      frame_type_name = "Unknown";
+      break;
+  }
+
+  return frame_type_name;
+}
+
+static const gchar *
+_rate_control_get_name (guint32 rc_mode)
+{
+  GParamSpecEnum *spec;
+  guint i;
+
+  if (!(properties[PROP_RATE_CONTROL]
+          && G_IS_PARAM_SPEC_ENUM (properties[PROP_RATE_CONTROL])))
+    return NULL;
+
+  spec = G_PARAM_SPEC_ENUM (properties[PROP_RATE_CONTROL]);
+  for (i = 0; i < spec->enum_class->n_values; i++) {
+    if (spec->enum_class->values[i].value == rc_mode)
+      return spec->enum_class->values[i].value_nick;
+  }
+
+  return NULL;
+}
+#endif
+
+static void
+_vp9_print_gf_group (GstVaVp9Enc * self, GstVaVp9GFGroup * gf_group)
+{
+#ifndef GST_DISABLE_GST_DEBUG
+  gint pushed_frame_num = gf_group->last_pushed_num < 0 ? 0 :
+      gf_group->last_pushed_num - gf_group->start_frame_offset + 1;
+  GString *str;
+  gint i;
+
+  if (gst_debug_category_get_threshold (GST_CAT_DEFAULT) < GST_LEVEL_LOG)
+    return;
+
+  str = g_string_new (NULL);
+
+  g_string_append_printf (str, "\n============================"
+      " GF Group ===========================\n");
+  g_string_append_printf (str, " start:%d,  size:%d  ",
+      gf_group->start_frame_offset, gf_group->group_frame_num);
+  g_string_append_printf (str, "pushed:%d,  poped:%d  ",
+      pushed_frame_num, gf_group->last_poped_index + 1);
+  g_string_append_printf (str, "\n ALT: %s  max level: %d  output num: %d",
+      gf_group->use_alt ? "yes" : "no", gf_group->highest_level,
+      gf_group->output_frame_num);
+
+  g_string_append_printf (str, "\n----------------------------"
+      "-------------------------------------\n");
+  g_string_append_printf (str, "|     |  type   | level |"
+      "             flags            | offset |\n");
+
+  g_string_append_printf (str, "----------------------------"
+      "-------------------------------------\n");
+  for (i = 0; i < gf_group->output_frame_num; i++) {
+    g_string_append_printf (str, "| %3d ", i);
+    g_string_append_printf (str, "| %s ",
+        _vp9_get_frame_type_name (gf_group->frame_types[i]));
+
+    g_string_append_printf (str, "| %5d | ", gf_group->pyramid_levels[i]);
+
+    if (gf_group->flags[i] & FRAME_FLAG_GF) {
+      g_string_append_printf (str, "GF ");
+    } else {
+      g_string_append_printf (str, "   ");
+    }
+
+    if (gf_group->flags[i] & FRAME_FLAG_LAST_IN_GF) {
+      g_string_append_printf (str, "Last ");
+    } else {
+      g_string_append_printf (str, "     ");
+    }
+
+    if (gf_group->flags[i] & (FRAME_FLAG_ALT | FRAME_FLAG_ALT_INL)) {
+      g_string_append_printf (str, "ALT ");
+    } else {
+      g_string_append_printf (str, "    ");
+    }
+
+    if (gf_group->flags[i] & FRAME_FLAG_NOT_SHOW) {
+      g_string_append_printf (str, "Unshown ");
+    } else {
+      g_string_append_printf (str, "Shown   ");
+    }
+
+    if (gf_group->flags[i] & FRAME_FLAG_LEAF) {
+      g_string_append_printf (str, "Leaf ");
+    } else {
+      g_string_append_printf (str, "     ");
+    }
+
+    if (gf_group->flags[i] & FRAME_FLAG_UPDATE_REF) {
+      g_string_append_printf (str, "Ref ");
+    } else {
+      g_string_append_printf (str, "    ");
+    }
+
+    g_string_append_printf (str, "| %-5d  | ", gf_group->frame_offsets[i]);
+
+    g_string_append_printf (str, "\n");
+  }
+
+  g_string_append_printf (str, "---------------------------"
+      "--------------------------------------\n");
+
+  GST_LOG_OBJECT (self, "%s", str->str);
+
+  g_string_free (str, TRUE);
+
+#endif
+}
+
+#ifndef GST_DISABLE_GST_DEBUG
+static void
+_vp9_print_ref_list (GstVaVp9Enc * self, GString * str)
+{
+  gint i;
+
+  g_string_append_printf (str, "\n================== Reference List "
+      "===================\n");
+
+  g_string_append_printf (str, "|   index   |");
+  for (i = 0; i < GST_VP9_REF_FRAMES; i++)
+    g_string_append_printf (str, "%3d |", i);
+
+  g_string_append_printf (str, "\n-------------------------------"
+      "----------------------\n");
+
+  g_string_append_printf (str, "| frame num |");
+  for (i = 0; i < GST_VP9_REF_FRAMES; i++) {
+    if (self->gop.ref_list[i]) {
+      GstVaVp9EncFrame *va_frame = _enc_frame (self->gop.ref_list[i]);
+      g_string_append_printf (str, "%3d |", va_frame->frame_num);
+    } else {
+      g_string_append_printf (str, "%3d |", -1);
+    }
+  }
+  g_string_append_printf (str, "\n-------------------------------"
+      "----------------------\n");
+}
+#endif
+
+static void
+_vp9_print_frame_reference (GstVaVp9Enc * self, GstVideoCodecFrame * frame)
+{
+#ifndef GST_DISABLE_GST_DEBUG
+  GString *str;
+  GstVaVp9EncFrame *va_frame;
+  gint i;
+
+  if (gst_debug_category_get_threshold (GST_CAT_DEFAULT) < GST_LEVEL_LOG)
+    return;
+
+  str = g_string_new (NULL);
+
+  _vp9_print_ref_list (self, str);
+
+  va_frame = _enc_frame (frame);
+
+  g_string_append_printf (str, "Current %sframe num: %d,  ",
+      va_frame->frame_num == 0 ? "key " : "", va_frame->frame_num);
+
+  if (va_frame->type & FRAME_TYPE_REPEAT) {
+    g_string_append_printf (str, "repeat index %d", va_frame->repeat_index);
+    goto print;
+  }
+
+  g_string_append_printf (str, "Reference: [");
+
+  for (i = GST_VP9_REF_FRAME_LAST; i < GST_VP9_REF_FRAME_MAX; i++) {
+    switch (i) {
+      case GST_VP9_REF_FRAME_LAST:
+        g_string_append_printf (str, " %s", "Last");
+        break;
+      case GST_VP9_REF_FRAME_GOLDEN:
+        g_string_append_printf (str, " %s", "Golden");
+        break;
+      case GST_VP9_REF_FRAME_ALTREF:
+        g_string_append_printf (str, " %s", "Alt");
+        break;
+      default:
+        g_assert_not_reached ();
+        break;
+    }
+    g_string_append_printf (str, ":");
+
+    if (va_frame->ref_frame_idx[i] == -1) {
+      g_string_append_printf (str, "unused");
+    } else {
+      g_string_append_printf (str, "%d", va_frame->ref_frame_idx[i]);
+    }
+
+    if (i != GST_VP9_REF_FRAME_MAX - 1) {
+      g_string_append_printf (str, ", ");
+    } else {
+      g_string_append_printf (str, " ");
+    }
+  }
+
+  g_string_append_printf (str, "]");
+
+print:
+  GST_LOG_OBJECT (self, "%s", str->str);
+
+  g_string_free (str, TRUE);
+#endif
+}
+
+static void
+_vp9_print_ref_list_update (GstVaVp9Enc * self, gint update_index,
+    GstVideoCodecFrame * del_frame, GstVideoCodecFrame * add_frame)
+{
+#ifndef GST_DISABLE_GST_DEBUG
+  GString *str;
+
+  if (gst_debug_category_get_threshold (GST_CAT_DEFAULT) < GST_LEVEL_LOG)
+    return;
+
+  str = g_string_new (NULL);
+
+  _vp9_print_ref_list (self, str);
+
+  if (_enc_frame (add_frame)->frame_num == 0)
+    g_string_append_printf (str, "Key frame clear all reference list.\n");
+
+  if (update_index >= 0) {
+    if (del_frame) {
+      g_string_append_printf (str, "Replace index %d, delete frame num %d, "
+          "add frame num %d.", update_index, _enc_frame (del_frame)->frame_num,
+          _enc_frame (add_frame)->frame_num);
+    } else {
+      g_string_append_printf (str, "Add frame %d to index %d.",
+          _enc_frame (add_frame)->frame_num, update_index);
+    }
+  }
+
+  GST_LOG_OBJECT (self, "%s", str->str);
+
+  g_string_free (str, TRUE);
+#endif
+}
+
+/* [ start, end ) */
+static void
+_set_multi_layer (GstVaVp9GFGroup * gf_group, gint * frame_index,
+    gint start, gint end, guint level, guint max_level)
+{
+  const gint num_frames_to_process = end - start;
+  guint m = (start + end - 1) / 2;
+
+  g_assert (level <= max_level);
+
+  if (level == max_level || num_frames_to_process <= 2) {
+    guint i;
+
+    for (i = 0; i < num_frames_to_process; i++) {
+      gf_group->frame_types[*frame_index] = GST_VP9_INTER_FRAME;
+      gf_group->pyramid_levels[*frame_index] = level;
+      gf_group->flags[*frame_index] = FRAME_FLAG_LEAF | FRAME_FLAG_UPDATE_REF;
+      gf_group->frame_offsets[*frame_index] = start + i;
+      (*frame_index)++;
+    }
+    return;
+  }
+
+  gf_group->frame_types[*frame_index] = GST_VP9_INTER_FRAME;
+  gf_group->pyramid_levels[*frame_index] = level;
+  gf_group->flags[*frame_index] = FRAME_FLAG_ALT_INL | FRAME_FLAG_UPDATE_REF;
+  gf_group->flags[*frame_index] |= FRAME_FLAG_NOT_SHOW;
+  gf_group->frame_offsets[*frame_index] = m;
+  (*frame_index)++;
+
+  /* The frames between start and this internal ALT */
+  _set_multi_layer (gf_group, frame_index, start, m, level + 1, max_level);
+
+  /* Repeat for this internal ALT frame */
+  gf_group->frame_types[*frame_index] = FRAME_TYPE_REPEAT;
+  gf_group->pyramid_levels[*frame_index] = -1;
+  gf_group->flags[*frame_index] = 0;
+  gf_group->frame_offsets[*frame_index] = m;
+  (*frame_index)++;
+
+  /* The frames between this internal ALT and end */
+  _set_multi_layer (gf_group, frame_index, m + 1, end, level + 1, max_level);
+}
+
+static void
+_vp9_init_gf_group (GstVaVp9GFGroup * gf_group, GQueue * reorder_list)
+{
+  guint i;
+
+  gf_group->start_frame_offset = -1;
+  gf_group->group_frame_num = 0;
+  gf_group->last_pushed_num = -1;
+  gf_group->use_alt = FALSE;
+  gf_group->last_poped_index = -1;
+
+  for (i = 0; i < MAX_GF_GROUP_SIZE * 2; i++) {
+    gf_group->frame_types[i] = FRAME_TYPE_INVALID;
+    gf_group->pyramid_levels[i] = INVALID_PYRAMID_LEVEL;
+    gf_group->flags[i] = 0;
+    gf_group->frame_offsets[i] = -1;
+  }
+
+  /* We just use it, not own it. */
+  gf_group->reorder_list = reorder_list;
+}
+
+static void
+_vp9_start_gf_group (GstVaVp9Enc * self, GstVideoCodecFrame * gf_frame)
+{
+  GstVaVp9GFGroup *gf_group = &self->gop.current_group;
+  guint group_size = self->gop.gf_group_size + 1;
+  gboolean use_alt = self->gop.backward_ref_num > 0;
+  guint max_level = self->gop.max_level;
+  GstVaVp9EncFrame *frame = _enc_frame (gf_frame);
+  gboolean key_frame_start = (frame->frame_num == 0);
+  gint frame_index;
+  guint i;
+
+  if (use_alt) {
+    /* At least 2 levels if bi-direction ref,
+       1st for ALT, and 2nd for leaves. */
+    g_assert (max_level >= 2);
+  }
+
+  /* + 1 for golden frame itself. */
+  g_assert (group_size <= MAX_GF_GROUP_SIZE + 1);
+  g_assert (max_level <= HIGHEST_PYRAMID_LEVELS);
+  /* If size < 3, no backward ref needed. */
+  g_assert (group_size > 3 || use_alt == FALSE);
+
+  gf_group->start_frame_offset = frame->frame_num;
+  gf_group->group_frame_num = group_size;
+  gf_group->last_pushed_num = frame->frame_num;
+  gf_group->use_alt = use_alt;
+
+  gf_group->last_poped_index = -1;
+  /* An already encoded frame as the GF,
+     for example, the ALT of the previous GF group. */
+  if (frame->flags & FRAME_FLAG_ALREADY_ENCODED)
+    gf_group->last_poped_index = 0;
+
+  for (i = 0; i < MAX_GF_GROUP_SIZE * 2; i++) {
+    gf_group->frame_types[i] = FRAME_TYPE_INVALID;
+    gf_group->pyramid_levels[i] = INVALID_PYRAMID_LEVEL;
+    gf_group->flags[i] = 0;
+    gf_group->frame_offsets[i] = -1;
+  }
+
+  frame_index = 0;
+  /* GF frame is the first */
+  gf_group->frame_types[frame_index] = key_frame_start ? GST_VP9_KEY_FRAME :
+      GST_VP9_INTER_FRAME;
+  gf_group->pyramid_levels[frame_index] = 0;
+  gf_group->flags[frame_index] = FRAME_FLAG_GF;
+  gf_group->flags[frame_index] |= FRAME_FLAG_UPDATE_REF;
+  gf_group->frame_offsets[frame_index] = 0;
+  frame_index++;
+
+  /* No backward ref, in simple I/P mode */
+  if (gf_group->use_alt == FALSE) {
+    for (; frame_index < gf_group->group_frame_num; frame_index++) {
+      gf_group->frame_types[frame_index] = GST_VP9_INTER_FRAME;
+      gf_group->pyramid_levels[frame_index] = 1;
+      gf_group->flags[frame_index] = FRAME_FLAG_UPDATE_REF | FRAME_FLAG_LEAF;
+      if (frame_index == gf_group->group_frame_num - 1)
+        gf_group->flags[frame_index] |= FRAME_FLAG_LAST_IN_GF;
+      gf_group->frame_offsets[frame_index] = frame_index;
+    }
+
+    gf_group->output_frame_num = gf_group->group_frame_num;
+    gf_group->highest_level = 1;
+
+    _vp9_print_gf_group (self, gf_group);
+    return;
+  }
+
+  /* ALT frame */
+  gf_group->frame_types[frame_index] = GST_VP9_INTER_FRAME;
+  gf_group->pyramid_levels[frame_index] = 1;
+  gf_group->flags[frame_index] = FRAME_FLAG_ALT | FRAME_FLAG_UPDATE_REF;
+  gf_group->flags[frame_index] |= FRAME_FLAG_LAST_IN_GF;
+  gf_group->flags[frame_index] |= FRAME_FLAG_NOT_SHOW;
+  gf_group->frame_offsets[frame_index] = gf_group->group_frame_num - 1;
+  frame_index++;
+
+  /* The frames between GF and ALT */
+  _set_multi_layer (gf_group, &frame_index, 1,
+      gf_group->group_frame_num - 1, 2, max_level);
+
+  /* Repeat for ALT frame */
+  gf_group->frame_types[frame_index] = FRAME_TYPE_REPEAT;
+  gf_group->pyramid_levels[frame_index] = -1;
+  gf_group->flags[frame_index] = 0;
+  gf_group->frame_offsets[frame_index] = gf_group->group_frame_num - 1;
+  frame_index++;
+
+  gf_group->output_frame_num = frame_index;
+
+  gf_group->highest_level = 0;
+  for (i = 0; i < gf_group->output_frame_num; i++) {
+    if (gf_group->highest_level < gf_group->pyramid_levels[i])
+      gf_group->highest_level = gf_group->pyramid_levels[i];
+  }
+
+  _vp9_print_gf_group (self, gf_group);
+  return;
+}
+
+static gboolean
+_vp9_gf_group_push_frame (GstVaVp9GFGroup * gf_group,
+    GstVideoCodecFrame * gst_frame)
+{
+  GstVaVp9EncFrame *frame = _enc_frame (gst_frame);
+  gint pushed_frame_num = gf_group->last_pushed_num < 0 ? 0 :
+      gf_group->last_pushed_num - gf_group->start_frame_offset + 1;
+
+  /* No room for a new one. */
+  g_return_val_if_fail (pushed_frame_num < gf_group->group_frame_num, FALSE);
+  /* The frame num should just increase. */
+  g_return_val_if_fail (frame->frame_num == gf_group->last_pushed_num + 1,
+      FALSE);
+
+  if (gf_group->use_alt)
+    /* If we already begin pop, no more push again. */
+    g_return_val_if_fail (gf_group->last_poped_index <= 0, FALSE);
+
+  g_queue_push_tail (gf_group->reorder_list,
+      gst_video_codec_frame_ref (gst_frame));
+
+  gf_group->last_pushed_num = frame->frame_num;
+  return TRUE;
+}
+
+static gboolean
+_vp9_gf_group_pop_frame (GstVaVp9GFGroup * gf_group,
+    GstVideoCodecFrame * ref_list[GST_VP9_REF_FRAMES],
+    GstVideoCodecFrame ** out_frame)
+{
+  GstVaVp9EncFrame *vaframe;
+  GstVideoCodecFrame *frame;
+  gint pushed_frame_num = gf_group->last_pushed_num < 0 ? 0 :
+      gf_group->last_pushed_num - gf_group->start_frame_offset + 1;
+  guint i;
+
+  g_assert (pushed_frame_num <= gf_group->group_frame_num);
+
+  if (pushed_frame_num == 0)
+    goto no_frame;
+
+  if (!gf_group->use_alt) {
+    g_assert (gf_group->last_poped_index < pushed_frame_num);
+
+    if (gf_group->last_poped_index + 1 < pushed_frame_num) {
+      gf_group->last_poped_index++;
+      goto find_frame;
+    }
+
+    goto no_frame;
+  }
+
+  /* The first frame of a GF group has no backward ref, pop immediately. */
+  if (gf_group->last_poped_index < 0) {
+    gf_group->last_poped_index++;
+    goto find_frame;
+  }
+
+  /* The ALT frame has not come. */
+  if (pushed_frame_num < gf_group->group_frame_num)
+    goto no_frame;
+
+  gf_group->last_poped_index++;
+  g_assert (gf_group->last_poped_index < gf_group->output_frame_num);
+
+find_frame:
+  vaframe = NULL;
+  frame = NULL;
+
+  /* If repeating some frame, it should be in reference list,
+     or it should be in reorder list. */
+  if (gf_group->frame_types[gf_group->last_poped_index] == FRAME_TYPE_REPEAT) {
+    for (i = 0; i < GST_VP9_REF_FRAMES; i++) {
+      GstVaVp9EncFrame *vaf;
+
+      if (ref_list[i] == NULL)
+        continue;
+
+      vaf = _enc_frame (ref_list[i]);
+      if (vaf->frame_num == gf_group->start_frame_offset +
+          gf_group->frame_offsets[gf_group->last_poped_index]) {
+        vaframe = vaf;
+        frame = ref_list[i];
+        break;
+      }
+    }
+
+    g_return_val_if_fail (vaframe, FALSE);
+
+    g_assert (vaframe->flags & FRAME_FLAG_ALREADY_ENCODED);
+    vaframe->type |= FRAME_TYPE_REPEAT;
+  } else {
+    for (i = 0; i < g_queue_get_length (gf_group->reorder_list); i++) {
+      GstVaVp9EncFrame *vaf;
+      GstVideoCodecFrame *f;
+
+      f = g_queue_peek_nth (gf_group->reorder_list, i);
+      vaf = _enc_frame (f);
+      if (vaf->frame_num == gf_group->start_frame_offset +
+          gf_group->frame_offsets[gf_group->last_poped_index]) {
+        vaframe = vaf;
+        frame = f;
+        break;
+      }
+    }
+    /* We push the frame num in increment order, so it must exist. */
+    g_return_val_if_fail (vaframe, FALSE);
+    /* Clear that frame from reorder list. */
+    g_queue_pop_nth (gf_group->reorder_list, i);
+
+    vaframe->type = gf_group->frame_types[gf_group->last_poped_index];
+    vaframe->pyramid_level =
+        gf_group->pyramid_levels[gf_group->last_poped_index];
+    vaframe->flags = gf_group->flags[gf_group->last_poped_index];
+
+    /* unref frame popped from reorder queue */
+    gst_video_codec_frame_unref (frame);
+  }
+
+  *out_frame = frame;
+  return TRUE;
+
+no_frame:
+  *out_frame = NULL;
+  return TRUE;
+}
+
+/* Force to finish current group, no matter how many frames we have. */
+static void
+_vp9_finish_current_gf_group (GstVaVp9Enc * self, GstVaVp9GFGroup * gf_group)
+{
+  gint frame_index;
+  gint pushed_frame_num = gf_group->last_pushed_num < 0 ? 0 :
+      gf_group->last_pushed_num - gf_group->start_frame_offset + 1;
+  guint i;
+
+  g_assert (pushed_frame_num <= gf_group->group_frame_num);
+
+  /* Alt comes and already finished. */
+  if (gf_group->use_alt && gf_group->last_poped_index > 0)
+    return;
+
+  /* Already pushed all frames. */
+  if (pushed_frame_num == gf_group->group_frame_num)
+    return;
+
+  /* Not enough frames, no need to use backward ref. */
+  if (gf_group->use_alt && pushed_frame_num <= 3)
+    gf_group->use_alt = FALSE;
+
+  if (gf_group->use_alt == FALSE) {
+    g_assert (gf_group->last_poped_index < pushed_frame_num);
+
+    gf_group->group_frame_num = pushed_frame_num;
+
+    for (frame_index = 1; frame_index < gf_group->group_frame_num;
+        frame_index++) {
+      gf_group->frame_types[frame_index] = GST_VP9_INTER_FRAME;
+      gf_group->pyramid_levels[frame_index] = 1;
+      gf_group->flags[frame_index] = FRAME_FLAG_UPDATE_REF | FRAME_FLAG_LEAF;
+      gf_group->frame_offsets[frame_index] = frame_index;
+      if (frame_index == gf_group->group_frame_num - 1) {
+        gf_group->flags[frame_index] |= FRAME_FLAG_LAST_IN_GF;
+      }
+
+    }
+
+    gf_group->output_frame_num = gf_group->group_frame_num;
+    gf_group->highest_level = 1;
+
+    GST_LOG_OBJECT (self, "Finish current golden group.");
+    _vp9_print_gf_group (self, gf_group);
+    return;
+  }
+
+  g_assert (gf_group->highest_level >= 2);
+
+  gf_group->group_frame_num = pushed_frame_num;
+
+  frame_index = 1;
+  /* ALT frame */
+  gf_group->frame_types[frame_index] = GST_VP9_INTER_FRAME;
+  gf_group->pyramid_levels[frame_index] = 1;
+  gf_group->flags[frame_index] = FRAME_FLAG_ALT | FRAME_FLAG_UPDATE_REF;
+  gf_group->flags[frame_index] |= FRAME_FLAG_LAST_IN_GF;
+  gf_group->flags[frame_index] |= FRAME_FLAG_NOT_SHOW;
+  gf_group->frame_offsets[frame_index] = gf_group->group_frame_num - 1;
+  frame_index++;
+
+  /* The frames between GF and ALT */
+  _set_multi_layer (gf_group, &frame_index, 1, gf_group->group_frame_num - 1,
+      2, gf_group->highest_level);
+
+  /* Repeat of ALT frame */
+  gf_group->frame_types[frame_index] = FRAME_TYPE_REPEAT;
+  gf_group->pyramid_levels[frame_index] = -1;
+  gf_group->flags[frame_index] = 0;
+  gf_group->frame_offsets[frame_index] = gf_group->group_frame_num - 1;
+  frame_index++;
+
+  gf_group->output_frame_num = frame_index;
+
+  gf_group->highest_level = 0;
+  for (i = 0; i < gf_group->output_frame_num; i++) {
+    if (gf_group->highest_level < gf_group->pyramid_levels[i])
+      gf_group->highest_level = gf_group->pyramid_levels[i];
+  }
+
+  GST_LOG_OBJECT (self, "Finish current golden group.");
+  _vp9_print_gf_group (self, gf_group);
+  return;
+}
+
+static inline gboolean
+_vp9_gf_group_is_empty (GstVaVp9GFGroup * gf_group)
+{
+  gint pushed_frame_num = gf_group->last_pushed_num < 0 ? 0 :
+      gf_group->last_pushed_num - gf_group->start_frame_offset + 1;
+
+  if (pushed_frame_num <= 0)
+    return TRUE;
+
+  if (gf_group->use_alt == FALSE) {
+    g_assert (gf_group->last_poped_index + 1 <= pushed_frame_num);
+    if (gf_group->last_poped_index + 1 == pushed_frame_num)
+      return TRUE;
+
+    return FALSE;
+  }
+
+  g_assert (gf_group->last_poped_index < gf_group->output_frame_num);
+  if (gf_group->last_poped_index == gf_group->output_frame_num - 1)
+    return TRUE;
+
+  return FALSE;
+}
+
+static inline gboolean
+_vp9_gf_group_is_finished (GstVaVp9GFGroup * gf_group)
+{
+  g_assert (gf_group->last_poped_index < gf_group->output_frame_num);
+  if (gf_group->last_poped_index == gf_group->output_frame_num - 1)
+    return TRUE;
+
+  return FALSE;
+}
+
+static GstVideoCodecFrame *
+_vp9_find_next_golden_frame (GstVaVp9Enc * self)
+{
+  guint i;
+  GstVideoCodecFrame *f, *f_max_frame_num;
+  GstVaVp9EncFrame *vaf;
+  gint max_frame_num;
+
+  g_assert (_vp9_gf_group_is_empty (&self->gop.current_group));
+
+  f = NULL;
+  f_max_frame_num = NULL;
+  max_frame_num = -1;
+  for (i = 0; i < GST_VP9_REF_FRAMES; i++) {
+    if (self->gop.ref_list[i] == NULL)
+      continue;
+
+    vaf = _enc_frame (self->gop.ref_list[i]);
+    if (vaf->flags & FRAME_FLAG_LAST_IN_GF) {
+      /* Should not have 2 of group end frame at the same time. */
+      g_assert (f == NULL);
+      f = self->gop.ref_list[i];
+    }
+
+    if (vaf->frame_num > max_frame_num) {
+      max_frame_num = vaf->frame_num;
+      f_max_frame_num = self->gop.ref_list[i];
+    }
+
+    /* clear all flags about last GF group. */
+    vaf->flags &= ~(FRAME_FLAG_LAST_IN_GF | FRAME_FLAG_ALT_INL |
+        FRAME_FLAG_ALT | FRAME_FLAG_GF);
+  }
+
+  if (f == NULL)
+    f = f_max_frame_num;
+
+  vaf = _enc_frame (f);
+  vaf->flags |= FRAME_FLAG_GF;
+
+  GST_LOG_OBJECT (self, "Find the next golden frame num %d", vaf->frame_num);
+
+  return f;
+}
+
+static gboolean
+gst_va_vp9_enc_reorder_frame (GstVaBaseEnc * base, GstVideoCodecFrame * frame,
+    gboolean bump_all, GstVideoCodecFrame ** out_frame)
+{
+  GstVaVp9Enc *self = GST_VA_VP9_ENC (base);
+  GstVaVp9EncFrame *va_frame;
+
+  *out_frame = NULL;
+
+  if (bump_all) {
+    g_return_val_if_fail (frame == NULL, FALSE);
+
+    _vp9_finish_current_gf_group (self, &self->gop.current_group);
+
+    if (!_vp9_gf_group_is_finished (&self->gop.current_group)) {
+      g_assert (!_vp9_gf_group_is_empty (&self->gop.current_group));
+      goto pop;
+    }
+
+    /* no more frames, the cached key frame is the last frame */
+    if (self->gop.last_keyframe) {
+      g_assert (_vp9_gf_group_is_empty (&self->gop.current_group));
+
+      *out_frame = self->gop.last_keyframe;
+      self->gop.last_keyframe = NULL;
+    }
+
+    goto finish;
+  }
+
+  /* Pop only. We can pop some frame if:
+     1. The current GF group is not finished.
+     2. Encountered a key frame last time and force to finish
+     the current GF group. */
+  if (frame == NULL) {
+    if (!_vp9_gf_group_is_empty (&self->gop.current_group))
+      goto pop;
+
+    if (self->gop.last_keyframe) {
+      GstVideoCodecFrame *f = self->gop.last_keyframe;
+      self->gop.last_keyframe = NULL;
+
+      _vp9_start_gf_group (self, f);
+      goto pop;
+    }
+
+    goto finish;
+  }
+
+  if (self->gop.frame_num_since_kf == self->gop.keyframe_interval)
+    self->gop.frame_num_since_kf = 0;
+
+  if (GST_VIDEO_CODEC_FRAME_IS_FORCE_KEYFRAME (frame))
+    self->gop.frame_num_since_kf = 0;
+
+  va_frame = _enc_frame (frame);
+  va_frame->frame_num = self->gop.frame_num_since_kf;
+  self->gop.frame_num_since_kf++;
+
+  GST_LOG_OBJECT (self, "push frame: system_frame_number %d, frame_num: %d",
+      frame->system_frame_number, va_frame->frame_num);
+
+  /* A new key frame force to finish the current GF group. */
+  if (va_frame->frame_num == 0) {
+    _vp9_finish_current_gf_group (self, &self->gop.current_group);
+
+    g_queue_push_tail (&base->reorder_list, gst_video_codec_frame_ref (frame));
+
+    if (_vp9_gf_group_is_finished (&self->gop.current_group)) {
+      g_assert (_vp9_gf_group_is_empty (&self->gop.current_group));
+
+      /* Already poped all of the last group,
+         so begin a new group with this keyframe. */
+      _vp9_start_gf_group (self, frame);
+    } else {
+      g_assert (!_vp9_gf_group_is_empty (&self->gop.current_group));
+
+      /* The reorder() should exhaust all available frames in the
+         reorder list before push a frame again, so the last key
+         frame should already be popped. */
+      g_return_val_if_fail (self->gop.last_keyframe == NULL, FALSE);
+      self->gop.last_keyframe = frame;
+    }
+
+    goto pop;
+  }
+
+  if (_vp9_gf_group_is_finished (&self->gop.current_group)) {
+    GstVideoCodecFrame *gf_frame;
+
+    g_assert (_vp9_gf_group_is_empty (&self->gop.current_group));
+
+    gf_frame = _vp9_find_next_golden_frame (self);
+    /* At least, there are some frames inside the reference list. */
+    g_assert (gf_frame);
+
+    _vp9_start_gf_group (self, gf_frame);
+  }
+
+  if (!_vp9_gf_group_push_frame (&self->gop.current_group, frame)) {
+    GST_WARNING_OBJECT (base, "Failed to push the frame,"
+        " system_frame_number %d.", frame->system_frame_number);
+    goto error;
+  }
+
+pop:
+  frame = NULL;
+
+  if (!_vp9_gf_group_pop_frame (&self->gop.current_group, self->gop.ref_list,
+          out_frame))
+    goto error;
+
+finish:
+  if (*out_frame) {
+    va_frame = _enc_frame (*out_frame);
+    GST_LOG_OBJECT (self, "pop frame: system_frame_number %d,"
+        " frame_num: %d, frame_type %s", (*out_frame)->system_frame_number,
+        va_frame->frame_num, _vp9_get_frame_type_name (va_frame->type));
+  }
+
+  return TRUE;
+
+error:
+  if (frame) {
+    GST_ERROR_OBJECT (base, "Failed to reorder the frame,"
+        " system_frame_number %d.", frame->system_frame_number);
+  } else {
+    GST_ERROR_OBJECT (base, "error when poping frame.");
+  }
+  return FALSE;
+}
+
+static gint
+_vp9_sort_by_frame_num (gconstpointer a, gconstpointer b, gpointer user_data)
+{
+  GstVaVp9EncFrame *frame1 = _enc_frame (((GstVaVp9Ref *) a)->frame);
+  GstVaVp9EncFrame *frame2 = _enc_frame (((GstVaVp9Ref *) b)->frame);
+
+  g_assert (frame1->frame_num != frame2->frame_num);
+
+  return frame1->frame_num - frame2->frame_num;
+}
+
+static gboolean
+_vp9_assign_ref_index (GstVaVp9Enc * self, GstVideoCodecFrame * frame)
+{
+  GstVaVp9Ref all_refs[GST_VP9_REF_FRAMES];
+  guint ref_num;
+  gint forward_num, backward_num;
+  gint forward_ref_num;
+  GstVaVp9EncFrame *va_frame = _enc_frame (frame);
+  gint i, num;
+
+  memset (va_frame->ref_frame_idx, -1, sizeof (va_frame->ref_frame_idx));
+
+  if (va_frame->type & FRAME_TYPE_REPEAT) {
+    va_frame->repeat_index = -1;
+
+    for (i = 0; i < GST_VP9_REF_FRAMES; i++) {
+      if (self->gop.ref_list[i] == frame) {
+        va_frame->repeat_index = i;
+        break;
+      }
+    }
+
+    g_return_val_if_fail (va_frame->repeat_index >= 0, FALSE);
+    goto finish;
+  }
+
+  /* key frame has no ref */
+  if (va_frame->frame_num == 0) {
+    g_assert (va_frame->type == GST_VP9_KEY_FRAME);
+    va_frame->bidir_ref = FALSE;
+    goto finish;
+  }
+
+  ref_num = forward_num = backward_num = 0;
+  for (i = 0; i < GST_VP9_REF_FRAMES; i++) {
+    GstVaVp9EncFrame *va_f;
+
+    if (self->gop.ref_list[i] == NULL)
+      continue;
+
+    all_refs[ref_num].frame = self->gop.ref_list[i];
+    all_refs[ref_num].index_in_dpb = i;
+    ref_num++;
+
+    va_f = _enc_frame (self->gop.ref_list[i]);
+    g_assert (va_f->frame_num != va_frame->frame_num);
+    if (va_f->frame_num < va_frame->frame_num) {
+      forward_num++;
+    } else {
+      backward_num++;
+      g_assert (va_f->flags & FRAME_FLAG_ALT ||
+          va_f->flags & FRAME_FLAG_ALT_INL);
+    }
+
+    if (va_f->flags & FRAME_FLAG_GF)
+      va_frame->ref_frame_idx[GST_VP9_REF_FRAME_GOLDEN] = i;
+  }
+
+  if (va_frame->ref_frame_idx[GST_VP9_REF_FRAME_GOLDEN] == -1) {
+    GST_WARNING_OBJECT (self, "failed to find the golden frame.");
+    return FALSE;
+  }
+
+  g_qsort_with_data (all_refs, ref_num, sizeof (GstVaVp9Ref),
+      _vp9_sort_by_frame_num, NULL);
+
+  /* Setting the forward refs. GOLDEN is always set first.
+     LAST is set to the nearest frame in the past if forward_ref_num is
+     enough. If forward_ref_num is not enough, it is just set to GOLDEN. */
+  va_frame->bidir_ref = FALSE;
+
+  num = forward_num - 1;
+  forward_ref_num = self->gop.forward_ref_num - 1 /* already assign gf */ ;
+
+  if (num >= 0 && all_refs[num].index_in_dpb ==
+      va_frame->ref_frame_idx[GST_VP9_REF_FRAME_GOLDEN])
+    num--;
+
+  if (num >= 0 && forward_ref_num > 0) {
+    va_frame->ref_frame_idx[GST_VP9_REF_FRAME_LAST] =
+        all_refs[num].index_in_dpb;
+  } else {
+    va_frame->ref_frame_idx[GST_VP9_REF_FRAME_LAST] =
+        va_frame->ref_frame_idx[GST_VP9_REF_FRAME_GOLDEN];
+  }
+
+  /* Setting the backward refs */
+  if (backward_num > 0 && self->gop.backward_ref_num > 0) {
+    g_assert (self->gop.backward_ref_num == 1);
+    g_assert (_enc_frame (all_refs[ref_num - 1].frame)->flags & FRAME_FLAG_ALT);
+
+    va_frame->bidir_ref = TRUE;
+    /* Set the ALTREF to the nearest future frame. */
+    va_frame->ref_frame_idx[GST_VP9_REF_FRAME_ALTREF] =
+        all_refs[forward_num].index_in_dpb;
+  } else {
+    /* If no backward refs, ALTREF is set to next forward. */
+    num--;
+    forward_ref_num--;
+    if (num >= 0 && all_refs[num].index_in_dpb ==
+        va_frame->ref_frame_idx[GST_VP9_REF_FRAME_GOLDEN])
+      num--;
+
+    if (num >= 0 && forward_ref_num > 0) {
+      va_frame->ref_frame_idx[GST_VP9_REF_FRAME_ALTREF] =
+          all_refs[num].index_in_dpb;
+    } else {
+      va_frame->ref_frame_idx[GST_VP9_REF_FRAME_ALTREF] =
+          va_frame->ref_frame_idx[GST_VP9_REF_FRAME_GOLDEN];
+    }
+  }
+
+finish:
+  _vp9_print_frame_reference (self, frame);
+  return TRUE;
+}
+
+static void
+_vp9_find_ref_to_update (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
+{
+  GstVaVp9Enc *self = GST_VA_VP9_ENC (base);
+  GstVaVp9EncFrame *va_frame = _enc_frame (frame);
+  gint slot;
+  gint lowest_slot;
+  gint lowest_frame_num = MAX_KEY_FRAME_INTERVAL + 1;
+  gint i;
+
+  if (va_frame->type & FRAME_TYPE_REPEAT)
+    return;
+
+  if ((va_frame->flags & FRAME_FLAG_UPDATE_REF) == 0) {
+    /* Key frame should always clean the reference list. */
+    g_assert (va_frame->type != GST_VP9_KEY_FRAME);
+    return;
+  }
+
+  va_frame->update_index = -1;
+
+  /* key frame will clear the whole ref list, just use the 0 */
+  if (va_frame->type == GST_VP9_KEY_FRAME) {
+    va_frame->update_index = 0;
+    return;
+  }
+
+  /* 1. Find an empty slot in the reference list.
+     2. If the list is full, kick out the non GF frame with lowest
+     frame num. GF frame should not be kicked out because we always
+     set GOLDEN to GF frame.
+     3. If still not find, we drop ourself. */
+  lowest_frame_num = MAX_KEY_FRAME_INTERVAL + 1;
+  slot = lowest_slot = -1;
+  for (i = 0; i < GST_VP9_REF_FRAMES; i++) {
+    GstVaVp9EncFrame *va_f;
+
+    if (self->gop.ref_list[i] == NULL) {
+      slot = i;
+      break;
+    }
+
+    va_f = _enc_frame (self->gop.ref_list[i]);
+    if (va_f->flags & FRAME_FLAG_GF)
+      continue;
+
+    if (va_f->frame_num > va_frame->frame_num)
+      continue;
+
+    if (va_f->frame_num < lowest_frame_num) {
+      lowest_frame_num = va_f->frame_num;
+      lowest_slot = i;
+    }
+  }
+
+  if (slot < 0 && lowest_slot >= 0)
+    slot = lowest_slot;
+
+  if (slot >= 0)
+    va_frame->update_index = slot;
+}
+
+static void
+_vp9_update_ref_list (GstVaBaseEnc * base, GstVideoCodecFrame * frame)
+{
+  GstVaVp9Enc *self = GST_VA_VP9_ENC (base);
+  GstVaVp9EncFrame *va_frame = _enc_frame (frame);
+  GstVideoCodecFrame *del_f;
+  gint i;
+
+  if (va_frame->type & FRAME_TYPE_REPEAT)
+    return;
+
+  /* key frame, clear the whole ref list. */
+  if (va_frame->type == GST_VP9_KEY_FRAME) {
+    g_assert (va_frame->update_index == 0);
+    g_assert (va_frame->flags & FRAME_FLAG_UPDATE_REF);
+
+    for (i = 0; i < GST_VP9_REF_FRAMES; i++) {
+      if (self->gop.ref_list[i] == NULL)
+        continue;
+
+      g_queue_remove (&base->ref_list, self->gop.ref_list[i]);
+      gst_video_codec_frame_unref (self->gop.ref_list[i]);
+      self->gop.ref_list[i] = NULL;
+    }
+
+    g_assert (g_queue_is_empty (&base->ref_list));
+  }
+
+  /* We drop ourself. */
+  if (va_frame->update_index < 0) {
+    GST_DEBUG_OBJECT (self, "Drop the non ref frame %d,"
+        " reference list unchanged", va_frame->frame_num);
+    return;
+  }
+
+  del_f = self->gop.ref_list[va_frame->update_index];
+
+  g_queue_push_tail (&base->ref_list, gst_video_codec_frame_ref (frame));
+  self->gop.ref_list[va_frame->update_index] = frame;
+
+  _vp9_print_ref_list_update (self, va_frame->update_index, del_f, frame);
+
+  if (del_f) {
+    g_queue_remove (&base->ref_list, del_f);
+    gst_video_codec_frame_unref (del_f);
+  }
+}
+
+static void
+gst_va_vp9_enc_reset_state (GstVaBaseEnc * base)
+{
+  GstVaVp9Enc *self = GST_VA_VP9_ENC (base);
+
+  GST_VA_BASE_ENC_CLASS (parent_class)->reset_state (base);
+
+  GST_OBJECT_LOCK (self);
+  self->rc.rc_ctrl_mode = self->prop.rc_ctrl;
+  self->rc.target_usage = self->prop.target_usage;
+  self->rc.base_qindex = self->prop.qp;
+  self->rc.min_qindex = self->prop.min_qp;
+  self->rc.max_qindex = self->prop.max_qp;
+  self->rc.target_percentage = self->prop.target_percentage;
+  self->rc.cpb_size = self->prop.cpb_size;
+  self->rc.mbbrc = self->prop.mbbrc;
+  self->rc.filter_level = self->prop.filter_level;
+  self->rc.sharpness_level = self->prop.sharpness_level;
+
+  self->gop.keyframe_interval = self->prop.keyframe_interval;
+  self->gop.gf_group_size = self->prop.gf_group_size;
+  self->gop.num_ref_frames = self->prop.num_ref_frames;
+  self->gop.max_level = self->prop.max_hierarchical_level;
+  GST_OBJECT_UNLOCK (self);
+
+  self->packed_headers = 0;
+
+  self->depth = 0;
+  self->chrome = 0;
+
+  _vp9_init_gf_group (&self->gop.current_group, &base->reorder_list);
+  self->gop.last_keyframe = NULL;
+  memset (self->gop.ref_list, 0, sizeof (self->gop.ref_list));
+  self->gop.frame_num_since_kf = 0;
+  self->gop.forward_ref_num = 0;
+  self->gop.backward_ref_num = 0;
+
+  self->rc.max_bitrate = 0;
+  self->rc.target_bitrate = 0;
+  self->rc.max_bitrate_bits = 0;
+  self->rc.cpb_length_bits = 0;
+
+  memset (self->frames_in_super, 0, sizeof (self->frames_in_super));
+  self->frames_in_super_num = 0;
+}
+
+static guint
+_vp9_get_rtformat (GstVaVp9Enc * self, GstVideoFormat format,
+    guint * depth, guint * chrome)
+{
+  guint chroma;
+
+  chroma = gst_va_chroma_from_video_format (format);
+
+  switch (chroma) {
+    case VA_RT_FORMAT_YUV400:
+      *depth = 8;
+      *chrome = 0;
+      break;
+    case VA_RT_FORMAT_YUV420:
+      *depth = 8;
+      *chrome = 1;
+      break;
+    case VA_RT_FORMAT_YUV420_10:
+      *depth = 10;
+      *chrome = 1;
+      break;
+    case VA_RT_FORMAT_YUV444:
+      *depth = 8;
+      *chrome = 3;
+      break;
+    case VA_RT_FORMAT_YUV422_10:
+      *depth = 10;
+      *chrome = 2;
+      break;
+    default:
+      chroma = 0;
+      GST_ERROR_OBJECT (self, "Unsupported chroma for video format: %s",
+          gst_video_format_to_string (format));
+      break;
+  }
+
+  return chroma;
+}
+
+#define update_property(type, obj, old_val, new_val, prop_id)           \
+  gst_va_base_enc_update_property_##type (obj, old_val, new_val, properties[prop_id])
+#define update_property_uint(obj, old_val, new_val, prop_id)    \
+  update_property (uint, obj, old_val, new_val, prop_id)
+#define update_property_bool(obj, old_val, new_val, prop_id)    \
+  update_property (bool, obj, old_val, new_val, prop_id)
+
+static gboolean
+_vp9_decide_profile (GstVaVp9Enc * self)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  gboolean ret = FALSE;
+  GstCaps *allowed_caps = NULL;
+  guint num_structures, i;
+  GstStructure *structure;
+  const GValue *v_profile;
+  GArray *candidates = NULL;
+  VAProfile va_profile;
+
+  candidates = g_array_new (TRUE, TRUE, sizeof (VAProfile));
+
+  /* First, check whether the downstream requires a specified profile. */
+  allowed_caps = gst_pad_get_allowed_caps (GST_VIDEO_ENCODER_SRC_PAD (base));
+  if (!allowed_caps)
+    allowed_caps = gst_pad_query_caps (GST_VIDEO_ENCODER_SRC_PAD (base), NULL);
+
+  if (allowed_caps && !gst_caps_is_empty (allowed_caps)) {
+    num_structures = gst_caps_get_size (allowed_caps);
+    for (i = 0; i < num_structures; i++) {
+      structure = gst_caps_get_structure (allowed_caps, i);
+      v_profile = gst_structure_get_value (structure, "profile");
+      if (!v_profile)
+        continue;
+
+      if (G_VALUE_HOLDS_STRING (v_profile)) {
+        va_profile =
+            gst_va_profile_from_name (VP9, g_value_get_string (v_profile));
+        g_array_append_val (candidates, va_profile);
+      } else if (GST_VALUE_HOLDS_LIST (v_profile)) {
+        guint j;
+
+        for (j = 0; j < gst_value_list_get_size (v_profile); j++) {
+          const GValue *p = gst_value_list_get_value (v_profile, j);
+          if (!p)
+            continue;
+
+          va_profile = gst_va_profile_from_name (VP9, g_value_get_string (p));
+          g_array_append_val (candidates, va_profile);
+        }
+      }
+    }
+  }
+
+  if (candidates->len == 0) {
+    GST_ERROR_OBJECT (self, "No available profile in caps");
+    ret = FALSE;
+    goto out;
+  }
+
+  va_profile = VAProfileNone;
+  /* Profile Color | Depth Chroma | Subsampling
+     0             | 8 bit/sample | 4:2:0
+     1             | 8 bit        | 4:2:2, 4:4:4
+     2             | 10 or 12 bit | 4:2:0
+     3             | 10 or 12 bit | 4:2:2, 4:4:4     */
+  if (self->chrome == 3 || self->chrome == 2) {
+    /* 4:4:4 and 4:2:2 */
+    if (self->depth == 8) {
+      va_profile = VAProfileVP9Profile1;
+    } else if (self->depth == 10 || self->depth == 12) {
+      va_profile = VAProfileVP9Profile3;
+    }
+  } else if (self->chrome == 1) {
+    /* 4:2:0 */
+    if (self->depth == 8) {
+      va_profile = VAProfileVP9Profile0;
+    } else if (self->depth == 10 || self->depth == 12) {
+      va_profile = VAProfileVP9Profile2;
+    }
+  }
+
+  if (va_profile == VAProfileNone) {
+    GST_ERROR_OBJECT (self, "Fails to find a suitable profile");
+    ret = FALSE;
+    goto out;
+  }
+
+  ret = FALSE;
+  for (i = 0; i < candidates->len; i++) {
+    VAProfile p;
+
+    p = g_array_index (candidates, VAProfile, i);
+    if (!gst_va_encoder_has_profile (base->encoder, p))
+      continue;
+
+    if ((base->rt_format & gst_va_encoder_get_rtformat (base->encoder,
+                p, GST_VA_BASE_ENC_ENTRYPOINT (base))) == 0)
+      continue;
+
+    if (p == va_profile) {
+      base->profile = p;
+      ret = TRUE;
+      goto out;
+    }
+  }
+
+out:
+  if (ret)
+    GST_INFO_OBJECT (self, "Decide the profile: %s",
+        gst_va_profile_name (base->profile));
+
+  return ret;
+}
+
+static gboolean
+_vp9_generate_gop_structure (GstVaVp9Enc * self)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint32 list0, list1;
+
+  /* If not set, generate a key frame every 2 second */
+  if (self->gop.keyframe_interval == 0) {
+    self->gop.keyframe_interval =
+        (2 * GST_VIDEO_INFO_FPS_N (&base->input_state->info)
+        + GST_VIDEO_INFO_FPS_D (&base->input_state->info) - 1) /
+        GST_VIDEO_INFO_FPS_D (&base->input_state->info);
+  }
+
+  if (self->gop.keyframe_interval > MAX_KEY_FRAME_INTERVAL)
+    self->gop.keyframe_interval = MAX_KEY_FRAME_INTERVAL;
+
+  if (self->gop.gf_group_size >= self->gop.keyframe_interval)
+    self->gop.gf_group_size = self->gop.keyframe_interval - 1;
+
+  /* VP9 does not define reference list1 in spec. */
+  if (!gst_va_encoder_get_max_num_reference (base->encoder, base->profile,
+          GST_VA_BASE_ENC_ENTRYPOINT (base), NULL, &list0, NULL)) {
+    GST_INFO_OBJECT (self, "Failed to get the max num reference");
+    list0 = 1;
+  }
+
+  /* At most, 3 forward refs */
+  if (list0 > 3)
+    list0 = 3;
+
+  if (self->gop.num_ref_frames == 0) {
+    list0 = 0;
+    list1 = 0;
+    self->gop.keyframe_interval = 1;
+    self->gop.gf_group_size = 0;
+    GST_INFO_OBJECT (self,
+        "No reference for each frame, key frame only stream");
+  } else if (self->gop.num_ref_frames <= 2 || list0 <= 2) {
+    list0 = MIN (self->gop.num_ref_frames, list0);
+    list1 = 0;
+    self->gop.num_ref_frames = list0;
+    GST_INFO_OBJECT (self, "Only %d reference frames, disable backward ref",
+        self->gop.num_ref_frames);
+  } else {
+    self->gop.num_ref_frames = 3;
+
+    /* Only I/P mode is needed */
+    if (self->gop.max_level < 2 || self->gop.gf_group_size < 3) {
+      list1 = 3;
+      list0 = 0;
+    } else {
+      list0 = 2;
+      list1 = 1;
+    }
+  }
+
+  /* Check the ref num again after adjust. */
+  if (self->gop.num_ref_frames == 0) {
+    list0 = 0;
+    list1 = 0;
+    self->gop.keyframe_interval = 1;
+    self->gop.gf_group_size = 0;
+    GST_INFO_OBJECT (self,
+        "No reference for each frame, key frame only stream");
+  }
+
+  self->gop.forward_ref_num = list0;
+  self->gop.backward_ref_num = list1;
+
+  if (self->gop.backward_ref_num == 0)
+    self->gop.max_level = 1;
+
+  GST_INFO_OBJECT (self, "key frame interval %d, golden frame group size %d,"
+      " max hierarchical level %d, reference num %d, forward ref num %d,"
+      " backward ref num %d", self->gop.keyframe_interval,
+      self->gop.gf_group_size, self->gop.max_level, self->gop.num_ref_frames,
+      self->gop.forward_ref_num, self->gop.backward_ref_num);
+
+  update_property_uint (base, &self->prop.keyframe_interval,
+      self->gop.keyframe_interval, PROP_KEYFRAME_INT);
+  update_property_uint (base, &self->prop.gf_group_size,
+      self->gop.gf_group_size, PROP_GOLDEN_GROUP_SIZE);
+  update_property_uint (base, &self->prop.num_ref_frames,
+      self->gop.num_ref_frames, PROP_NUM_REF_FRAMES);
+  update_property_uint (base, &self->prop.max_hierarchical_level,
+      self->gop.max_level, PROP_HIERARCHICAL_LEVEL);
+
+  _vp9_init_gf_group (&self->gop.current_group, &base->reorder_list);
+
+  return TRUE;
+}
+
+static void
+_vp9_calculate_coded_size (GstVaVp9Enc * self)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint codedbuf_size = 0;
+  gint width = GST_ROUND_UP_16 (base->width);
+  gint height = GST_ROUND_UP_16 (base->height);
+
+  switch (self->chrome) {
+    case 0:
+      /* 4:0:0 */
+    case 1:
+      /* 4:2:0 */
+      codedbuf_size = (width * height * 3 / 2);
+      break;
+    case 2:
+      /* 4:2:2 */
+      codedbuf_size = (width * height * 2);
+      break;
+    case 3:
+      /* 4:4:4 */
+      codedbuf_size = (width * height * 3);
+      break;
+    default:
+      g_assert_not_reached ();
+      break;
+  }
+
+  codedbuf_size = codedbuf_size + (codedbuf_size * (self->depth - 8) / 8);
+  /* FIXME: Just use a rough 1/2 min compression ratio here. */
+  codedbuf_size = codedbuf_size / 2;
+
+  base->codedbuf_size = codedbuf_size;
+
+  GST_INFO_OBJECT (self, "Calculate codedbuf size: %u", base->codedbuf_size);
+}
+
+/* Normalizes bitrate (and CPB size) for HRD conformance */
+static void
+_vp9_calculate_bitrate_hrd (GstVaVp9Enc * self)
+{
+  guint bitrate_bits, cpb_bits_size;
+
+  bitrate_bits = self->rc.max_bitrate * 1000;
+  GST_DEBUG_OBJECT (self, "Max bitrate: %u bits/sec", bitrate_bits);
+  self->rc.max_bitrate_bits = bitrate_bits;
+
+  bitrate_bits = self->rc.target_bitrate * 1000;
+  GST_DEBUG_OBJECT (self, "Target bitrate: %u bits/sec", bitrate_bits);
+  self->rc.target_bitrate_bits = bitrate_bits;
+
+  if (self->rc.cpb_size > 0 && self->rc.cpb_size < (self->rc.max_bitrate / 2)) {
+    GST_INFO_OBJECT (self, "Too small cpb_size: %d", self->rc.cpb_size);
+    self->rc.cpb_size = 0;
+  }
+
+  if (self->rc.cpb_size == 0) {
+    /* We cache 2 second coded data by default. */
+    self->rc.cpb_size = self->rc.max_bitrate * 2;
+    GST_INFO_OBJECT (self, "Adjust cpb_size to: %d", self->rc.cpb_size);
+  }
+
+  cpb_bits_size = self->rc.cpb_size * 1000;
+
+  GST_DEBUG_OBJECT (self, "HRD CPB size: %u bits", cpb_bits_size);
+  self->rc.cpb_length_bits = cpb_bits_size;
+}
+
+static guint
+_vp9_adjust_loopfilter_level_based_on_qindex (guint qindex)
+{
+  if (qindex >= 40) {
+    return (gint32) (-18.98682 + 0.3967082 * (gfloat) qindex +
+        0.0005054 * pow ((float) qindex - 127.5, 2) -
+        9.692e-6 * pow ((float) qindex - 127.5, 3));
+  } else {
+    return qindex / 4;
+  }
+}
+
+/* Estimates a good enough bitrate if none was supplied */
+static gboolean
+_vp9_ensure_rate_control (GstVaVp9Enc * self)
+{
+  /* User can specify the properties of: "bitrate", "target-percentage",
+   * "max-qp", "min-qp", "qp", "loop-filter-level", "sharpness-level",
+   * "mbbrc", "cpb-size", "rate-control" and "target-usage" to control
+   * the RC behavior.
+   *
+   * "target-usage" is different from the others, it controls the encoding
+   * speed and quality, while the others control encoding bit rate and
+   * quality. The lower value has better quality(maybe bigger MV search
+   * range) but slower speed, the higher value has faster speed but lower
+   * quality.
+   *
+   * The possible composition to control the bit rate and quality:
+   *
+   * 1. CQP mode: "rate-control=cqp", then "qp"(the qindex in VP9) specify
+   *    the QP of frames(within the "max-qp" and "min-qp" range). The QP
+   *    will not change during the whole stream. "loop-filter-level" and
+   *    "sharpness-level" together determine how much the filtering can
+   *    change the sample values. Other properties related to rate control
+   *    are ignored.
+   *
+   * 2. CBR mode: "rate-control=CBR", then the "bitrate" specify the
+   *    target bit rate and the "cpb-size" specifies the max coded
+   *    picture buffer size to avoid overflow. If the "bitrate" is not
+   *    set, it is calculated by the picture resolution and frame
+   *    rate. If "cpb-size" is not set, it is set to the size of
+   *    caching 2 second coded data. Encoder will try its best to make
+   *    the QP with in the ["max-qp", "min-qp"] range. "mbbrc" can
+   *    enable bit rate control in macro block level. Other paramters
+   *    are ignored.
+   *
+   * 3. VBR mode: "rate-control=VBR", then the "bitrate" specify the
+   *    target bit rate, "target-percentage" is used to calculate the
+   *    max bit rate of VBR mode by ("bitrate" * 100) /
+   *    "target-percentage". It is also used by driver to calculate
+   *    the min bit rate. The "cpb-size" specifies the max coded
+   *    picture buffer size to avoid overflow. If the "bitrate" is not
+   *    set, the target bit rate will be calculated by the picture
+   *    resolution and frame rate. Encoder will try its best to make
+   *    the QP with in the ["max-qp", "min-qp"] range. "mbbrc" can
+   *    enable bit rate control in macro block level. Other paramters
+   *    are ignored.
+   *
+   * 4. VCM mode: "rate-control=VCM", then the "bitrate" specify the
+   *    target bit rate, and encoder will try its best to make the QP
+   *    with in the ["max-qp", "min-qp"] range. Other paramters are
+   *    ignored.
+   */
+
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint bitrate;
+  guint32 rc_ctrl, rc_mode, quality_level;
+
+  quality_level = gst_va_encoder_get_quality_level (base->encoder,
+      base->profile, GST_VA_BASE_ENC_ENTRYPOINT (base));
+  if (self->rc.target_usage > quality_level) {
+    GST_INFO_OBJECT (self, "User setting target-usage: %d is not supported, "
+        "fallback to %d", self->rc.target_usage, quality_level);
+    self->rc.target_usage = quality_level;
+
+    update_property_uint (base, &self->prop.target_usage, self->rc.target_usage,
+        PROP_TARGET_USAGE);
+  }
+
+  GST_OBJECT_LOCK (self);
+  rc_ctrl = self->prop.rc_ctrl;
+  GST_OBJECT_UNLOCK (self);
+
+  if (rc_ctrl != VA_RC_NONE) {
+    rc_mode = gst_va_encoder_get_rate_control_mode (base->encoder,
+        base->profile, GST_VA_BASE_ENC_ENTRYPOINT (base));
+    if (!(rc_mode & rc_ctrl)) {
+      guint32 defval =
+          G_PARAM_SPEC_ENUM (properties[PROP_RATE_CONTROL])->default_value;
+      GST_INFO_OBJECT (self, "The rate control mode %s is not supported, "
+          "fallback to %s mode", _rate_control_get_name (rc_ctrl),
+          _rate_control_get_name (defval));
+      self->rc.rc_ctrl_mode = defval;
+
+      update_property_uint (base, &self->prop.rc_ctrl, self->rc.rc_ctrl_mode,
+          PROP_RATE_CONTROL);
+    }
+  } else {
+    self->rc.rc_ctrl_mode = VA_RC_NONE;
+  }
+
+  if (self->rc.min_qindex > self->rc.max_qindex) {
+    GST_INFO_OBJECT (self, "The min_qindex %d is bigger than the max_qindex"
+        " %d, set it to the max_qindex", self->rc.min_qindex,
+        self->rc.max_qindex);
+    self->rc.min_qindex = self->rc.max_qindex;
+
+    update_property_uint (base, &self->prop.min_qp, self->rc.min_qindex,
+        PROP_MIN_QP);
+  }
+
+  /* Make the qp in the valid range */
+  if (self->rc.base_qindex < self->rc.min_qindex) {
+    if (self->rc.base_qindex != DEFAULT_BASE_QINDEX)
+      GST_INFO_OBJECT (self, "The base_qindex %d is smaller than the"
+          " min_qindex %d, set it to the min_qindex", self->rc.base_qindex,
+          self->rc.min_qindex);
+    self->rc.base_qindex = self->rc.min_qindex;
+  }
+  if (self->rc.base_qindex > self->rc.max_qindex) {
+    if (self->rc.base_qindex != DEFAULT_BASE_QINDEX)
+      GST_INFO_OBJECT (self, "The base_qindex %d is bigger than the"
+          " max_qindex %d, set it to the max_qindex", self->rc.base_qindex,
+          self->rc.max_qindex);
+    self->rc.base_qindex = self->rc.max_qindex;
+  }
+
+  /* Calculate the loop filter level. */
+  if (self->rc.rc_ctrl_mode == VA_RC_CQP) {
+    if (self->rc.filter_level == -1)
+      self->rc.filter_level =
+          _vp9_adjust_loopfilter_level_based_on_qindex (self->rc.base_qindex);
+  }
+
+  GST_OBJECT_LOCK (self);
+  bitrate = self->prop.bitrate;
+  GST_OBJECT_UNLOCK (self);
+
+  /* Calculate a bitrate if it is not set. */
+  if ((self->rc.rc_ctrl_mode == VA_RC_CBR || self->rc.rc_ctrl_mode == VA_RC_VBR
+          || self->rc.rc_ctrl_mode == VA_RC_VCM) && bitrate == 0) {
+    /* FIXME: Provide better estimation. */
+    /* Choose the max value of all levels' MainCR which is 8, and x2 for
+       conservative calculation. So just using a 1/16 compression ratio,
+       12 bits per pixel for 4:2:0, 16 bits per pixel for 4:2:2 and 24 bits
+       per pixel for 4:4:4. Also the depth should be considered. */
+    guint64 factor;
+    guint depth = 8, chrome = 1;
+    guint bits_per_pix;
+
+    if (!_vp9_get_rtformat (self,
+            GST_VIDEO_INFO_FORMAT (&base->input_state->info), &depth, &chrome))
+      g_assert_not_reached ();
+
+    if (chrome == 3) {
+      bits_per_pix = 24;
+    } else if (chrome == 2) {
+      bits_per_pix = 16;
+    } else {
+      bits_per_pix = 12;
+    }
+    bits_per_pix = bits_per_pix + bits_per_pix * (depth - 8) / 8;
+
+    factor = (guint64) base->width * base->height * bits_per_pix / 16;
+    bitrate = gst_util_uint64_scale (factor,
+        GST_VIDEO_INFO_FPS_N (&base->input_state->info),
+        GST_VIDEO_INFO_FPS_D (&base->input_state->info)) / 1000;
+
+    GST_INFO_OBJECT (self, "target bitrate computed to %u kbps", bitrate);
+
+    self->prop.bitrate = bitrate;
+    g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_BITRATE]);
+  }
+
+  /* Adjust the setting based on RC mode. */
+  switch (self->rc.rc_ctrl_mode) {
+    case VA_RC_CQP:
+      self->rc.max_bitrate = 0;
+      self->rc.target_bitrate = 0;
+      self->rc.target_percentage = 0;
+      self->rc.cpb_size = 0;
+      self->rc.mbbrc = 0;
+      break;
+    case VA_RC_CBR:
+      self->rc.max_bitrate = bitrate;
+      self->rc.target_bitrate = bitrate;
+      self->rc.target_percentage = 100;
+      self->rc.base_qindex = DEFAULT_BASE_QINDEX;
+      self->rc.filter_level = DEFAULT_LOOP_FILTER_LEVEL;
+      self->rc.sharpness_level = 0;
+      break;
+    case VA_RC_VBR:
+      g_assert (self->rc.target_percentage >= 10);
+      self->rc.max_bitrate = (guint) gst_util_uint64_scale_int (bitrate,
+          100, self->rc.target_percentage);
+      self->rc.target_bitrate = bitrate;
+      self->rc.base_qindex = DEFAULT_BASE_QINDEX;
+      self->rc.filter_level = DEFAULT_LOOP_FILTER_LEVEL;
+      self->rc.sharpness_level = 0;
+      break;
+    case VA_RC_VCM:
+      self->rc.max_bitrate = bitrate;
+      self->rc.target_bitrate = bitrate;
+      self->rc.target_percentage = 0;
+      self->rc.base_qindex = DEFAULT_BASE_QINDEX;
+      self->rc.filter_level = DEFAULT_LOOP_FILTER_LEVEL;
+      self->rc.sharpness_level = 0;
+      self->rc.cpb_size = 0;
+
+      if (self->gop.max_level > 1) {
+        GST_INFO_OBJECT (self, "VCM mode does not reorder frames");
+        self->gop.max_level = 1;
+      }
+      break;
+    default:
+      GST_WARNING_OBJECT (self, "Unsupported rate control");
+      return FALSE;
+      break;
+  }
+
+  GST_DEBUG_OBJECT (self, "Max bitrate: %u bits/sec, "
+      "Target bitrate: %u bits/sec", self->rc.max_bitrate,
+      self->rc.target_bitrate);
+
+  if (self->rc.rc_ctrl_mode != VA_RC_NONE && self->rc.rc_ctrl_mode != VA_RC_CQP)
+    _vp9_calculate_bitrate_hrd (self);
+
+  /* notifications */
+  update_property_uint (base, &self->prop.cpb_size, self->rc.cpb_size,
+      PROP_CPB_SIZE);
+  update_property_uint (base, &self->prop.target_percentage,
+      self->rc.target_percentage, PROP_TARGET_PERCENTAGE);
+  update_property_uint (base, &self->prop.qp, self->rc.base_qindex, PROP_QP);
+  update_property_uint (base, ((guint *) (&self->prop.filter_level)),
+      self->rc.filter_level, PROP_LOOP_FILTER_LEVEL);
+  update_property_uint (base, &self->prop.sharpness_level,
+      self->rc.sharpness_level, PROP_SHARPNESS_LEVEL);
+  update_property_uint (base, &self->prop.mbbrc, self->rc.mbbrc, PROP_MBBRC);
+
+  return TRUE;
+}
+
+static gboolean
+_vp9_init_packed_headers (GstVaVp9Enc * self)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint32 packed_headers;
+
+  if (!gst_va_encoder_get_packed_headers (base->encoder, base->profile,
+          GST_VA_BASE_ENC_ENTRYPOINT (base), &packed_headers))
+    return FALSE;
+
+  /* TODO: Need to implement bitwriter for VP9. */
+  if (packed_headers & (VA_ENC_PACKED_HEADER_SEQUENCE |
+          VA_ENC_PACKED_HEADER_PICTURE | VA_ENC_PACKED_HEADER_SLICE)) {
+    GST_ERROR_OBJECT (self,
+        "The packed header of VP9 is not supported now. "
+        "The driver need to generate VP9 frame headers by itself.");
+    return FALSE;
+  }
+
+  /* VP9 does not support meta data, either. */
+  self->packed_headers = 0;
+
+  return TRUE;
+}
+
+static gboolean
+gst_va_vp9_enc_reconfig (GstVaBaseEnc * base)
+{
+  GstVideoEncoder *venc = GST_VIDEO_ENCODER (base);
+  GstVaVp9Enc *self = GST_VA_VP9_ENC (base);
+  GstCaps *out_caps;
+  GstVideoCodecState *output_state;
+  GstVideoFormat in_format;
+  guint max_ref_frames;
+
+  gst_va_base_enc_reset_state (base);
+
+  base->width = GST_VIDEO_INFO_WIDTH (&base->input_state->info);
+  base->height = GST_VIDEO_INFO_HEIGHT (&base->input_state->info);
+
+  /* Frame rate is needed for rate control and PTS setting. */
+  if (GST_VIDEO_INFO_FPS_N (&base->input_state->info) == 0
+      || GST_VIDEO_INFO_FPS_D (&base->input_state->info) == 0) {
+    GST_INFO_OBJECT (self, "Unknown framerate, just set to 30 fps");
+    GST_VIDEO_INFO_FPS_N (&base->input_state->info) = 30;
+    GST_VIDEO_INFO_FPS_D (&base->input_state->info) = 1;
+  }
+  base->frame_duration = gst_util_uint64_scale (GST_SECOND,
+      GST_VIDEO_INFO_FPS_D (&base->input_state->info),
+      GST_VIDEO_INFO_FPS_N (&base->input_state->info));
+
+  in_format = GST_VIDEO_INFO_FORMAT (&base->input_state->info);
+  base->rt_format =
+      _vp9_get_rtformat (self, in_format, &self->depth, &self->chrome);
+  if (!base->rt_format) {
+    GST_ERROR_OBJECT (self, "unrecognized input format.");
+    return FALSE;
+  }
+
+  if (!_vp9_decide_profile (self))
+    return FALSE;
+
+  if (!_vp9_ensure_rate_control (self))
+    return FALSE;
+
+  if (!_vp9_generate_gop_structure (self))
+    return FALSE;
+
+  _vp9_calculate_coded_size (self);
+
+  if (!_vp9_init_packed_headers (self))
+    return FALSE;
+
+  max_ref_frames = GST_VP9_REF_FRAMES + 3 /* scratch frames */ ;
+  if (!gst_va_encoder_open (base->encoder, base->profile,
+          GST_VIDEO_INFO_FORMAT (&base->input_state->info), base->rt_format,
+          base->width, base->height, base->codedbuf_size, max_ref_frames,
+          self->rc.rc_ctrl_mode, self->packed_headers)) {
+    GST_ERROR_OBJECT (self, "Failed to open the VA encoder.");
+    return FALSE;
+  }
+
+  /* Add some tags */
+  gst_va_base_enc_add_codec_tag (base, "VP9");
+
+  out_caps = gst_va_profile_caps (base->profile);
+  g_assert (out_caps);
+  out_caps = gst_caps_fixate (out_caps);
+
+  gst_caps_set_simple (out_caps, "width", G_TYPE_INT, base->width,
+      "height", G_TYPE_INT, base->height, "alignment",
+      G_TYPE_STRING, "super-frame", NULL);
+
+  GST_DEBUG_OBJECT (self, "output caps is %" GST_PTR_FORMAT, out_caps);
+
+  output_state =
+      gst_video_encoder_set_output_state (venc, out_caps, base->input_state);
+  gst_video_codec_state_unref (output_state);
+
+  if (!gst_video_encoder_negotiate (venc)) {
+    GST_ERROR_OBJECT (self, "Failed to negotiate with the downstream");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static void
+_vp9_clear_super_frames (GstVaVp9Enc * self)
+{
+  guint i;
+  GstVaVp9EncFrame *frame_enc;
+
+  for (i = 0; i < self->frames_in_super_num; i++) {
+    frame_enc = _enc_frame (self->frames_in_super[i]);
+    frame_enc->flags &= (~FRAME_FLAG_IN_SUPER_FRAME);
+  }
+
+  memset (self->frames_in_super, 0, sizeof (self->frames_in_super));
+  self->frames_in_super_num = 0;
+}
+
+static gboolean
+gst_va_vp9_enc_flush (GstVideoEncoder * venc)
+{
+  GstVaVp9Enc *self = GST_VA_VP9_ENC (venc);
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+
+  _vp9_clear_super_frames (self);
+
+  /* begin from an key frame after flush. */
+  self->gop.frame_num_since_kf = 0;
+
+  /* Parent's flush will release all frames for us. */
+  _vp9_init_gf_group (&self->gop.current_group, &base->reorder_list);
+  self->gop.last_keyframe = NULL;
+  memset (self->gop.ref_list, 0, sizeof (self->gop.ref_list));
+
+  return GST_VIDEO_ENCODER_CLASS (parent_class)->flush (venc);
+}
+
+static void
+_vp9_fill_sequence_param (GstVaVp9Enc * self,
+    VAEncSequenceParameterBufferVP9 * sequence)
+{
+  /* *INDENT-OFF* */
+  *sequence = (VAEncSequenceParameterBufferVP9) {
+    .max_frame_width = MAX_FRAME_WIDTH,
+    .max_frame_height = MAX_FRAME_HEIGHT,
+    .kf_auto = 0,
+    .kf_min_dist = 1,
+    .kf_max_dist = self->gop.keyframe_interval,
+    .intra_period = self->gop.keyframe_interval,
+    .bits_per_second = self->rc.target_bitrate_bits,
+  };
+  /* *INDENT-ON* */
+}
+
+static gboolean
+_vp9_add_sequence_param (GstVaVp9Enc * self, GstVaEncodePicture * picture,
+    VAEncSequenceParameterBufferVP9 * sequence)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+
+  if (!gst_va_encoder_add_param (base->encoder, picture,
+          VAEncSequenceParameterBufferType, sequence, sizeof (*sequence))) {
+    GST_ERROR_OBJECT (self, "Failed to create the sequence parameter");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+_vp9_fill_frame_param (GstVaVp9Enc * self, GstVaVp9EncFrame * va_frame,
+    VAEncPictureParameterBufferVP9 * pic_param)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  uint8_t refresh_frame_flags = 0xff;
+  gint sb_cols = 0, min_log2_tile_columns = 0;
+  guint i;
+
+  g_assert (!(va_frame->type & FRAME_TYPE_REPEAT));
+
+  /* Maximum width of a tile in units of superblocks is MAX_TILE_WIDTH_B64(64).
+     When the width is big enough to partition more than MAX_TILE_WIDTH_B64(64)
+     superblocks, we need multi tiles to handle it. */
+  sb_cols = (base->width + 63) / 64;
+  while ((MAX_TILE_WIDTH_B64 << min_log2_tile_columns) < sb_cols)
+    ++min_log2_tile_columns;
+
+  /* *INDENT-OFF* */
+  if (va_frame->type != GST_VP9_KEY_FRAME) {
+    if (va_frame->update_index >= 0) {
+      refresh_frame_flags = (1 << va_frame->update_index);
+    } else {
+      refresh_frame_flags = 0;
+    }
+  }
+
+  *pic_param = (VAEncPictureParameterBufferVP9) {
+    .frame_width_src = base->width,
+    .frame_height_src = base->height,
+    .frame_width_dst = base->width,
+    .frame_height_dst = base->height,
+    .reconstructed_frame =
+        gst_va_encode_picture_get_reconstruct_surface (va_frame->picture),
+    /* Set it later. */
+    .reference_frames = { },
+    .coded_buf = va_frame->picture->coded_buffer,
+    .ref_flags.bits = {
+      .force_kf = 0,
+      /* Set all the refs later if inter frame. */
+      .ref_frame_ctrl_l0 = 0,
+      .ref_frame_ctrl_l1 = 0,
+      .ref_last_idx = 0,
+      .ref_last_sign_bias = 0,
+      .ref_gf_idx = 0,
+      .ref_gf_sign_bias = 0,
+      .ref_arf_idx = 0,
+      .ref_arf_sign_bias = 0,
+      /* Do not support multi temporal now. */
+      .temporal_id = 0,
+    },
+    .pic_flags.bits = {
+      .frame_type = va_frame->type,
+      .show_frame = !(va_frame->flags & FRAME_FLAG_NOT_SHOW),
+      /* We do not support error resilient mode now. */
+      .error_resilient_mode = 0,
+      .intra_only = 0,
+      .allow_high_precision_mv = 1,
+      .mcomp_filter_type = 0,
+      .frame_parallel_decoding_mode = 0,
+      .reset_frame_context = 0,
+      .refresh_frame_context = 0,
+      .frame_context_idx = 0,
+      .segmentation_enabled = 0,
+      .segmentation_temporal_update = 0,
+      .segmentation_update_map = 0,
+      /* Do not use lossless mode now. */
+      .lossless_mode = 0,
+      .comp_prediction_mode = 0,
+      .auto_segmentation = 0,
+      .super_frame_flag = 0,
+    },
+    .refresh_frame_flags = refresh_frame_flags,
+    .luma_ac_qindex = self->rc.base_qindex,
+    .luma_dc_qindex_delta = 0,
+    .chroma_ac_qindex_delta = 0,
+    .chroma_dc_qindex_delta = 0,
+    .filter_level = self->rc.filter_level,
+    .sharpness_level = self->rc.sharpness_level,
+    .ref_lf_delta = { },
+    .mode_lf_delta = { },
+    .bit_offset_ref_lf_delta = 0,
+    .bit_offset_mode_lf_delta = 0,
+    .bit_offset_lf_level = 0,
+    .bit_offset_qindex = 0,
+    .bit_offset_first_partition_size = 0,
+    .bit_offset_segmentation = 0,
+    .bit_size_segmentation = 0,
+    .log2_tile_rows = 0,
+    .log2_tile_columns = min_log2_tile_columns,
+    .skip_frame_flag = 0,
+  };
+  /* *INDENT-ON* */
+
+  if (va_frame->type == GST_VP9_INTER_FRAME) {
+    for (i = 0; i < 8; i++) {
+      if (self->gop.ref_list[i] == NULL) {
+        pic_param->reference_frames[i] = VA_INVALID_SURFACE;
+        continue;
+      }
+
+      pic_param->reference_frames[i] =
+          gst_va_encode_picture_get_reconstruct_surface
+          (_enc_frame (self->gop.ref_list[i])->picture);
+
+    }
+
+    pic_param->ref_flags.bits.ref_last_idx =
+        va_frame->ref_frame_idx[GST_VP9_REF_FRAME_LAST];
+    pic_param->ref_flags.bits.ref_gf_idx =
+        va_frame->ref_frame_idx[GST_VP9_REF_FRAME_GOLDEN];
+    pic_param->ref_flags.bits.ref_arf_idx =
+        va_frame->ref_frame_idx[GST_VP9_REF_FRAME_ALTREF];
+
+    pic_param->ref_flags.bits.ref_frame_ctrl_l0 = 0x7;
+    pic_param->ref_flags.bits.ref_frame_ctrl_l0 = 0x7;
+  } else {
+    for (i = 0; i < 8; i++)
+      pic_param->reference_frames[i] = VA_INVALID_SURFACE;
+
+    pic_param->ref_flags.bits.ref_last_idx = 0;
+    pic_param->ref_flags.bits.ref_gf_idx = 0;
+    pic_param->ref_flags.bits.ref_arf_idx = 0;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+_vp9_encode_one_frame (GstVaVp9Enc * self, GstVaVp9EncFrame * va_frame)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  VAEncPictureParameterBufferVP9 pic_param;
+
+  if (!_vp9_fill_frame_param (self, va_frame, &pic_param)) {
+    GST_ERROR_OBJECT (self, "Fails to fill the frame parameter.");
+    return FALSE;
+  }
+
+  if (!gst_va_encoder_add_param (base->encoder, va_frame->picture,
+          VAEncPictureParameterBufferType, &pic_param, sizeof (pic_param))) {
+    GST_ERROR_OBJECT (self, "Failed to create the frame parameter");
+    return FALSE;
+  }
+
+  if (!gst_va_encoder_encode (base->encoder, va_frame->picture)) {
+    GST_ERROR_OBJECT (self, "Encode frame error");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static void
+_vp9_add_repeat_frame_header (GstVaVp9Enc * self, GstVaVp9EncFrame * va_frame)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint profile = 0;
+  GstVp9FrameHdr frame_hdr;
+
+  switch (base->profile) {
+    case VAProfileVP9Profile0:
+      profile = 0;
+      break;
+    case VAProfileVP9Profile1:
+      profile = 1;
+      break;
+    case VAProfileVP9Profile2:
+      profile = 2;
+      break;
+    case VAProfileVP9Profile3:
+      profile = 3;
+      break;
+    default:
+      g_assert_not_reached ();
+      break;
+  }
+
+  g_assert (va_frame->repeat_index >= 0 && va_frame->repeat_index <= 7);
+
+  /* *INDENT-OFF* */
+  frame_hdr = (GstVp9FrameHdr) {
+    .profile = profile,
+    .show_existing_frame = 1,
+    .frame_to_show = va_frame->repeat_index,
+  };
+  /* *INDENT-ON* */
+
+  memset (va_frame->repeat_frame_header, 0,
+      sizeof (va_frame->repeat_frame_header));
+  va_frame->repeat_frame_header_size = sizeof (va_frame->repeat_frame_header);
+  gst_vp9_bit_writer_frame_header (&frame_hdr, va_frame->repeat_frame_header,
+      &va_frame->repeat_frame_header_size);
+}
+
+static GstFlowReturn
+gst_va_vp9_enc_encode_frame (GstVaBaseEnc * base,
+    GstVideoCodecFrame * gst_frame, gboolean is_last)
+{
+  GstVaVp9Enc *self = GST_VA_VP9_ENC (base);
+  GstVaVp9EncFrame *va_frame = _enc_frame (gst_frame);
+  VAEncSequenceParameterBufferVP9 seq_param;
+
+  if (!_vp9_assign_ref_index (self, gst_frame)) {
+    GST_ERROR_OBJECT (self, "Failed to assign reference for frame:"
+        "system_frame_number %d, frame_num: %d, frame_type %s",
+        gst_frame->system_frame_number, va_frame->frame_num,
+        _vp9_get_frame_type_name (va_frame->type));
+    return GST_FLOW_ERROR;
+  }
+
+  if (va_frame->type & FRAME_TYPE_REPEAT) {
+    g_assert (va_frame->flags & FRAME_FLAG_ALREADY_ENCODED);
+    _vp9_add_repeat_frame_header (self, va_frame);
+  } else {
+    g_assert (va_frame->picture == NULL);
+    va_frame->picture = gst_va_encode_picture_new (base->encoder,
+        gst_frame->input_buffer);
+
+    _vp9_find_ref_to_update (base, gst_frame);
+
+    /* Repeat the sequence for each key. */
+    if (va_frame->frame_num == 0) {
+      if (!gst_va_base_enc_add_rate_control_parameter (base, va_frame->picture,
+              self->rc.rc_ctrl_mode, self->rc.max_bitrate_bits,
+              self->rc.target_percentage, self->rc.base_qindex,
+              self->rc.min_qindex, self->rc.max_qindex, self->rc.mbbrc))
+        return FALSE;
+
+      if (!gst_va_base_enc_add_quality_level_parameter (base, va_frame->picture,
+              self->rc.target_usage))
+        return FALSE;
+
+      if (!gst_va_base_enc_add_frame_rate_parameter (base, va_frame->picture))
+        return FALSE;
+
+      if (!gst_va_base_enc_add_hrd_parameter (base, va_frame->picture,
+              self->rc.rc_ctrl_mode, self->rc.cpb_length_bits))
+        return FALSE;
+
+      _vp9_fill_sequence_param (self, &seq_param);
+      if (!_vp9_add_sequence_param (self, va_frame->picture, &seq_param))
+        return FALSE;
+    }
+
+    if (!_vp9_encode_one_frame (self, va_frame)) {
+      GST_ERROR_OBJECT (self, "Fails to encode one frame.");
+      return GST_FLOW_ERROR;
+    }
+
+    va_frame->flags |= FRAME_FLAG_ALREADY_ENCODED;
+  }
+
+  _vp9_update_ref_list (base, gst_frame);
+
+  g_queue_push_tail (&base->output_list, gst_video_codec_frame_ref (gst_frame));
+
+  return GST_FLOW_OK;
+}
+
+static GstBuffer *
+_vp9_create_super_frame_output_buffer (GstVaVp9Enc * self,
+    GstVideoCodecFrame * last_frame)
+{
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+  guint8 *data;
+  guint total_sz, offset;
+  GstVaVp9EncFrame *frame_enc;
+  GstBuffer *buf = NULL;
+  gint frame_size[GST_VP9_MAX_FRAMES_IN_SUPERFRAME] = { };
+  guint num;
+
+  g_assert ((_enc_frame (last_frame)->flags & FRAME_TYPE_REPEAT) == 0);
+  g_assert ((_enc_frame (last_frame)->flags & FRAME_FLAG_NOT_SHOW) == 0);
+  g_assert (self->frames_in_super_num <= GST_VP9_MAX_FRAMES_IN_SUPERFRAME - 1);
+
+  total_sz = self->frames_in_super_num * base->codedbuf_size;
+
+  data = g_malloc (total_sz);
+  if (!data)
+    goto error;
+
+  offset = 0;
+  for (num = 0; num < self->frames_in_super_num; num++) {
+    frame_enc = _enc_frame (self->frames_in_super[num]);
+
+    frame_size[num] = gst_va_base_enc_copy_output_data (base,
+        frame_enc->picture, data + offset, total_sz - offset);
+    if (frame_size[num] <= 0) {
+      GST_ERROR_OBJECT (self, "Fails to copy the output data of "
+          "system_frame_number %d, frame_num: %d",
+          self->frames_in_super[num]->system_frame_number,
+          frame_enc->frame_num);
+      goto error;
+    }
+
+    offset += frame_size[num];
+  }
+
+  frame_enc = _enc_frame (last_frame);
+  frame_size[num] = gst_va_base_enc_copy_output_data (base,
+      frame_enc->picture, data + offset, total_sz - offset);
+  if (frame_size[num] <= 0) {
+    GST_ERROR_OBJECT (self, "Fails to copy the output data of "
+        "system_frame_number %d, frame_num: %d",
+        last_frame->system_frame_number, frame_enc->frame_num);
+    goto error;
+  }
+  offset += frame_size[num];
+  num++;
+
+  if (gst_vp9_bit_writer_superframe_info (num, frame_size, data,
+          &total_sz) != GST_VP9_BIT_WRITER_OK)
+    goto error;
+
+  buf = gst_video_encoder_allocate_output_buffer
+      (GST_VIDEO_ENCODER_CAST (base), total_sz);
+  if (!buf) {
+    GST_ERROR_OBJECT (base, "Failed to create output buffer");
+    goto error;
+  }
+
+  if (gst_buffer_fill (buf, 0, data, total_sz) != total_sz) {
+    GST_ERROR_OBJECT (base, "Failed to write output buffer for super frame");
+    goto error;
+  }
+
+  g_free (data);
+
+  _vp9_clear_super_frames (self);
+
+  return buf;
+
+error:
+  {
+    if (data)
+      g_free (data);
+
+    _vp9_clear_super_frames (self);
+
+    gst_clear_buffer (&buf);
+
+    return NULL;
+  }
+}
+
+static gboolean
+gst_va_vp9_enc_prepare_output (GstVaBaseEnc * base,
+    GstVideoCodecFrame * frame, gboolean * complete)
+{
+  GstVaVp9Enc *self = GST_VA_VP9_ENC (base);
+  GstVaVp9EncFrame *frame_enc;
+  GstBuffer *buf = NULL;
+
+  frame_enc = _enc_frame (frame);
+
+  if (frame_enc->flags & FRAME_FLAG_NOT_SHOW &&
+      ((frame_enc->type & FRAME_TYPE_REPEAT) == 0)) {
+    self->frames_in_super[self->frames_in_super_num] = frame;
+    self->frames_in_super_num++;
+    g_assert (self->frames_in_super_num <=
+        GST_VP9_MAX_FRAMES_IN_SUPERFRAME - 1);
+    g_assert ((frame_enc->flags & FRAME_FLAG_IN_SUPER_FRAME) == 0);
+    g_assert ((frame_enc->flags & FRAME_FLAG_ALREADY_OUTPUTTED) == 0);
+
+    frame_enc->flags |= FRAME_FLAG_IN_SUPER_FRAME;
+    frame_enc->flags |= FRAME_FLAG_ALREADY_OUTPUTTED;
+
+    *complete = FALSE;
+
+    gst_buffer_replace (&frame->output_buffer, NULL);
+
+    return TRUE;
+  }
+
+  frame->pts =
+      base->start_pts + base->frame_duration * frame_enc->total_frame_count;
+  frame->dts =
+      base->start_pts + base->frame_duration * base->output_frame_count;
+  frame->duration = base->frame_duration;
+
+  if (frame_enc->flags & FRAME_FLAG_ALREADY_OUTPUTTED) {
+    gsize sz;
+
+    /* Already outputted, must be a repeat this time. */
+    g_assert (frame_enc->type & FRAME_TYPE_REPEAT);
+    /* Should already sync and complete in the super frame. */
+    g_assert ((frame_enc->flags & FRAME_FLAG_IN_SUPER_FRAME) == 0);
+
+    buf = gst_video_encoder_allocate_output_buffer
+        (GST_VIDEO_ENCODER_CAST (base), frame_enc->repeat_frame_header_size);
+    if (!buf) {
+      GST_ERROR_OBJECT (base, "Failed to create output buffer");
+      return FALSE;
+    }
+
+    sz = gst_buffer_fill (buf, 0, frame_enc->repeat_frame_header,
+        frame_enc->repeat_frame_header_size);
+
+    if (sz != frame_enc->repeat_frame_header_size) {
+      GST_ERROR_OBJECT (base, "Failed to write output buffer for repeat frame");
+      gst_clear_buffer (&buf);
+      return FALSE;
+    }
+
+    *complete = TRUE;
+  } else {
+    if (self->frames_in_super_num > 0) {
+      buf = _vp9_create_super_frame_output_buffer (self, frame);
+    } else {
+      buf = gst_va_base_enc_create_output_buffer (base, frame_enc->picture);
+    }
+    if (!buf) {
+      GST_ERROR_OBJECT (base, "Failed to create output buffer%s",
+          self->frames_in_super_num > 0 ? " for super frame" : "");
+      return FALSE;
+    }
+
+    *complete = TRUE;
+
+    frame_enc->flags |= FRAME_FLAG_ALREADY_OUTPUTTED;
+  }
+
+  gst_buffer_replace (&frame->output_buffer, buf);
+  gst_clear_buffer (&buf);
+
+  base->output_frame_count++;
+
+  return TRUE;
+}
+
+/* *INDENT-OFF* */
+static const gchar *sink_caps_str =
+    GST_VIDEO_CAPS_MAKE_WITH_FEATURES (GST_CAPS_FEATURE_MEMORY_VA,
+        "{ NV12 }") " ;"
+    GST_VIDEO_CAPS_MAKE ("{ NV12 }");
+/* *INDENT-ON* */
+
+static const gchar *src_caps_str = "video/x-vp9,alignment=(string)super-frame";
+
+static gpointer
+_register_debug_category (gpointer data)
+{
+  GST_DEBUG_CATEGORY_INIT (gst_va_vp9enc_debug, "vavp9enc", 0,
+      "VA vp9 encoder");
+
+  return NULL;
+}
+
+static void
+gst_va_vp9_enc_init (GTypeInstance * instance, gpointer g_class)
+{
+  GstVaVp9Enc *self = GST_VA_VP9_ENC (instance);
+
+  /* default values */
+  self->prop.bitrate = 0;
+  self->prop.target_usage = 4;
+  self->prop.cpb_size = 0;
+  self->prop.target_percentage = 66;
+  self->prop.gf_group_size = MAX_GF_GROUP_SIZE;
+  self->prop.num_ref_frames = 7;
+  self->prop.max_hierarchical_level = HIGHEST_PYRAMID_LEVELS;
+  self->prop.keyframe_interval = MAX_KEY_FRAME_INTERVAL;
+  self->prop.qp = DEFAULT_BASE_QINDEX;
+  self->prop.min_qp = 0;
+  self->prop.max_qp = 255;
+  self->prop.mbbrc = 0;
+  self->prop.filter_level = -1;
+  self->prop.sharpness_level = 0;
+
+  if (properties[PROP_RATE_CONTROL]) {
+    self->prop.rc_ctrl =
+        G_PARAM_SPEC_ENUM (properties[PROP_RATE_CONTROL])->default_value;
+  } else {
+    self->prop.rc_ctrl = VA_RC_NONE;
+  }
+}
+
+static void
+gst_va_vp9_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstVaVp9Enc *const self = GST_VA_VP9_ENC (object);
+  GstVaBaseEnc *base = GST_VA_BASE_ENC (self);
+
+  if (base->encoder && gst_va_encoder_is_open (base->encoder)) {
+    GST_ERROR_OBJECT (object,
+        "failed to set any property after encoding started");
+    return;
+  }
+
+  GST_OBJECT_LOCK (self);
+
+  switch (prop_id) {
+    case PROP_KEYFRAME_INT:
+      self->prop.keyframe_interval = g_value_get_uint (value);
+      break;
+    case PROP_GOLDEN_GROUP_SIZE:
+      self->prop.gf_group_size = g_value_get_uint (value);
+      break;
+    case PROP_NUM_REF_FRAMES:
+      self->prop.num_ref_frames = g_value_get_uint (value);
+      break;
+    case PROP_HIERARCHICAL_LEVEL:
+      self->prop.max_hierarchical_level = g_value_get_uint (value);
+      break;
+    case PROP_QP:
+      self->prop.qp = g_value_get_uint (value);
+      break;
+    case PROP_MAX_QP:
+      self->prop.max_qp = g_value_get_uint (value);
+      break;
+    case PROP_MIN_QP:
+      self->prop.min_qp = g_value_get_uint (value);
+      break;
+    case PROP_BITRATE:
+      self->prop.bitrate = g_value_get_uint (value);
+      break;
+    case PROP_TARGET_USAGE:
+      self->prop.target_usage = g_value_get_uint (value);
+      break;
+    case PROP_TARGET_PERCENTAGE:
+      self->prop.target_percentage = g_value_get_uint (value);
+      break;
+    case PROP_CPB_SIZE:
+      self->prop.cpb_size = g_value_get_uint (value);
+      break;
+    case PROP_RATE_CONTROL:
+      self->prop.rc_ctrl = g_value_get_enum (value);
+      break;
+    case PROP_LOOP_FILTER_LEVEL:
+      self->prop.filter_level = g_value_get_int (value);
+      break;
+    case PROP_SHARPNESS_LEVEL:
+      self->prop.sharpness_level = g_value_get_uint (value);
+      break;
+    case PROP_MBBRC:{
+      /* Macroblock-level rate control.
+       * 0: use default,
+       * 1: always enable,
+       * 2: always disable,
+       * other: reserved. */
+      switch (g_value_get_enum (value)) {
+        case GST_VA_FEATURE_DISABLED:
+          self->prop.mbbrc = 2;
+          break;
+        case GST_VA_FEATURE_ENABLED:
+          self->prop.mbbrc = 1;
+          break;
+        case GST_VA_FEATURE_AUTO:
+          self->prop.mbbrc = 0;
+          break;
+      }
+      break;
+    }
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+  }
+
+  GST_OBJECT_UNLOCK (self);
+}
+
+static void
+gst_va_vp9_enc_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstVaVp9Enc *const self = GST_VA_VP9_ENC (object);
+
+  GST_OBJECT_LOCK (self);
+
+  switch (prop_id) {
+    case PROP_KEYFRAME_INT:
+      g_value_set_uint (value, self->prop.keyframe_interval);
+      break;
+    case PROP_GOLDEN_GROUP_SIZE:
+      g_value_set_uint (value, self->prop.gf_group_size);
+      break;
+    case PROP_NUM_REF_FRAMES:
+      g_value_set_uint (value, self->prop.num_ref_frames);
+      break;
+    case PROP_HIERARCHICAL_LEVEL:
+      g_value_set_uint (value, self->prop.max_hierarchical_level);
+      break;
+    case PROP_QP:
+      g_value_set_uint (value, self->prop.qp);
+      break;
+    case PROP_MIN_QP:
+      g_value_set_uint (value, self->prop.min_qp);
+      break;
+    case PROP_MAX_QP:
+      g_value_set_uint (value, self->prop.max_qp);
+      break;
+    case PROP_BITRATE:
+      g_value_set_uint (value, self->prop.bitrate);
+      break;
+    case PROP_TARGET_USAGE:
+      g_value_set_uint (value, self->prop.target_usage);
+      break;
+    case PROP_TARGET_PERCENTAGE:
+      g_value_set_uint (value, self->prop.target_percentage);
+      break;
+    case PROP_CPB_SIZE:
+      g_value_set_uint (value, self->prop.cpb_size);
+      break;
+    case PROP_RATE_CONTROL:
+      g_value_set_enum (value, self->prop.rc_ctrl);
+      break;
+    case PROP_MBBRC:
+      g_value_set_enum (value, self->prop.mbbrc);
+      break;
+    case PROP_LOOP_FILTER_LEVEL:
+      g_value_set_int (value, self->prop.filter_level);
+      break;
+    case PROP_SHARPNESS_LEVEL:
+      g_value_set_uint (value, self->prop.sharpness_level);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+  }
+
+  GST_OBJECT_UNLOCK (self);
+}
+
+static void
+gst_va_vp9_enc_class_init (gpointer g_klass, gpointer class_data)
+{
+  GstCaps *src_doc_caps, *sink_doc_caps;
+  GstPadTemplate *sink_pad_templ, *src_pad_templ;
+  GObjectClass *object_class = G_OBJECT_CLASS (g_klass);
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_klass);
+  GstVideoEncoderClass *venc_class = GST_VIDEO_ENCODER_CLASS (g_klass);
+  GstVaBaseEncClass *va_enc_class = GST_VA_BASE_ENC_CLASS (g_klass);
+  GstVaVp9EncClass *vavp9enc_class = GST_VA_VP9_ENC_CLASS (g_klass);
+  GstVaDisplay *display;
+  GstVaEncoder *encoder;
+  struct CData *cdata = class_data;
+  gchar *long_name;
+  const gchar *name, *desc;
+  gint n_props = N_PROPERTIES;
+
+  if (cdata->entrypoint == VAEntrypointEncSlice) {
+    desc = "VA-API based VP9 video encoder";
+    name = "VA-API VP9 Encoder";
+  } else {
+    desc = "VA-API based VP9 low power video encoder";
+    name = "VA-API VP9 Low Power Encoder";
+  }
+
+  if (cdata->description)
+    long_name = g_strdup_printf ("%s in %s", name, cdata->description);
+  else
+    long_name = g_strdup (name);
+
+  gst_element_class_set_metadata (element_class, long_name,
+      "Codec/Encoder/Video/Hardware", desc, "He Junyan <junyan.he@intel.com>");
+
+  sink_doc_caps = gst_caps_from_string (sink_caps_str);
+  src_doc_caps = gst_caps_from_string (src_caps_str);
+
+  parent_class = g_type_class_peek_parent (g_klass);
+
+  va_enc_class->codec = VP9;
+  va_enc_class->entrypoint = cdata->entrypoint;
+  va_enc_class->render_device_path = g_strdup (cdata->render_device_path);
+
+  sink_pad_templ = gst_pad_template_new ("sink", GST_PAD_SINK, GST_PAD_ALWAYS,
+      cdata->sink_caps);
+  gst_element_class_add_pad_template (element_class, sink_pad_templ);
+
+  gst_pad_template_set_documentation_caps (sink_pad_templ, sink_doc_caps);
+  gst_caps_unref (sink_doc_caps);
+
+  src_pad_templ = gst_pad_template_new ("src", GST_PAD_SRC, GST_PAD_ALWAYS,
+      cdata->src_caps);
+  gst_element_class_add_pad_template (element_class, src_pad_templ);
+
+  gst_pad_template_set_documentation_caps (src_pad_templ, src_doc_caps);
+  gst_caps_unref (src_doc_caps);
+
+  object_class->set_property = gst_va_vp9_enc_set_property;
+  object_class->get_property = gst_va_vp9_enc_get_property;
+
+  venc_class->flush = GST_DEBUG_FUNCPTR (gst_va_vp9_enc_flush);
+  va_enc_class->reset_state = GST_DEBUG_FUNCPTR (gst_va_vp9_enc_reset_state);
+  va_enc_class->reconfig = GST_DEBUG_FUNCPTR (gst_va_vp9_enc_reconfig);
+  va_enc_class->new_frame = GST_DEBUG_FUNCPTR (gst_va_vp9_enc_new_frame);
+  va_enc_class->reorder_frame =
+      GST_DEBUG_FUNCPTR (gst_va_vp9_enc_reorder_frame);
+  va_enc_class->encode_frame = GST_DEBUG_FUNCPTR (gst_va_vp9_enc_encode_frame);
+  va_enc_class->prepare_output =
+      GST_DEBUG_FUNCPTR (gst_va_vp9_enc_prepare_output);
+
+  {
+    display =
+        gst_va_display_drm_new_from_path (va_enc_class->render_device_path);
+    encoder = gst_va_encoder_new (display, va_enc_class->codec,
+        va_enc_class->entrypoint);
+    if (gst_va_encoder_get_rate_control_enum (encoder,
+            vavp9enc_class->rate_control)) {
+      g_snprintf (vavp9enc_class->rate_control_type_name,
+          G_N_ELEMENTS (vavp9enc_class->rate_control_type_name) - 1,
+          "GstVaEncoderRateControl_%" GST_FOURCC_FORMAT "%s_%s",
+          GST_FOURCC_ARGS (va_enc_class->codec),
+          (va_enc_class->entrypoint == VAEntrypointEncSliceLP) ? "_LP" : "",
+          g_path_get_basename (va_enc_class->render_device_path));
+      vavp9enc_class->rate_control_type =
+          g_enum_register_static (vavp9enc_class->rate_control_type_name,
+          vavp9enc_class->rate_control);
+      gst_type_mark_as_plugin_api (vavp9enc_class->rate_control_type, 0);
+    }
+    gst_object_unref (encoder);
+    gst_object_unref (display);
+  }
+
+  g_free (long_name);
+  g_free (cdata->description);
+  g_free (cdata->render_device_path);
+  gst_caps_unref (cdata->src_caps);
+  gst_caps_unref (cdata->sink_caps);
+  g_free (cdata);
+
+  /**
+   * GstVaVp9Enc:key-int-max:
+   *
+   * The maximal distance between two keyframes.
+   */
+  properties[PROP_KEYFRAME_INT] = g_param_spec_uint ("key-int-max",
+      "Key frame maximal interval",
+      "The maximal distance between two keyframes. It decides the size of GOP"
+      " (0: auto-calculate)", 0, MAX_KEY_FRAME_INTERVAL, 60,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:gf-group-size:
+   *
+   * The size of the golden frame group.
+   */
+  properties[PROP_GOLDEN_GROUP_SIZE] = g_param_spec_uint ("gf-group-size",
+      "Golden frame group size",
+      "The size of the golden frame group.",
+      1, MAX_GF_GROUP_SIZE, DEFAULT_GF_GROUP_SIZE,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:ref-frames:
+   *
+   * The number of reference frames.
+   */
+  properties[PROP_NUM_REF_FRAMES] = g_param_spec_uint ("ref-frames",
+      "Number of Reference Frames",
+      "Number of reference frames, including both the forward and the backward",
+      0, 3, 3, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:hierarchical-level:
+   *
+   * The hierarchical level for golden frame group.
+   */
+  properties[PROP_HIERARCHICAL_LEVEL] =
+      g_param_spec_uint ("hierarchical-level", "The hierarchical level",
+      "The hierarchical level for golden frame group. Setting to 1 disables "
+      "all future reference", 1, HIGHEST_PYRAMID_LEVELS, HIGHEST_PYRAMID_LEVELS,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:min-qp:
+   *
+   * The minimum quantizer value.
+   */
+  properties[PROP_MIN_QP] = g_param_spec_uint ("min-qp", "Minimum QP",
+      "Minimum quantizer value for each frame", 0, 255, 0,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:max-qp:
+   *
+   * The maximum quantizer value.
+   */
+  properties[PROP_MAX_QP] = g_param_spec_uint ("max-qp", "Maximum QP",
+      "Maximum quantizer value for each frame", 1, 255, 255,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:qp:
+   *
+   * The basic quantizer value for all frames.
+   */
+  properties[PROP_QP] = g_param_spec_uint ("qp", "The frame QP",
+      "The basic quantizer value for all frames.", 0, 255, DEFAULT_BASE_QINDEX,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:bitrate:
+   *
+   * The desired target bitrate, expressed in kbps.
+   * This is not available in CQP mode.
+   *
+   * CBR: This applies equally to the minimum, maximum and target bitrate.
+   * VBR: This applies to the target bitrate. The driver will use the
+   * "target-percentage" together to calculate the minimum and maximum bitrate.
+   * VCM: This applies to the target bitrate. The minimum and maximum bitrate
+   * are not needed.
+   */
+  properties[PROP_BITRATE] = g_param_spec_uint ("bitrate", "Bitrate (kbps)",
+      "The desired bitrate expressed in kbps (0: auto-calculate)",
+      0, 2000 * 1024, 0,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:target-percentage:
+   *
+   * The target percentage of the max bitrate, and expressed in uint,
+   * equal to "target percentage"*100.
+   * "target percentage" = "target bitrate" * 100 / "max bitrate"
+   * This is available only when rate-control is VBR.
+   * The driver uses it to calculate the minimum and maximum bitrate.
+   */
+  properties[PROP_TARGET_PERCENTAGE] = g_param_spec_uint ("target-percentage",
+      "target bitrate percentage",
+      "The percentage for 'target bitrate'/'maximum bitrate' (Only in VBR)",
+      50, 100, 66,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:cpb-size:
+   *
+   * The desired max CPB size in Kb (0: auto-calculate).
+   */
+  properties[PROP_CPB_SIZE] = g_param_spec_uint ("cpb-size",
+      "max CPB size in Kb",
+      "The desired max CPB size in Kb (0: auto-calculate)", 0, 2000 * 1024, 0,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:target-usage:
+   *
+   * The target usage of the encoder. It controls and balances the encoding
+   * speed and the encoding quality. The lower value has better quality but
+   * slower speed, the higher value has faster speed but lower quality.
+   */
+  properties[PROP_TARGET_USAGE] = g_param_spec_uint ("target-usage",
+      "target usage",
+      "The target usage to control and balance the encoding speed/quality",
+      1, 7, 4, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:mbbrc:
+   *
+   * Macroblock level bitrate control.
+   * This is not compatible with Constant QP rate control.
+   */
+  properties[PROP_MBBRC] = g_param_spec_enum ("mbbrc",
+      "Macroblock level Bitrate Control",
+      "Macroblock level Bitrate Control. It is not compatible with CQP",
+      GST_TYPE_VA_FEATURE, GST_VA_FEATURE_AUTO,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:loop-filter-level:
+   *
+   * Controls the deblocking filter strength, -1 means auto calculation.
+   */
+  properties[PROP_LOOP_FILTER_LEVEL] = g_param_spec_int ("loop-filter-level",
+      "Loop Filter Level",
+      "Controls the deblocking filter strength, -1 means auto calculation",
+      -1, 63, -1,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  /**
+   * GstVaVp9Enc:sharpness-level:
+   *
+   * Controls the deblocking filter sensitivity.
+   */
+  properties[PROP_SHARPNESS_LEVEL] = g_param_spec_uint ("sharpness-level",
+      "Sharpness Level",
+      "Controls the deblocking filter sensitivity",
+      0, 7, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+
+  if (vavp9enc_class->rate_control_type > 0) {
+    properties[PROP_RATE_CONTROL] = g_param_spec_enum ("rate-control",
+        "rate control mode",
+        "The desired rate control mode for the encoder",
+        vavp9enc_class->rate_control_type,
+        vavp9enc_class->rate_control[0].value,
+        GST_PARAM_CONDITIONALLY_AVAILABLE | G_PARAM_READWRITE |
+        G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT);
+  } else {
+    n_props--;
+    properties[PROP_RATE_CONTROL] = NULL;
+  }
+
+  g_object_class_install_properties (object_class, n_props, properties);
+
+  /**
+   * GstVaFeature:
+   * @GST_VA_FEATURE_DISABLED: The feature is disabled.
+   * @GST_VA_FEATURE_ENABLED: The feature is enabled.
+   * @GST_VA_FEATURE_AUTO: The feature is enabled automatically.
+   *
+   * Since: 1.22
+   */
+  gst_type_mark_as_plugin_api (GST_TYPE_VA_FEATURE, 0);
+}
+
+static GstCaps *
+_complete_src_caps (GstCaps * srccaps)
+{
+  GstCaps *caps = gst_caps_copy (srccaps);
+  GValue val = G_VALUE_INIT;
+
+  g_value_init (&val, G_TYPE_STRING);
+  g_value_set_string (&val, "super-frame");
+  gst_caps_set_value (caps, "alignment", &val);
+  g_value_unset (&val);
+
+  return caps;
+}
+
+gboolean
+gst_va_vp9_enc_register (GstPlugin * plugin, GstVaDevice * device,
+    GstCaps * sink_caps, GstCaps * src_caps, guint rank,
+    VAEntrypoint entrypoint)
+{
+  static GOnce debug_once = G_ONCE_INIT;
+  GType type;
+  GTypeInfo type_info = {
+    .class_size = sizeof (GstVaVp9EncClass),
+    .class_init = gst_va_vp9_enc_class_init,
+    .instance_size = sizeof (GstVaVp9Enc),
+    .instance_init = gst_va_vp9_enc_init,
+  };
+  struct CData *cdata;
+  gboolean ret;
+  gchar *type_name, *feature_name;
+
+  g_return_val_if_fail (GST_IS_PLUGIN (plugin), FALSE);
+  g_return_val_if_fail (GST_IS_VA_DEVICE (device), FALSE);
+  g_return_val_if_fail (GST_IS_CAPS (sink_caps), FALSE);
+  g_return_val_if_fail (GST_IS_CAPS (src_caps), FALSE);
+  g_return_val_if_fail (entrypoint == VAEntrypointEncSlice ||
+      entrypoint == VAEntrypointEncSliceLP, FALSE);
+
+  cdata = g_new (struct CData, 1);
+  cdata->entrypoint = entrypoint;
+  cdata->description = NULL;
+  cdata->render_device_path = g_strdup (device->render_device_path);
+  cdata->sink_caps = gst_caps_ref (sink_caps);
+  cdata->src_caps = _complete_src_caps (src_caps);
+
+  /* class data will be leaked if the element never gets instantiated */
+  GST_MINI_OBJECT_FLAG_SET (cdata->sink_caps,
+      GST_MINI_OBJECT_FLAG_MAY_BE_LEAKED);
+  GST_MINI_OBJECT_FLAG_SET (cdata->src_caps,
+      GST_MINI_OBJECT_FLAG_MAY_BE_LEAKED);
+
+  type_info.class_data = cdata;
+  if (entrypoint == VAEntrypointEncSlice) {
+    type_name = g_strdup ("GstVaVp9Enc");
+    feature_name = g_strdup ("vavp9enc");
+  } else {
+    type_name = g_strdup ("GstVaVp9LPEnc");
+    feature_name = g_strdup ("vavp9lpenc");
+  }
+
+  /* The first encoder to be registered should use a constant name,
+   * like vavp9enc, for any additional encoders, we create unique
+   * names, using inserting the render device name. */
+  if (g_type_from_name (type_name)) {
+    gchar *basename = g_path_get_basename (device->render_device_path);
+    g_free (type_name);
+    g_free (feature_name);
+    if (entrypoint == VAEntrypointEncSlice) {
+      type_name = g_strdup_printf ("GstVa%sVp9Enc", basename);
+      feature_name = g_strdup_printf ("va%svp9enc", basename);
+    } else {
+      type_name = g_strdup_printf ("GstVa%sVp9LPEnc", basename);
+      feature_name = g_strdup_printf ("va%svp9lpenc", basename);
+    }
+    cdata->description = basename;
+    /* lower rank for non-first device */
+    if (rank > 0)
+      rank--;
+  }
+
+  g_once (&debug_once, _register_debug_category, NULL);
+  type = g_type_register_static (GST_TYPE_VA_BASE_ENC,
+      type_name, &type_info, 0);
+  ret = gst_element_register (plugin, feature_name, rank, type);
+
+  g_free (type_name);
+  g_free (feature_name);
+
+  return ret;
+}
diff --git a/sys/va/gstvavp9enc.h b/sys/va/gstvavp9enc.h
new file mode 100644
index 0000000..94db2e8
--- /dev/null
+++ b/sys/va/gstvavp9enc.h
@@ -0,0 +1,34 @@
+/* GStreamer
+ *  Copyright (C) 2022 Intel Corporation
+ *     Author: He Junyan <junyan.he@intel.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#pragma once
+
+#include "gstvadevice.h"
+
+G_BEGIN_DECLS
+
+gboolean     gst_va_vp9_enc_register                 (GstPlugin * plugin,
+                                                      GstVaDevice * device,
+                                                      GstCaps * sink_caps,
+                                                      GstCaps * src_caps,
+                                                      guint rank,
+                                                      VAEntrypoint entrypoint);
+
+G_END_DECLS
diff --git a/sys/va/meson.build b/sys/va/meson.build
index b12f9b3..0bc61d8 100644
--- a/sys/va/meson.build
+++ b/sys/va/meson.build
@@ -21,6 +21,7 @@ va_sources = [
   'gstvaprofile.c',
   'gstvavp8dec.c',
   'gstvavp9dec.c',
+  'gstvavp9enc.c',
   'gstvavpp.c',
 ]
 
@@ -39,6 +40,9 @@ cdata.set10('HAVE_GUDEV', libgudev_dep.found())
 if libva_dep.version().version_compare('>= 1.8')
   va_sources += 'gstvaav1dec.c'
 endif
+if libva_dep.version().version_compare('>= 1.15')
+  va_sources += 'gstvaav1enc.c'
+endif
 
 driverdir = libva_dep.get_variable('driverdir', default_value: '')
 if driverdir == ''
@@ -54,7 +58,7 @@ gstva = library('gstva',
   va_sources,
   c_args : gst_plugins_bad_args + gstva_cargs,
   include_directories : [configinc],
-  dependencies : [gstcodecs_dep, gstva_dep, libgudev_dep] + extra_dep,
+  dependencies : [gstcodecs_dep, gstva_dep, libgudev_dep, libm] + extra_dep,
   install : true,
   install_dir : plugins_install_dir,
 )
diff --git a/sys/va/plugin.c b/sys/va/plugin.c
index 937fa04..1de6e4f 100644
--- a/sys/va/plugin.c
+++ b/sys/va/plugin.c
@@ -28,6 +28,7 @@
 #endif
 
 #include "gstvaav1dec.h"
+#include "gstvaav1enc.h"
 #include "gstvacaps.h"
 #include "gstvacompositor.h"
 #include "gstvadeinterlace.h"
@@ -42,6 +43,7 @@
 #include "gstvaprofile.h"
 #include "gstvavp8dec.h"
 #include "gstvavp9dec.h"
+#include "gstvavp9enc.h"
 #include "gstvavpp.h"
 
 #define GST_CAT_DEFAULT gstva_debug
@@ -203,6 +205,22 @@ plugin_register_encoders (GstPlugin * plugin, GstVaDevice * device,
               device->render_device_path);
         }
         break;
+      case VP9:
+        if (!gst_va_vp9_enc_register (plugin, device, sinkcaps, srccaps,
+                GST_RANK_NONE, entrypoint)) {
+          GST_WARNING ("Failed to register VP9 encoder: %s",
+              device->render_device_path);
+        }
+        break;
+#if VA_CHECK_VERSION(1, 15, 0)
+      case AV1:
+        if (!gst_va_av1_enc_register (plugin, device, sinkcaps, srccaps,
+                GST_RANK_NONE, entrypoint)) {
+          GST_WARNING ("Failed to register AV1 encoder: %s",
+              device->render_device_path);
+        }
+        break;
+#endif
       default:
         GST_DEBUG ("No encoder implementation for %" GST_FOURCC_FORMAT,
             GST_FOURCC_ARGS (codec));
-- 
2.40.0

